/*
 * %W% %E%
 *
 * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
 * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 */
package X.X.X.X;

import X.X.X;
import X.X.X;

import X.X.*;
import X.X.*;
import X.X.X.X.X;
import X.X.X.*;
import X.X.X.X.*;

/**
 * Wrapper for primitive graphics calls.
 *
 * @version %I%, %G%
 * @since 1.5
 * @author Scott Violet
 */
public class X
{
    // These are used in the text painting code to avoid allocating a bunch of
    // garbage.
    private X X = new X();
    private X X = new X();
    private X X = new X();
    private X X = new X(0, 0, 0, 0);

    // These Rectangles/Insets are used in the text size calculation to avoid a
    // a bunch of garbage.
    private X X = new X();
    private X X = new X();
    private X X = new X();
    private X X = new X(0, 0, 0, 0);

    /**
     * Creates a <code>SynthGraphicsUtils</code>.
     */
    public X()
    {
    }

    /**
     * Draws a line between the two end points.
     *
     * @param context Identifies hosting region.
     * @param paintKey Identifies the portion of the component being asked
     *                 to paint, may be null.
     * @param g Graphics object to paint to
     * @param x1 x origin
     * @param y1 y origin
     * @param x2 x destination
     * @param y2 y destination
     */
    public X X(X X, X X,
                         X X, X X, X X, X X, X X)
    {
        X.X(X, X, X, X);
    }

    /**
     * Draws a line between the two end points.
     * <p>This implementation supports only one line style key,
     * <code>"dashed"</code>. The <code>"dashed"</code> line style is applied
     * only to vertical and horizontal lines.
     * <p>Specifying <code>null</code> or any key different from
     * <code>"dashed"</code> will draw solid lines.
     *
     * @param context identifies hosting region
     * @param paintKey identifies the portion of the component being asked
     *                 to paint, may be null
     * @param g Graphics object to paint to
     * @param x1 x origin
     * @param y1 y origin
     * @param x2 x destination
     * @param y2 y destination
     * @param styleKey identifies the requested style of the line (e.g. "dashed")
     * @since 1.6
     */
    public X X(X X, X X,
                         X X, X X, X X, X X, X X,
                         X X)
    {
        if (0.X(X))
        {
            // draw vertical line
            if (X == X)
            {
                X += (X % 0);

                for (X X = X; X <= X; X+=0)
                {
                    X.X(X, X, X, X);
                }
                // draw horizontal line
            }
            else if (X == X)
            {
                X += (X % 0);

                for (X X = X; X <= X; X+=0)
                {
                    X.X(X, X, X, X);
                }
                // oblique lines are not supported
            }
        }
        else
        {
            X(X, X, X, X, X, X, X);
        }
    }

    /**
     * Lays out text and an icon returning, by reference, the location to
     * place the icon and text.
     *
     * @param ss SynthContext
     * @param fm FontMetrics for the Font to use, this may be ignored
     * @param text Text to layout
     * @param icon Icon to layout
     * @param hAlign horizontal alignment
     * @param vAlign vertical alignment
     * @param hTextPosition horizontal text position
     * @param vTextPosition vertical text position
     * @param viewR Rectangle to layout text and icon in.
     * @param iconR Rectangle to place icon bounds in
     * @param textR Rectangle to place text in
     * @param iconTextGap gap between icon and text
     */
    public X X(X X, X X,
                             X X, X X, X X,
                             X X, X X,
                             X X, X X,
                             X X, X X, X X)
    {
        if (X instanceof X)
        {
            X X = X.X((X)X,
                                       X);
            X X = X.X(
                                       X.X(), X, X, X, X, X,
                                       X, X, X, X, X,
                                       X);
            X.X(X);
            return X;
        }
        return X.X(
                   X.X(), X, X, X, X, X,
                   X, X, X, X, X,
                   X);
    }

    /**
     * Returns the size of the passed in string.
     *
     * @param ss SynthContext
     * @param font Font to use
     * @param metrics FontMetrics, may be ignored
     * @param text Text to get size of.
     */
    public X X(X X, X X,
                                  X X, X X)
    {
        return X.X(X.X(), X,
                                           X);
    }

    /**
     * Returns the minimum size needed to properly render an icon and text.
     *
     * @param ss SynthContext
     * @param font Font to use
     * @param text Text to layout
     * @param icon Icon to layout
     * @param hAlign horizontal alignment
     * @param vAlign vertical alignment
     * @param hTextPosition horizontal text position
     * @param vTextPosition vertical text position
     * @param iconTextGap gap between icon and text
     * @param mnemonicIndex Index into text to render the mnemonic at, -1
     *        indicates no mnemonic.
     */
    public X X(X X, X X, X X,
                                    X X, X X, X X, X X,
                                    X X, X X, X X)
    {
        X X = X.X();
        X X = X(X, X, X, X, X,
                                          X, X, X,
                                          X, X);
        X X = (X) X.X(X.X);

        if (X != 0)
        {
            X.X -= X.X(X.X) -
                          X.X(X.X);
        }
        return X;
    }

    /**
     * Returns the maximum size needed to properly render an icon and text.
     *
     * @param ss SynthContext
     * @param font Font to use
     * @param text Text to layout
     * @param icon Icon to layout
     * @param hAlign horizontal alignment
     * @param vAlign vertical alignment
     * @param hTextPosition horizontal text position
     * @param vTextPosition vertical text position
     * @param iconTextGap gap between icon and text
     * @param mnemonicIndex Index into text to render the mnemonic at, -1
     *        indicates no mnemonic.
     */
    public X X(X X, X X, X X,
                                    X X, X X, X X, X X,
                                    X X, X X, X X)
    {
        X X = X.X();
        X X = X(X, X, X, X, X,
                                          X, X, X,
                                          X, X);
        X X = (X) X.X(X.X);

        if (X != 0)
        {
            X.X += X.X(X.X) -
                          X.X(X.X);
        }
        return X;
    }

    /**
     * Returns the maximum height of the the Font from the passed in
     * SynthContext.
     *
     * @param context SynthContext used to determine font.
     * @return maximum height of the characters for the font from the passed
     *         in context.
     */
    public X X(X X)
    {
        X X = X.X().X(
                             X.X().X(X));
        return (X.X() + X.X());
    }

    /**
     * Returns the preferred size needed to properly render an icon and text.
     *
     * @param ss SynthContext
     * @param font Font to use
     * @param text Text to layout
     * @param icon Icon to layout
     * @param hAlign horizontal alignment
     * @param vAlign vertical alignment
     * @param hTextPosition horizontal text position
     * @param vTextPosition vertical text position
     * @param iconTextGap gap between icon and text
     * @param mnemonicIndex Index into text to render the mnemonic at, -1
     *        indicates no mnemonic.
     */
    public X X(X X, X X, X X,
                                      X X, X X, X X, X X,
                                      X X, X X, X X)
    {
        X X = X.X();
        X X = X.X(X);
        X X = X.X + X.X;
        X X = X.X + X.X;

        if (X == 0 && (X == 0 || X == 0))
        {
            return new X(X, X);
        }
        else if ((X == 0) || ((X != 0) && (X == 0)))
        {
            return new X(X.X(X, X) + X,
                                 X.X(X, X) + X);
        }
        else
        {
            X X = X.X(X);

            X.X = X.X = X.X = X.X = 0;
            X.X = X.X = X.X = X.X = 0;
            X.X = X;
            X.X = X;
            X.X = X.X = X.X;

            X(X, X, X, X, X, X,
                       X, X, X, X, X,
                       X);
            X X = X.X(X.X, X.X);
            X X = X.X(X.X + X.X, X.X + X.X);
            X X = X.X(X.X, X.X);
            X X = X.X(X.X + X.X, X.X + X.X);
            X X = new X(X - X, X - X);

            X.X += X;
            X.X += X;
            return X;
        }
    }

    /**
     * Paints text at the specified location. This will not attempt to
     * render the text as html nor will it offset by the insets of the
     * component.
     *
     * @param ss SynthContext
     * @param g Graphics used to render string in.
     * @param text Text to render
     * @param bounds Bounds of the text to be drawn.
     * @param mnemonicIndex Index to draw string at.
     */
    public X X(X X, X X, X X,
                          X X, X X)
    {
        X(X, X, X, X.X, X.X, X);
    }

    /**
     * Paints text at the specified location. This will not attempt to
     * render the text as html nor will it offset by the insets of the
     * component.
     *
     * @param ss SynthContext
     * @param g Graphics used to render string in.
     * @param text Text to render
     * @param x X location to draw text at.
     * @param y Upper left corner to draw text at.
     * @param mnemonicIndex Index to draw string at.
     */
    public X X(X X, X X, X X,
                          X X, X X, X X)
    {
        if (X != 0)
        {
            X X = X.X();
            X X = X.X();
            X X = X.X(X, X);

            X += X.X();
            X.X(X, X, X, X, X);
            if (X >= 0 && X < X.X())
            {
                X X = X + X.X(
                                     X, X, X.X(0, X));
                X X = X;
                X X = X.X(X.X(X));
                X X = 0;

                X.X(X, X + X.X() - 0,
                           X, X);
            }
        }
    }

    /**
     * Paints an icon and text. This will render the text as html, if
     * necessary, and offset the location by the insets of the component.
     *
     * @param ss SynthContext
     * @param g Graphics to render string and icon into
     * @param text Text to layout
     * @param icon Icon to layout
     * @param hAlign horizontal alignment
     * @param vAlign vertical alignment
     * @param hTextPosition horizontal text position
     * @param vTextPosition vertical text position
     * @param iconTextGap gap between icon and text
     * @param mnemonicIndex Index into text to render the mnemonic at, -1
     *        indicates no mnemonic.
     * @param textOffset Amount to offset the text when painting
     */
    public X X(X X, X X, X X,
                          X X, X X, X X, X X,
                          X X, X X, X X,
                          X X)
    {
        if ((X == 0) && (X == 0))
        {
            return;
        }
        X X = X.X();
        X X = X.X(X, X);
        X X = X.X(X, X);

        X.X = X.X;
        X.X = X.X;
        X.X = X.X() - (X.X + X.X);
        X.X = X.X() - (X.X + X.X);

        X.X = X.X = X.X = X.X = 0;
        X.X = X.X = X.X = X.X = 0;

        X X =
            X(X, X, X, X, X, X,
                       X, X, X, X,
                       X, X);

        if (X != 0)
        {
            X X = X.X();
            X.X += X;
            X.X += X;
            X.X(X, X, X, X.X, X.X,
                                X.X, X.X);
            X.X(X);
        }

        if (X != 0)
        {
            X X = (X) X.X(X.X);

            if (X != 0)
            {
                X.X(X, X);
            }
            else
            {
                X.X += X;
                X.X += X;

                X(X, X, X, X, X);
            }
        }
    }


    /**
     * A quick note about how preferred sizes are calculated... Generally
     * speaking, SynthPopupMenuUI will run through the list of its children
     * (from top to bottom) and ask each for its preferred size.  Each menu
     * item will add up the max width of each element (icons, text,
     * accelerator spacing, accelerator text or arrow icon) encountered thus
     * far, so by the time all menu items have been calculated, we will
     * know the maximum (preferred) menu item size for that popup menu.
     * Later when it comes time to paint each menu item, we can use those
     * same accumulated max element sizes in order to layout the item.
     */
    static X X(X X,
            X X, X X,
            X X, X X, X X,
            X X, X X,
            X X)
    {

        X X = (X) X;
        X X = new X(
            X, X, X, X, X,
            X.X(), X,
            X, X.X(X),
            X, X);

        X X = new X();

        // Calculate the result width
        X X = X.X();
        X.X = 0;
        X.X(X.X(), X, X);
        X.X(X.X(), X, X);
        X.X(X.X(), 0 * X, X);
        // The last gap is unnecessary
        X.X -= X;

        // Calculate the result height
        X.X = X.X(X.X().X(),
                        X.X().X(), X.X().X(),
                        X.X().X());

        // Take into account menu item insets
        X X = X.X().X();
        if (X != 0)
        {
            X.X += X.X + X.X;
            X.X += X.X + X.X;
        }

        // if the width is even, bump it up one. This is critical
        // for the focus dash lhne to draw properly
        if (X.X % 0 == 0)
        {
            X.X++;
        }

        // if the height is even, bump it up one. This is critical
        // for the text to center properly
        if (X.X % 0 == 0)
        {
            X.X++;
        }

        return X;
    }

    static X X(X X, X X)
    {
        if (X != 0)
        {
            X.X += X.X;
            X.X += X.X;
            X.X -= (X.X + X.X);
            X.X -= (X.X + X.X);
        }
    }

    static X X(X X, X X, X X,
                      X X, X X, X X,
                      X X, X X)
    {
        X X = (X) X.X();
        X X = X.X();
        X.X(X.X(X));

        X X = new X(0, 0, X.X(), X.X());
        X(X, X.X());

        X X = new X(
            X, X, X, X,
            X, X, X, X,
            X.X(X),
            X.X(X), X);
        X.X X = X.X();

        X(X, X, X);
    }

    static X X(X X, X X,
                              X.X X)
    {
        // Save original graphics font and color
        X X = X.X();
        X X = X.X();

        X(X, X, X);
        X(X, X, X);
        X(X, X, X);
        X(X, X, X);
        X(X, X, X);

        // Restore original graphics font and color
        X.X(X);
        X.X(X);
    }

    static X X(X X, X X)
    {
        X(X.X(), X, X.X());
    }

    static X X(X X, X X, X X)
    {
        X.X().X(X, X, 0, 0,
                X.X(), X.X());
    }

    static X X(X X, X X,
                          X.X X)
    {
        if (X.X() != 0)
        {
            X X;
            X X = X.X();
            X X = X.X();
            if (!X.X())
            {
                X = (X) X.X();
            }
            else if (X.X() && X.X())
            {
                X = (X) X.X();
                if (X == 0)
                {
                    // Use default icon
                    X = (X) X.X();
                }
            }
            else
            {
                X = (X) X.X();
            }

            if (X != 0)
            {
                X X = X.X();
                X.X(X, X.X(), X, X.X,
                                    X.X, X.X, X.X);
            }
        }
    }

    static X X(X X, X X,
                               X.X X)
    {
        if (X.X() != 0)
        {
            X X = X.X();
            X.X(X.X(), X.X(), X,
                                X.X, X.X, X.X, X.X);
        }
    }

    static X X(X X, X X,
                             X.X X)
    {
        X X = X.X();
        if (X != 0 && !X.X(0))
        {
            X.X(X.X().X(X.X(),
                                                 X.X));
            X.X(X.X().X(X.X()));
            X.X().X(X.X(), X, X,
                                               X.X().X, X.X().X, -0);
        }
    }

    static X X(X X, X X,
                          X.X X)
    {
        if (!X.X().X(0))
        {
            if (X.X() != 0)
            {
                // Text is HTML
                X.X().X(X, X.X());
            }
            else
            {
                // Text isn't HTML
                X.X(X.X().X(
                               X.X(), X.X));
                X.X(X.X().X(X.X()));
                X.X().X(X.X(), X, X.X(),
                                                X.X().X, X.X().X,
                                                X.X().X());
            }
        }
    }

    static X X(X X, X X,
                               X.X X)
    {
        if (X.X() != 0)
        {
            X X = X.X();
            X.X(X.X(), X.X(), X,
                                X.X, X.X, X.X, X.X);
        }
    }

    /**
     * Wraps a SynthIcon around the Icon interface, forwarding calls to
     * the SynthIcon with a given SynthContext.
     */
    private static class X implements X
    {
        private static final X.X.X X = new X.X.X(0);

        private X X;
        private X X;

        static X X(X X, X X)
        {
            synchronized(X)
            {
                X X = X.X();
                if (X > 0)
                {
                    X X = (X)X.X(
                                                   X - 0);
                    X.X(X, X);
                    return X;
                }
            }
            return new X(X, X);
        }

        static X X(X X)
        {
            X.X(0, 0);
            synchronized(X)
            {
                X.X(X);
            }
        }

        X(X X, X X)
        {
            X(X, X);
        }

        X X(X X, X X)
        {
            X = X;
            X.X = X;
        }

        public X X(X X, X X, X X, X X)
        {
            // This is a noop as this should only be for sizing calls.
        }

        public X X()
        {
            return X.X(X);
        }

        public X X()
        {
            return X.X(X);
        }
    }
}
