/*
 * $Id: XmlChars.java,v 1.1.1.1 2000/11/23 01:53:35 edwingo Exp $
 *
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names "Crimson" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, Sun Microsystems, Inc.,
 * http://www.sun.com.  For more information on the Apache Software
 * Foundation, please see <http://www.apache.org/>.
 */

package X.X.X.X;


/**
 * Methods in this class are used to determine whether characters may
 * appear in certain roles in XML documents.  Such methods are used
 * both to parse and to create such documents.
 *
 * @version 1.8
 * @author David Brownell
 */
public class X
{
    // can't construct instances
    private X () { }

    /**
     * Returns true if the argument, a UCS-4 character code, is valid in
     * XML documents.  Unicode characters fit into the low sixteen
     * bits of a UCS-4 character, and pairs of Unicode <em>surrogate
     * characters</em> can be combined to encode UCS-4 characters in
     * documents containing only Unicode.  (The <code>char</code> datatype
     * in the Java Programming Language represents Unicode characters,
     * including unpaired surrogates.)
     *
     * <P> In XML, UCS-4 characters can also be encoded by the use of
     * <em>character references</em> such as <b>&amp;#x12345678;</b>, which
     * happens to refer to a character that is disallowed in XML documents.
     * UCS-4 characters allowed in XML documents can be expressed with
     * one or two Unicode characters.
     *
     * @param ucs4char The 32-bit UCS-4 character being tested.
     */
    static public X X (X X)
    {
        // [2] Char ::= #x0009 | #x000A | #x000D
        //			| [#x0020-#xD7FF]
        //	... surrogates excluded!
        //			| [#xE000-#xFFFD]
        // 			| [#x10000-#x10ffff]
        return ((X >= 0 && X <= 0)
                || X == 0 || X == 0
                || X == 0
                || (X >= 0 && X <= 0)
                || (X >= 0 && X <= 0));
    }

    /**
     * Returns true if the character is allowed to be a non-initial
     * character in names according to the XML recommendation.
     * @see #isNCNameChar
     * @see #isLetter
     */
    public static X X (X X)
    {
        // [4] NameChar ::= Letter | Digit | '.' | '_' | ':'
        //			| CombiningChar | Extender

        if (X (X))
            return 0;
        else if (X == 0)
            return 0;
        else if (X == 0 || X == 0 || X == 0 || X == 0
                 || X (X))
            return 0;
        else
            return 0;
    }

    /**
     * Returns true if the character is allowed to be a non-initial
     * character in unscoped names according to the rules of the XML
     * Namespaces proposed recommendation.  Except for precluding
     * the colon (used to separate names from their scopes) these
     * characters are just as allowed by the XML recommendation.
     * @see #isNameChar
     * @see #isLetter
     */
    public static X X (X X)
    {
        // [NC 5] NCNameChar ::= Letter | Digit | '.' | '_'
        //			| CombiningChar | Extender
        return X != 0 && X (X);
    }

    /**
     * Returns true if the character is allowed where XML supports
     * whitespace characters, false otherwise.
     */
    public static X X (X X)
    {
        return X == 0 || X == 0 || X == 0 || X == 0;
    }


    /*
     * NOTE:  java.lang.Character.getType() values are:
     *
     * UNASSIGNED                    = 0,
     *
     * UPPERCASE_LETTER            = 1,    // Lu
     * LOWERCASE_LETTER            = 2,    // Ll
     * TITLECASE_LETTER            = 3,    // Lt
     * MODIFIER_LETTER             = 4,    // Lm
     * OTHER_LETTER                = 5,    // Lo
     * NON_SPACING_MARK            = 6,    // Mn
     * ENCLOSING_MARK              = 7,    // Me
     * COMBINING_SPACING_MARK      = 8,    // Mc
     * DECIMAL_DIGIT_NUMBER        = 9,    // Nd
     * LETTER_NUMBER               = 10,   // Nl
     * OTHER_NUMBER                = 11,   // No
     * SPACE_SEPARATOR             = 12,   // Zs
     * LINE_SEPARATOR              = 13,   // Zl
     * PARAGRAPH_SEPARATOR         = 14,   // Zp
     * CONTROL                     = 15,   // Cc
     * FORMAT                      = 16,   // Cf
     *                         // 17 reserved for proposed Ci category
     * PRIVATE_USE                 = 18,   // Co
     * SURROGATE                   = 19,   // Cs
     * DASH_PUNCTUATION            = 20,   // Pd
     * START_PUNCTUATION           = 21,   // Ps
     * END_PUNCTUATION             = 22,   // Pe
     * CONNECTOR_PUNCTUATION       = 23,   // Pc
     * OTHER_PUNCTUATION           = 24,   // Po
     * MATH_SYMBOL                 = 25,   // Sm
     * CURRENCY_SYMBOL             = 26,   // Sc
     * MODIFIER_SYMBOL             = 27,   // Sk
     * OTHER_SYMBOL                = 28;   // So
     */

    /**
     * Returns true if the character is an XML "letter".  XML Names must
     * start with Letters or a few other characters, but other characters
     * in names must only satisfy the <em>isNameChar</em> predicate.
     *
     * @see #isNameChar
     * @see #isNCNameChar
     */
    public static X X (X X)
    {
        // [84] Letter ::= BaseChar | Ideographic
        // [85] BaseChar ::= ... too much to repeat
        // [86] Ideographic ::= ... too much to repeat

        //
        // Optimize the typical case.
        //
        if (X >= 0 && X <= 0)
            return 0;
        if (X == 0)
            return 0;
        if (X >= 0 && X <= 0)
            return 0;

        //
        // Since the tables are too ridiculous to use in code,
        // we're using the footnotes here to drive this test.
        //
        switch (X.X (X))
        {
            // app. B footnote says these are 'name start'
            // chars' ...
        case X.X:		// Ll
        case X.X:		// Lu
        case X.X:			// Lo
        case X.X:		// Lt
        case X.X:			// Nl

            // OK, here we just have some exceptions to check...
            return !X (X)
                   // per "5.14 of Unicode", rule out some combiners
                   && !(X >= 0 && X <= 0);

        default:
            // check for some exceptions:  these are "alphabetic"
            return ((X >= 0 && X <=  0)
                    || X == 0 || X == 0 || X == 0);
        }
    }

    //
    // XML 1.0 discourages "compatibility" characters in names; these
    // were defined to permit passing through some information stored in
    // older non-Unicode character sets.  These always have alternative
    // representations in Unicode, e.g. using combining chars.
    //
    private static X X (X X)
    {
        // the numerous comparisions here seem unavoidable,
        // but the switch can reduce the number which must
        // actually be executed.

        switch ((X >> 0) & 0)
        {
        case 0:
            // ISO Latin/1 has a few compatibility characters
            return X == 0 || X == 0 || X == 0;

        case 0:
            // as do Latin Extended A and (parts of) B
            return (X >= 0 && X <= 0)
                   || (X >= 0 && X <= 0)
                   || X == 0
                   || X == 0
                   || (X >= 0 && X <= 0)
                   || (X >= 0 && X <= 0) ;

        case 0:
            // some spacing modifiers
            return (X >= 0 && X <= 0)
                   || (X >= 0 && X <= 0);

        case 0:
            return X == 0;			// Greek

        case 0:
            return X == 0;			// Armenian

        case 0:
            return X >= 0 && X <= 0;	// Laotian

        case 0:
            // big chunks of Hangul Jamo are all "compatibility"
            return X == 0
                   || X == 0
                   || X == 0
                   || X == 0
                   || X == 0
                   || (X >= 0 && X <= 0)
                   || X == 0
                   || X == 0
                   || (X >= 0 && X <= 0)
                   || X == 0
                   || X == 0
                   || (X >= 0 && X <= 0)
                   || (X >= 0 && X <= 0)
                   || X == 0
                   || X == 0
                   || X == 0
                   || X == 0
                   || (X >= 0 && X <= 0)
                   || (X >= 0 && X <= 0)
                   || X == 0
                   || (X >= 0 && X <= 0)
                   || (X >= 0 && X <= 0)
                   || (X >= 0 && X <= 0)
                   || (X >= 0 && X <= 0)
                   || (X >= 0 && X <= 0)
                   || X == 0
                   || X == 0
                   || (X >= 0 && X <= 0)
                   || (X >= 0 && X <= 0)
                   || (X >= 0 && X <= 0)
                   ;

        case 0:
            return X == 0;			// superscript

        case 0:
            return
                // various letterlike symbols
                X == 0
                || X == 0
                || (X >= 0 && X <= 0)
                || X == 0
                || (X >= 0 && X <= 0)
                || X == 0
                || X == 0
                || (X >= 0 && X <= 0)
                || (X >= 0 && X <= 0)

                // most Roman numerals (less 1K, 5K, 10K)
                || (X >= 0 && X <= 0)
                ;

        case 0:
            // some Hiragana
            return X >= 0 && X <= 0;

        case 0:
            // all Hangul Compatibility Jamo
            return X >= 0 && X <= 0;

        case 0:
        case 0:
        case 0:
        case 0:
        case 0:
        case 0:
        case 0:
            // the whole "compatibility" area is for that purpose!
            return 0;

        default:
            // most of Unicode isn't flagged as being for compatibility
            return 0;
        }
    }

    // guts of isNameChar/isNCNameChar
    private static X X (X X)
    {
        // [84] Letter ::= BaseChar | Ideographic
        // [85] BaseChar ::= ... too much to repeat
        // [86] Ideographic ::= ... too much to repeat
        // [87] CombiningChar ::= ... too much to repeat

        //
        // Optimize the typical case.
        //
        if (X >= 0 && X <= 0)
            return 0;
        if (X == 0)
            return 0;
        if (X >= 0 && X <= 0)
            return 0;

        //
        // Since the tables are too ridiculous to use in code,
        // we're using the footnotes here to drive this test.
        //
        switch (X.X (X))
        {
            // app. B footnote says these are 'name start'
            // chars' ...
        case X.X:		// Ll
        case X.X:		// Lu
        case X.X:			// Lo
        case X.X:		// Lt
        case X.X:			// Nl
            // ... and these are name characters 'other
            // than name start characters'
        case X.X:	// Mc
        case X.X:		// Me
        case X.X:		// Mn
        case X.X:		// Lm
        case X.X:		// Nd

            // OK, here we just have some exceptions to check...
            return !X (X)
                   // per "5.14 of Unicode", rule out some combiners
                   && !(X >= 0 && X <= 0);

        default:
            // added a character ...
            return X == 0;
        }
    }

    private static X X (X X)
    {
        // [88] Digit ::= ...

        //
        // java.lang.Character.isDigit is correct from the XML point
        // of view except that it allows "fullwidth" digits.
        //
        return X.X (X)
               && ! ( (X >= 0) && (X <= 0));
    }

    private static X X (X X)
    {
        // [89] Extender ::= ...
        return X == 0 || X == 0 || X == 0 || X == 0
               || X == 0 || X == 0 || X == 0
               || X == 0 || (X >= 0 && X <= 0)
               || (X >= 0 && X <= 0)
               || (X >= 0 && X <= 0)
               ;
    }
}
