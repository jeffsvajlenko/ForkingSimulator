/*
 * Copyright 1999-2005 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package X.X.X.X.X.X.X;

import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;

import X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X;
import X.X.X.X;
import X.X.X.X;
import X.X.X.X;
import X.X.X.X;
import X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X;
import X.X.X.X;
import X.X.X.X;
import X.X.X.X;
import X.X.X.X;
import X.X.X.X;
import X.X.X.X;
import X.X.X.X;
import X.X.X.X;
import X.X.X.X;
import X.X.X.X.X;
import X.X.X.X.X;
import X.X.X.X.X;
import X.X.X.X.X;


/**
 * EXPERIMENTAL: Implemenatation of DOM Level 3 org.w3c.ls.LSSerializer  by delegating serialization
 * calls to <CODE>XMLSerializer</CODE>.
 * LSSerializer provides an API for serializing (writing) a DOM document out in an
 * XML document. The XML data is written to an output stream.
 * During serialization of XML data, namespace fixup is done when possible as
 * defined in DOM Level 3 Core, Appendix B.
 *
 * @author Elena Litani, IBM
 * @author Gopal Sharma, Sun Microsystems
 * @author Arun Yadav, Sun Microsystems
 * @author Sunitha Reddy, Sun Microsystems
 * @version $Id: DOMSerializerImpl.java,v 1.7 2007/07/19 04:39:18 ofung Exp $
 */
public class X implements X, X
{

    // TODO: When DOM Level 3 goes to REC replace method calls using
    // reflection for: getXmlEncoding, getInputEncoding and getXmlEncoding
    // with regular static calls on the Document object.

    // data
    // serializer
    private X X;

    // XML 1.1 serializer
    private X X;

    //Recognized parameters
    private X X;

    /** REVISIT: Currently we handle 3 different configurations, would be nice just have one configuration
     * that has different recognized parameters depending if it is used in Core/LS.
     */
    protected X X = 0;

    protected final static X X          = 0<<0;
    protected final static X X          = 0<<0;
    protected final static X X            = 0<<0;
    protected final static X X               = 0<<0;
    protected final static X X          = 0<<0;
    protected final static X X            = 0<<0;
    protected final static X X      = 0<<0;
    protected final static X X             = 0<<0;
    protected final static X X             = 0<<0;
    protected final static X X              = 0<<0;
    protected final static X X = 0<<0;
    protected final static X X = 0<<0;

    // well-formness checking
    private X X = 0;
    private final X X = new X();
    private final X X = new X();
    private static final X X = new X();

    /**
     * Constructs a new LSSerializer.
     * The constructor turns on the namespace support in <code>XMLSerializer</code> and
     * initializes the following fields: fNSBinder, fLocalNSBinder, fSymbolTable,
     * fEmptySymbol, fXmlSymbol, fXmlnsSymbol, fNamespaceCounter, fFeatures.
     */
    public X()
    {
        // set default features
        X |= X;
        X |= X;
        X |= X;
        X |= X;
        X |= X;
        X |= X;
        X |= X;
        X |= X;
        X |= X;
        X |= X;

        X = new X();
        X(X);
    }



    //
    // LSSerializer methods
    //

    public X X()
    {
        return X;
    }

    /** DOM L3-EXPERIMENTAL:
     * Setter for boolean and object parameters
     */
    public X X(X X, X X) throws X
    {
        if (X instanceof X)
        {
            X X = ((X) X).X();
            if (X.X(X.X))
            {
                if (X)
                {
                    X &= ~X;
                    X &= ~X;
                    X |= X;
                    X |= X;
                    X |= X;
                    X |= X;
                }
                // false does not have any effect
            }
            else if (X.X(X.X))
            {
                X =
                    (X) (X ? X | X : X & ~X);
            }
            else if (X.X(X.X))
            {
                X =
                    (X) (X
                             ? X | X
                             : X & ~X);
                X.X = X;
            }
            else if (X.X(X.X))
            {
                X =
                    (X) (X
                             ? X | X
                             : X & ~X);
            }
            else if (X.X(X.X))
            {
                X =
                    (X) (X
                             ? X | X
                             : X & ~X);
            }
            else if (X.X(X.X))
            {
                X =
                    (X) (X
                             ? X | X
                             : X & ~X);
            }
            else if (X.X(X.X))
            {
                X =
                    (X) (X
                             ? X | X
                             : X & ~X);
            }
            else if (X.X(X.X))
            {
                X =
                    (X) (X
                             ? X | X
                             : X & ~X);
            }
            else if (X.X(X.X))
            {
                X =
                    (X) (X
                             ? X | X
                             : X & ~X);
            }
            else if (X.X(X.X))
            {
                X =
                    (X) (X
                             ? X | X
                             : X & ~X);
            }
            else if (X.X(X.X)
                     || X.X(X.X)
                     || X.X(X.X)
                     || X.X(X.X)
                     || X.X(X.X))
            {
                //  || name.equalsIgnoreCase(Constants.DOM_NORMALIZE_CHARACTERS)) {
                // true is not supported
                if (X)
                {
                    X X =
                        X.X(
                            X.X,
                            0,
                            new X[] { X });
                    throw new X(X.X, X);
                }
            }
            else if (
                X.X(X.X))
            {
                //namespace-declaration has effect only if namespaces is true
                X =
                    (X) (X
                             ? X | X
                             : X & ~X);
                X.X = X;
            }
            else if (X.X(X.X)
                     || X.X(X.X))
            {
                // false is not supported
                if (!X)
                {
                    X X =
                        X.X(
                            X.X,
                            0,
                            new X[] { X });
                    throw new X(X.X, X);
                }
            }
            else
            {
                X X =
                    X.X(
                        X.X,
                        0,
                        new X[] { X });
                throw new X(X.X, X);
            }
        }
        else if (X.X(X.X))
        {
            if (X == 0 || X instanceof X)
            {
                X = (X)X;
            }
            else
            {
                X X =
                    X.X(
                        X.X,
                        0,
                        new X[] { X });
                throw new X(X.X, X);
            }
        }
        else if (
            X.X(X.X)
            || X.X(X.X)
            || X.X(X.X)
            || X.X(X.X)
            && X != 0)
        {
            X X =
                X.X(
                    X.X,
                    0,
                    new X[] { X });
            throw new X(X.X, X);
        }
        else
        {
            X X =
                X.X(
                    X.X,
                    0,
                    new X[] { X });
            throw new X(X.X, X);
        }
    }

    /** DOM L3-EXPERIMENTAL:
     * Check if parameter can be set
     */
    public X X(X X, X X)
    {

        if (X == 0)
        {
            return 0;
        }

        if (X instanceof X)
        {
            X X = ((X) X).X();

            if (X.X(X.X)
                    || X.X(X.X)
                    || X.X(X.X)
                    || X.X(X.X)
                    || X.X(X.X)
                    || X.X(X.X)
                    || X.X(X.X)
                    || X.X(X.X)
                    || X.X(X.X)
                    || X.X(X.X)
                    || X.X(X.X))
            {
                // both values supported
                return 0;
            }
            else if (X.X(X.X)
                     || X.X(X.X)
                     || X.X(X.X)
                     || X.X(X.X)
                     || X.X(X.X))
            {
                // || name.equalsIgnoreCase(Constants.DOM_NORMALIZE_CHARACTERS)) {
                // true is not supported
                return !X;
            }
            else if (X.X(X.X)
                     || X.X(X.X))
            {
                // false is not supported
                return X;
            }
        }
        else if (X.X(X.X) &&
                 X == 0 || X instanceof X)
        {
            return 0;
        }

        return 0;
    }

    /**
     *  DOM Level 3 Core CR - Experimental.
     *
     *  The list of the parameters supported by this
     * <code>DOMConfiguration</code> object and for which at least one value
     * can be set by the application. Note that this list can also contain
     * parameter names defined outside this specification.
     */
    public X X()
    {

        if (X == 0)
        {
            X X = new X();

            //Add DOM recognized parameters
            //REVISIT: Would have been nice to have a list of
            //recognized parameters.
            X.X(X.X);
            X.X(X.X);
            X.X(X.X);
            X.X(X.X);
            X.X(X.X);
            X.X(X.X);
            X.X(X.X);
            X.X(X.X);
            X.X(X.X);
            X.X(X.X);
            //parameters.add(Constants.DOM_NORMALIZE_CHARACTERS);
            X.X(X.X);
            X.X(X.X);
            X.X(X.X);
            X.X(X.X);
            X.X(X.X);
            X.X(X.X);
            X.X(X.X);
            X.X(X.X);
            X.X(X.X);
            //parameters.add(Constants.DOM_SCHEMA_LOCATION);
            //parameters.add(Constants.DOM_SCHEMA_TYPE);

            //Add recognized xerces features and properties

            X = new X(X);

        }

        return X;
    }

    /** DOM L3-EXPERIMENTAL:
     * Getter for boolean and object parameters
     */
    public X X(X X) throws X
    {

        if(X.X(X.X))
        {
            return 0;
        }
        else if (X.X(X.X))
        {
            return ((X & X) != 0) ? X.X : X.X;
        }
        else if (X.X(X.X))
        {
            return (X & X) != 0 ? X.X : X.X;
        }
        else if (X.X(X.X))
        {
            return (X & X) != 0 ? X.X : X.X;
        }
        else if (X.X(X.X))
        {
            return (X & X) != 0 ? X.X : X.X;
        }
        else if (X.X(X.X))
        {
            return (X & X) != 0 ? X.X : X.X;
        }
        else if (X.X(X.X))
        {
            return (X & X) != 0 ? X.X : X.X;
        }
        else if (X.X(X.X))
        {
            return (X & X) != 0 ? X.X : X.X;
        }
        else if (X.X(X.X))
        {
            return (X & X) != 0 ? X.X : X.X;
        }
        else if (X.X(X.X))
        {
            return (X & X) != 0 ? X.X : X.X;
        }
        else if (X.X(X.X) ||
                 X.X(X.X))
        {
            return X.X;
        }
        else if (X.X(X.X))
        {
            return ((X & X)!=0)?X.X:X.X;
        }
        else if (X.X(X.X))
        {
            if ((X & X) == 0 &&
                    (X & X) == 0 &&
                    (X & X) != 0 &&
                    (X & X) != 0 &&
                    (X & X) != 0 &&
                    (X & X) != 0)
            {
                return X.X;
            }
            return X.X;
        }
        else if (X.X(X.X)
                 || X.X(X.X)
                 || X.X(X.X)
                 || X.X(X.X)
                 || X.X(X.X)
                 || X.X(X.X))
        {
            return X.X;
        }
        else if (X.X(X.X))
        {
            return X;
        }
        else if (
            X.X(X.X)
            || X.X(X.X)
            || X.X(X.X))
        {
            X X =
                X.X(
                    X.X,
                    0,
                    new X[] { X });
            throw new X(X.X, X);
        }
        else
        {
            X X =
                X.X(
                    X.X,
                    0,
                    new X[] { X });
            throw new X(X.X, X);
        }
    }


    /**
     * DOM L3 EXPERIMENTAL:
     *  Serialize the specified node as described above in the description of
     * <code>LSSerializer</code>. The result of serializing the node is
     * returned as a string. Writing a Document or Entity node produces a
     * serialized form that is well formed XML. Writing other node types
     * produces a fragment of text in a form that is not fully defined by
     * this document, but that should be useful to a human for debugging or
     * diagnostic purposes.
     * @param wnode  The node to be written.
     * @return  Returns the serialized data
     * @exception DOMException
     *    DOMSTRING_SIZE_ERR: The resulting string is too long to fit in a
     *   <code>DOMString</code>.
     * @exception LSException
     *    SERIALIZE_ERR: Unable to serialize the node.  DOM applications should
     *    attach a <code>DOMErrorHandler</code> using the parameter
     *    &quot;<i>error-handler</i>&quot; to get details on error.
     */
    public X X(X X) throws X, X
    {
        // determine which serializer to use:
        X X = (X.X() == X.X)?(X)X:X.X();
        X X = 0;
        X X = 0;
        X X = 0;
        // this should run under JDK 1.1.8...
        try
        {
            X = X.X().X(0, new X[] {});
            if(X != 0 )
            {
                X = (X)X.X(X, (X[]) 0);
            }
        }
        catch (X X)
        {
            // no way to test the version...
            // ignore the exception
        }
        if(X != 0 && X.X(0))
        {
            if(X == 0)
            {
                X = new X();
                X(X);
            }
            // copy setting from "main" serializer to XML 1.1 serializer
            X(X, X);
            X = X;
        }
        else
        {
            X = X;
        }

        X X = new X();
        try
        {
            X(X, X);
            X.X.X(0);
            X.X(X);
            if (X.X() == X.X)
            {
                X.X((X)X);
            }
            else if (X.X() == X.X)
            {
                X.X((X)X);
            }
            else if (X.X() == X.X)
            {
                X.X((X)X);
            }
            else if (X.X() == X.X ||
                     X.X() == X.X ||
                     X.X() == X.X ||
                     X.X() == X.X ||
                     X.X() == X.X )
            {
                X.X(X);
            }
            else
            {
                X X = X.X(
                                 X.X,
                                 0, 0);
                if (X.X != 0)
                {
                    X X = new X();
                    X.X = 0;
                    X.X = X;
                    X.X = X.X;
                    X.X.X(X);
                }
                throw new X(X.X, X);
            }
        }
        catch (X X)
        {
            // Rethrow LSException.
            throw X;
        }
        catch (X X)
        {
            if (X == X.X)
            {
                // stopped at user request
                return 0;
            }
            throw (X) new X(X.X, X.X()).X(X);
        }
        catch (X X)
        {
            // REVISIT: A generic IOException doesn't provide enough information
            // to determine that the serialized document is too large to fit
            // into a string. This could have thrown for some other reason. -- mrglavas
            X X = X.X(
                             X.X,
                             0,
                             new X[] { X.X()});
            throw (X) new X(X.X, X).X(X);
        }

        return X.X();
    }

    /**
     * DOM L3 EXPERIMENTAL:
     * The end-of-line sequence of characters to be used in the XML being
     * written out. The only permitted values are these:
     * <dl>
     * <dt><code>null</code></dt>
     * <dd>
     * Use a default end-of-line sequence. DOM implementations should choose
     * the default to match the usual convention for text files in the
     * environment being used. Implementations must choose a default
     * sequence that matches one of those allowed by  2.11 "End-of-Line
     * Handling". </dd>
     * <dt>CR</dt>
     * <dd>The carriage-return character (#xD).</dd>
     * <dt>CR-LF</dt>
     * <dd> The
     * carriage-return and line-feed characters (#xD #xA). </dd>
     * <dt>LF</dt>
     * <dd> The line-feed
     * character (#xA). </dd>
     * </dl>
     * <br>The default value for this attribute is <code>null</code>.
     */
    public X X(X X)
    {
        X.X.X(X);
    }


    /**
     * DOM L3 EXPERIMENTAL:
     * The end-of-line sequence of characters to be used in the XML being
     * written out. The only permitted values are these:
     * <dl>
     * <dt><code>null</code></dt>
     * <dd>
     * Use a default end-of-line sequence. DOM implementations should choose
     * the default to match the usual convention for text files in the
     * environment being used. Implementations must choose a default
     * sequence that matches one of those allowed by  2.11 "End-of-Line
     * Handling". </dd>
     * <dt>CR</dt>
     * <dd>The carriage-return character (#xD).</dd>
     * <dt>CR-LF</dt>
     * <dd> The
     * carriage-return and line-feed characters (#xD #xA). </dd>
     * <dt>LF</dt>
     * <dd> The line-feed
     * character (#xA). </dd>
     * </dl>
     * <br>The default value for this attribute is <code>null</code>.
     */
    public X X()
    {
        return X.X.X();
    }


    /**
     *  When the application provides a filter, the serializer will call out
     * to the filter before serializing each Node. Attribute nodes are never
     * passed to the filter. The filter implementation can choose to remove
     * the node from the stream or to terminate the serialization early.
     */
    public X X()
    {
        return X.X;
    }
    /**
     *  When the application provides a filter, the serializer will call out
     * to the filter before serializing each Node. Attribute nodes are never
     * passed to the filter. The filter implementation can choose to remove
     * the node from the stream or to terminate the serialization early.
     */
    public X X(X X)
    {
        X.X = X;
    }

    // this initializes a newly-created serializer
    private X X(X X)
    {
        X.X = new X();
        X.X = new X();
        X.X = new X();
    }

    // copies all settings that could have been modified
    // by calls to LSSerializer methods from one serializer to another.
    // IMPORTANT:  if new methods are implemented or more settings of
    // the serializer are made alterable, this must be
    // reflected in this method!
    private X X(X X, X X)
    {
        X.X = X;
        X.X.X(X.X.X());
        X.X.X(X.X.X());
        X.X = X.X;
    }//copysettings

    /**
      *  Serialize the specified node as described above in the general
      * description of the <code>LSSerializer</code> interface. The output
      * is written to the supplied <code>LSOutput</code>.
      * <br> When writing to a <code>LSOutput</code>, the encoding is found by
      * looking at the encoding information that is reachable through the
      * <code>LSOutput</code> and the item to be written (or its owner
      * document) in this order:
      * <ol>
      * <li> <code>LSOutput.encoding</code>,
      * </li>
      * <li>
      * <code>Document.actualEncoding</code>,
      * </li>
      * <li>
      * <code>Document.xmlEncoding</code>.
      * </li>
      * </ol>
      * <br> If no encoding is reachable through the above properties, a
      * default encoding of "UTF-8" will be used.
      * <br> If the specified encoding is not supported an
      * "unsupported-encoding" error is raised.
      * <br> If no output is specified in the <code>LSOutput</code>, a
      * "no-output-specified" error is raised.
      * @param node  The node to serialize.
      * @param destination The destination for the serialized DOM.
      * @return  Returns <code>true</code> if <code>node</code> was
      *   successfully serialized and <code>false</code> in case the node
      *   couldn't be serialized.
      */
    public X X(X X, X X) throws X
    {

        if (X == 0)
            return 0;

        X X = 0;
        X X = 0;
        X X = 0;
        X X =(X.X() == X.X)
                            ? (X) X
                            : X.X();
        // this should run under JDK 1.1.8...
        try
        {
            X = X.X().X(0, new X[] {});
            if (X != 0)
            {
                X = (X) X.X(X, (X[]) 0);
            }
        }
        catch (X X)
        {
            //no way to test the version...
            //ignore the exception
        }
        //determine which serializer to use:
        if (X != 0 && X.X(0))
        {
            if (X == 0)
            {
                X = new X();
                X(X);
            }
            //copy setting from "main" serializer to XML 1.1 serializer
            X(X, X);
            X = X;
        }
        else
        {
            X = X;
        }

        X X = 0;
        if ((X = X.X()) == 0)
        {
            try
            {
                X X =
                    X.X().X(0, new X[] {});
                if (X != 0)
                {
                    X = (X) X.X(X, (X[]) 0);
                }
            }
            catch (X X)
            {
                // ignore the exception
            }
            if (X == 0)
            {
                try
                {
                    X X =
                        X.X().X(0, new X[] {});
                    if (X != 0)
                    {
                        X = (X) X.X(X, (X[]) 0);
                    }
                }
                catch (X X)
                {
                    // ignore the exception
                }
                if (X == 0)
                {
                    X = 0;
                }
            }
        }
        try
        {
            X(X, X);
            X.X.X(X);
            X X = X.X();
            X X = X.X();
            X X =  X.X();
            if (X == 0)
            {
                if (X == 0)
                {
                    if (X == 0)
                    {
                        X X = X.X(
                                         X.X,
                                         0, 0);
                        if (X.X != 0)
                        {
                            X X = new X();
                            X.X = 0;
                            X.X = X;
                            X.X = X.X;
                            X.X.X(X);
                        }
                        throw new X(X.X, X);
                    }
                    else
                    {
                        // URI was specified. Handle relative URIs.
                        X X = X.X(X, 0, 0);
                        X X = new X(X != 0 ? X : X);
                        X X = 0;
                        X X = X.X();
                        X X = X.X();
                        // Use FileOutputStream if this URI is for a local file.
                        if (X.X(0)
                                && (X == 0 || X.X() == 0 || X.X(0)))
                        {
                            X = new X(X(X.X()));
                        }
                        // Try to write to some other kind of URI. Some protocols
                        // won't support this, though HTTP should work.
                        else
                        {
                            X X = X.X();
                            X.X(0);
                            X.X(0);
                            X.X(0); // Enable tunneling.
                            if (X instanceof X)
                            {
                                // The DOM L3 LS CR says if we are writing to an HTTP URI
                                // it is to be done with an HTTP PUT.
                                X X = (X) X;
                                X.X(0);
                            }
                            X = X.X();
                        }
                        X.X(X);
                    }
                }
                else
                {
                    // byte stream was specified
                    X.X(X);
                }
            }
            else
            {
                // character stream is specified
                X.X(X);
            }

            if (X.X() == X.X)
                X.X((X) X);
            else if (X.X() == X.X)
                X.X((X) X);
            else if (X.X() == X.X)
                X.X((X) X);
            else if (X.X() == X.X ||
                     X.X() == X.X ||
                     X.X() == X.X ||
                     X.X() == X.X ||
                     X.X() == X.X )
            {
                X.X(X);
            }
            else
                return 0;
        }
        catch( X X)
        {
            if (X.X != 0)
            {
                X X = new X();
                X.X = X;
                X.X = 0;
                X.X = X.X();
                X.X = X.X;
                X.X.X(X);
            }
            throw new X(X.X,
                                  X.X(
                                      X.X,
                                      0, 0));
            //return false;
        }
        catch (X X)
        {
            // Rethrow LSException.
            throw X;
        }
        catch (X X)
        {
            if (X == X.X)
            {
                // stopped at user request
                return 0;
            }
            throw new X(X.X, X.X());
        }
        catch (X X)
        {
            if (X.X != 0)
            {
                X X = new X();
                X.X = X;
                X.X = X.X();
                X.X = X.X;
                X.X.X(X);

            }
            X.X();
            throw new X(X.X, X.X());
        }
        return 0;

    } //write

    /**
      *  Serialize the specified node as described above in the general
      * description of the <code>LSSerializer</code> interface. The output
      * is written to the supplied URI.
      * <br> When writing to a URI, the encoding is found by looking at the
      * encoding information that is reachable through the item to be written
      * (or its owner document) in this order:
      * <ol>
      * <li>
      * <code>Document.inputEncoding</code>,
      * </li>
      * <li>
      * <code>Document.xmlEncoding</code>.
      * </li>
      * </ol>
      * <br> If no encoding is reachable through the above properties, a
      * default encoding of "UTF-8" will be used.
      * <br> If the specified encoding is not supported an
      * "unsupported-encoding" error is raised.
      * @param node  The node to serialize.
      * @param URI The URI to write to.
      * @return  Returns <code>true</code> if <code>node</code> was
      *   successfully serialized and <code>false</code> in case the node
      *   couldn't be serialized.
      */
    public X X(X X, X X) throws X
    {
        if (X == 0)
        {
            return 0;
        }

        X X = 0;
        X X = 0;
        X X = 0;
        X X = 0;

        X X =(X.X() == X.X)
                            ? (X) X
                            : X.X();
        // this should run under JDK 1.1.8...
        try
        {
            X =
                X.X().X(0, new X[] {});
            if (X != 0)
            {
                X = (X) X.X(X, (X[]) 0);
            }
        }
        catch (X X)
        {
            // no way to test the version...
            // ignore the exception
        }
        if (X != 0 && X.X(0))
        {
            if (X == 0)
            {
                X = new X();
                X(X);
            }
            // copy setting from "main" serializer to XML 1.1 serializer
            X(X, X);
            X = X;
        }
        else
        {
            X = X;
        }

        try
        {
            X X =
                X.X().X(0, new X[] {});
            if (X != 0)
            {
                X = (X) X.X(X, (X[]) 0);
            }
        }
        catch (X X)
        {
            // ignore the exception
        }
        if (X == 0)
        {
            try
            {
                X X =
                    X.X().X(0, new X[] {});
                if (X != 0)
                {
                    X = (X) X.X(X, (X[]) 0);
                }
            }
            catch (X X)
            {
                // ignore the exception
            }
            if (X == 0)
            {
                X = 0;
            }
        }

        try
        {
            X(X, X);
            X.X.X(X);

            // URI was specified. Handle relative URIs.
            X X = X.X(X, 0, 0);
            X X = new X(X != 0 ? X : X);
            X X = 0;
            X X = X.X();
            X X = X.X();
            // Use FileOutputStream if this URI is for a local file.
            if (X.X(0)
                    && (X == 0 || X.X() == 0 || X.X(0)))
            {
                X = new X(X(X.X()));
            }
            // Try to write to some other kind of URI. Some protocols
            // won't support this, though HTTP should work.
            else
            {
                X X = X.X();
                X.X(0);
                X.X(0);
                X.X(0); // Enable tunneling.
                if (X instanceof X)
                {
                    // The DOM L3 LS CR says if we are writing to an HTTP URI
                    // it is to be done with an HTTP PUT.
                    X X = (X) X;
                    X.X(0);
                }
                X = X.X();
            }
            X.X(X);

            if (X.X() == X.X)
                X.X((X) X);
            else if (X.X() == X.X)
                X.X((X) X);
            else if (X.X() == X.X)
                X.X((X) X);
            else if (X.X() == X.X ||
                     X.X() == X.X ||
                     X.X() == X.X ||
                     X.X() == X.X ||
                     X.X() == X.X )
            {
                X.X(X);
            }
            else
                return 0;
        }
        catch (X X)
        {
            // Rethrow LSException.
            throw X;
        }
        catch (X X)
        {
            if (X == X.X)
            {
                // stopped at user request
                return 0;
            }
            throw new X(X.X, X.X());
        }
        catch (X X)
        {
            if (X.X != 0)
            {
                X X = new X();
                X.X = X;
                X.X = X.X();
                X.X = X.X;
                X.X.X(X);
            }
            throw new X(X.X, X.X());
        }
        return 0;
    } //writeURI


    //
    //  Private methods
    //

    private X X(X X, X X)
    {
        X.X();
        X.X = X;
        X.X = X;
        X.X = (X & X) != 0;
        X.X = (X & X) != 0;
        X.X.X((X & X)==0);
        X.X.X((X & X) == 0);
        X.X.X((X & X) != 0);

        if ((X & X) != 0)
        {
            // REVISIT: this is inefficient implementation of well-formness. Instead, we should check
            // well-formness as we serialize the tree
            X X, X;
            X = X;
            X X;
            X X = 0;
            X X =(X.X() == X.X)
                               ? (X) X
                               : X.X();
            try
            {
                X = X.X().X(0, new X[] {});
                if (X != 0)
                {
                    X = ((X)X.X(X, (X[]) 0)).X();
                }
            }
            catch (X X)
            {
                //no way to test the version...
                //ignore the exception
            }
            if (X.X() != 0)
            {
                while (X != 0)
                {
                    X(X, X, 0);
                    // Move down to first child
                    X = X.X();
                    // No child nodes, so walk tree
                    while (X == 0)
                    {
                        // Move to sibling if possible.
                        X = X.X();
                        if (X == 0)
                        {
                            X = X.X();
                            if (X == X)
                            {
                                X = 0;
                                break;
                            }
                            X = X.X();
                        }
                    }
                    X = X;
                }
            }
            else
            {
                X(X, X, 0);
            }
        }
    }


    private X X (X X, X X, X X)
    {

        X X = X.X();
        X.X = X;
        X X;
        switch (X)
        {
        case X.X:
        {
            break;
        }
        case X.X:
        {
            break;
        }
        case X.X:
        {
            if (X)
            {
                if((X & X) != 0)
                {
                    X = X.X(X.X() , X.X(), X) ;
                }
                else
                {
                    X = X.X(X.X() , X);
                }
                if (!X)
                {
                    if (!X)
                    {
                        if (X != 0)
                        {
                            X X = X.X(
                                             X.X,
                                             0,
                                             new X[] {0, X.X()});
                            X.X(X, X, X, X, X.X,
                                                         0);
                        }

                    }
                }
            }

            X X = (X.X()) ? X.X() : 0;
            if (X != 0)
            {
                for (X X = 0; X < X.X(); ++X)
                {
                    X X = (X) X.X(X);
                    X.X = X;
                    X.X( X, X, X,
                                                 X, X, X.X(), X);
                    if (X)
                    {
                        X = X.X( X.X(), X);
                        if (!X)
                        {
                            X X =
                                X.X(
                                    X.X,
                                    0,
                                    new X[] { 0, X.X()});
                            X.X( X, X, X, X, X.X,
                                                          0);
                        }
                    }
                }

            }

            break;
        }

        case X.X:
        {
            // only verify well-formness if comments included in the tree
            if ((X & X) != 0)
                X.X(X, X, X, ((X)X).X(), X);
            break;
        }
        case X.X:
        {
            // only if entity is preserved in the tree
            if (X && (X & X) != 0)
            {
                X.X(X.X() , X);
            }
            break;

        }
        case X.X:
        {
            // verify content
            X.X(X, X, X, X.X(), X);
            // the ]]> string will be checked during serialization
            break;
        }
        case X.X:
        {
            X.X(X, X, X, X.X(), X);
            break;
        }
        case X.X:
        {
            X X = (X)X ;
            X X = X.X();
            if (X)
            {
                if (X)
                {
                    X = X.X(X);
                }
                else
                {
                    X = X.X(X);
                }

                if (!X)
                {
                    X X =
                        X.X(
                            X.X,
                            0,
                            new X[] { 0, X.X()});
                    X.X(
                        X,
                        X,
                        X,
                        X,
                        X.X,
                        0);
                }
            }
            X.X(X, X, X, X.X(), X);
            break;
        }
        }

    }

    private X X(X X)
    {
        if (X != 0 && X.X() != 0 && X.X(0) != -0)
        {
            // Locate the escape characters
            X X = new X(X, 0);
            X X = new X(X.X());
            X X = X.X();
            X.X(X.X());
            for(X X = 0; X < X; ++X)
            {
                X X = X.X();
                // Decode the 2 digit hexadecimal number following % in '%nn'
                X.X((X)X.X(X.X(0, 0), 0).X());
                X.X(X.X(0));
            }
            return X.X();
        }
        return X;
    }

}//DOMSerializerImpl




