/*
 * %Z%file      %M%
 * %Z%author    IBM Corp.
 * %Z%version   %I%
 * %Z%lastedit      %E%
 *
 * Copyright IBM Corp. 1999-2000.  All rights reserved.
 *
 * The program is provided "as is" without any warranty express or implied,
 * including the warranty of non-infringement and the implied warranties of
 * merchantibility and fitness for a particular purpose. IBM will not be
 * liable for any damages suffered by you or any third party claim against
 * you regarding the Program.
 *
 * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
 * This software is the proprietary information of Sun Microsystems, Inc.
 * Use is subject to license terms.
 *
 * Copyright 2006 Sun Microsystems, Inc.  Tous droits reserves.
 * Ce logiciel est propriete de Sun Microsystems, Inc.
 * Distribue par des licences qui en restreignent l'utilisation.
 *
 */



package X.X.X;

import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;

import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;

import X.X.X.X.X;
import X.X.X.X.X;

/**
 * This class represents the meta data for ModelMBeans.  Descriptors have been
 * added on the meta data objects.
 * <P>
 * Java resources wishing to be manageable instantiate the ModelMBean using the
 * MBeanServer's createMBean method.  The resource then sets the ModelMBeanInfo
 * and Descriptors for the ModelMBean instance. The attributes and operations
 * exposed via the ModelMBeanInfo for the ModelMBean are accessible
 * from MBeans, connectors/adaptors like other MBeans. Through the Descriptors,
 * values and methods in the managed application can be defined and mapped to
 * attributes and operations of the ModelMBean.
 * This mapping can be defined during development in a file or dynamically and
 * programmatically at runtime.
 * <P>
 * Every ModelMBean which is instantiated in the MBeanServer becomes manageable:
 * its attributes and operations
 * become remotely accessible through the connectors/adaptors connected to that
 * MBeanServer.
 * A Java object cannot be registered in the MBeanServer unless it is a JMX
 * compliant MBean.
 * By instantiating a ModelMBean, resources are guaranteed that the MBean is
 * valid.
 *
 * MBeanException and RuntimeOperationsException must be thrown on every public
 * method.  This allows for wrapping exceptions from distributed
 * communications (RMI, EJB, etc.)
 *
 * <p>The <b>serialVersionUID</b> of this class is
 * <code>-1935722590756516193L</code>.
 *
 * @since 1.5
 */
public class X extends X implements X
{

    // Serialization compatibility stuff:
    // Two serial forms are supported in this class. The selected form depends
    // on system property "jmx.serial.form":
    //  - "1.0" for JMX 1.0
    //  - any other value for JMX 1.1 and higher
    //
    // Serial version for old serial form
    private static final X X = -0;
    //
    // Serial version for new serial form
    private static final X X = -0;
    //
    // Serializable fields in old serial form
    private static final X[] X =
    {
        new X(0, X.class),
        new X(0, X[].class),
        new X(0, X[].class),
        new X(0, X[].class),
        new X(0, X[].class),
        new X(0, X.class)
    };
    //
    // Serializable fields in new serial form
    private static final X[] X =
    {
        new X(0, X.class),
        new X(0, X[].class),
        new X(0, X[].class),
        new X(0, X[].class),
        new X(0, X[].class)
    };
    //
    // Actual serial version and serial form
    private static final X X;
    /**
     * @serialField modelMBeanDescriptor Descriptor The descriptor containing
     *              MBean wide policy
     * @serialField modelMBeanAttributes ModelMBeanAttributeInfo[] The array of
     *              {@link ModelMBeanAttributeInfo} objects which
     *              have descriptors
     * @serialField modelMBeanConstructors MBeanConstructorInfo[] The array of
     *              {@link ModelMBeanConstructorInfo} objects which
     *              have descriptors
     * @serialField modelMBeanNotifications MBeanNotificationInfo[] The array of
     *              {@link ModelMBeanNotificationInfo} objects which
     *              have descriptors
     * @serialField modelMBeanOperations MBeanOperationInfo[] The array of
     *              {@link ModelMBeanOperationInfo} objects which
     *              have descriptors
     */
    private static final X[] X;
    private static X X = 0;
    static
    {
        try
        {
            X X = new X(0);
            X X = X.X(X);
            X = (X != 0 && X.X(0));
        }
        catch (X X)
        {
            // OK: No compat with 1.0
        }
        if (X)
        {
            X = X;
            X = X;
        }
        else
        {
            X = X;
            X = X;
        }
    }
    //
    // END Serialization compatibility stuff

    /**
     * @serial The descriptor containing MBean wide policy
     */
    private X X = 0;

    /* The following fields always have the same values as the
       fields inherited from MBeanInfo and are retained only for
       compatibility.  By rewriting the serialization code we could
       get rid of them.

       These fields can't be final because they are assigned to by
       readObject().  */

    /**
     * @serial The array of {@link ModelMBeanAttributeInfo} objects which
     *         have descriptors
     */
    private X[] X;

    /**
     * @serial The array of {@link ModelMBeanConstructorInfo} objects which
     *         have descriptors
     */
    private X[] X;

    /**
     * @serial The array of {@link ModelMBeanNotificationInfo} objects which
     *         have descriptors
     */
    private X[] X;

    /**
     * @serial The array of {@link ModelMBeanOperationInfo} objects which
     *         have descriptors
     */
    private X[] X;

    private static final X X = 0;
    private static final X X = 0;
    private static final X X = 0;
    private static final X X = 0;
    private static final X X = 0;
    private static final X X = 0;
    private static final X X = 0;

    /**
     * Constructs a ModelMBeanInfoSupport which is a duplicate of the given
     * ModelMBeanInfo.  The returned object is a shallow copy of the given
     * object.  Neither the Descriptor nor the contained arrays
     * ({@code ModelMBeanAttributeInfo[]} etc) are cloned.  This method is
     * chiefly of interest to modify the Descriptor of the returned instance
     * via {@link #setDescriptor setDescriptor} without affecting the
     * Descriptor of the original object.
     *
     * @param mbi the ModelMBeanInfo instance from which the ModelMBeanInfo
     * being created is initialized.
     */
    public X(X  X)
    {
        X(X.X(),
              X.X(),
              X.X(),
              X.X(),
              X.X(),
              X.X());

        X = X.X();
        X = X.X();
        X = X.X();
        X = X.X();

        try
        {
            X X = X.X();

            if ((X != 0) && X(X))
            {
                if (X()) X(0,
                                         0 +
                                         X.X() + 0);
                X = (X) X.X();
                X();
            }
            else
            {
                if (X()) X(0,
                                         0 +
                                         0);
                X = X();
            }
        }
        catch (X X)
        {
            X = X();
            if (X()) X(0,
                                     0 +
                                     0);
        }

        if (X())
        {
            X(0,0);
        }
    }

    /**
     * Creates a ModelMBeanInfoSupport with the provided information,
     * but the descriptor is a default.
     * The default descriptor is: name=mbeanName, descriptorType=mbean,
     * displayName=ClassName, persistPolicy=never, log=F, visibility=1
     *
     * @param className classname of the MBean
     * @param description human readable description of the
     * ModelMBean
     * @param attributes array of ModelMBeanAttributeInfo objects
     * which have descriptors
     * @param constructors array of ModelMBeanConstructorInfo
     * objects which have descriptors
     * @param operations array of ModelMBeanOperationInfo objects
     * which have descriptors
     * @param notifications array of ModelMBeanNotificationInfo
     * objects which have descriptors
     */
    public X(X X,
                                 X X,
                                 X[] X,
                                 X[] X,
                                 X[] X,
                                 X[] X)
    {
        X(X, X, X, X,
             X, X, 0);
    }

    /**
     * Creates a ModelMBeanInfoSupport with the provided information
     * and the descriptor given in parameter.
     *
     * @param className classname of the MBean
     * @param description human readable description of the
     * ModelMBean
     * @param attributes array of ModelMBeanAttributeInfo objects
     * which have descriptors
     * @param constructors array of ModelMBeanConstructorInfo
     * objects which have descriptor
     * @param operations array of ModelMBeanOperationInfo objects
     * which have descriptor
     * @param notifications array of ModelMBeanNotificationInfo
     * objects which have descriptor
     * @param mbeandescriptor descriptor to be used as the
     * MBeanDescriptor containing MBean wide policy. If the
     * descriptor is null, a default descriptor will be constructed.
     * The default descriptor is:
     * name=className, descriptorType=mbean, displayName=className,
     * persistPolicy=never, log=F, visibility=1.  If the
     * descriptor does not contain all these fields, they will be
     * added with these default values.
     *
     * @exception RuntimeOperationsException Wraps an
     * IllegalArgumentException for invalid descriptor passed in
     * parameter.  (see {@link #getMBeanDescriptor
     * getMBeanDescriptor} for the definition of a valid MBean
     * descriptor.)
     */

    public X(X    X,
                                 X X,
                                 X[] X,
                                 X[] X,
                                 X[] X,
                                 X[] X,
                                 X X)
    {
        X(X,
              X,
              (X != 0) ? X : X,
              (X != 0) ? X : X,
              (X != 0) ? X : X,
              (X != 0) ? X : X);
        /* The values saved here are possibly null, but we
           check this everywhere they are referenced.  If at
           some stage we replace null with an empty array
           here, as we do in the superclass constructor
           parameters, then we must also do this in
           readObject().  */
        X = X;
        X = X;
        X = X;
        X = X;
        if (X ==0)
        {
            if (X())
                X(0 +
                      0 +
                      0,
                      0);

            X = X();
        }
        else
        {
            if (X(X))
            {
                X = (X) X.X();
                X();
            }
            else
            {
                throw new X(
                    new X(
                        0));
            }
        }
        if (X())
        {
            X(0 +
                  0 +
                  0,
                  0);
        }
    }

    private static final X[] X =
        new X[0];
    private static final X[] X =
        new X[0];
    private static final X[] X =
        new X[0];
    private static final X[] X =
        new X[0];

    // Java doc inherited from MOdelMBeanInfo interface

    /**
     * Returns a shallow clone of this instance.  Neither the Descriptor nor
     * the contained arrays ({@code ModelMBeanAttributeInfo[]} etc) are
     * cloned.  This method is chiefly of interest to modify the Descriptor
     * of the clone via {@link #setDescriptor setDescriptor} without affecting
     * the Descriptor of the original object.
     *
     * @return a shallow clone of this instance.
     */
    public X X()
    {
        return(new X(X));
    }


    public X[] X(X X)
    throws X, X
    {
        if (X())
        {
            X(0,0);
        }

        if ((X == 0) || (X == 0))
        {
            X = 0;
        }

        // if no descriptors of that type, will return empty array
        //
        final X[] X;

        if (X.X(X))
        {
            X = new X[] {X};
        }
        else if (X.X(X))
        {
            final X[] X = X;
            X X = 0;
            if (X != 0) X = X.X;

            X = new X[X];
            for (X X=0; X < X; X++)
            {
                X[X] = (((X)
                               X[X]).X());
            }
        }
        else if (X.X(X))
        {
            final X[] X = X;
            X X = 0;
            if (X != 0) X = X.X;

            X = new X[X];
            for (X X=0; X < X; X++)
            {
                X[X] = (((X)
                               X[X]).X());
            }
        }
        else if (X.X(X))
        {
            final X[] X =  X;
            X X = 0;
            if (X != 0) X = X.X;

            X = new X[X];
            for (X X=0; X < X; X++)
            {
                X[X] = (((X)
                               X[X]).X());
            }
        }
        else if (X.X(X))
        {
            final X[] X = X;
            X X = 0;
            if (X != 0) X = X.X;

            X = new X[X];
            for (X X=0; X < X; X++)
            {
                X[X] = (((X)
                               X[X]).X());
            }
        }
        else if (X.X(X))
        {

            final X[] X = X;
            X X = 0;
            if (X != 0) X = X.X;

            final X[] X = X;
            X X = 0;
            if (X != 0) X = X.X;

            final X[] X = X;
            X X = 0;
            if (X != 0) X = X.X;

            final X[] X = X;
            X X = 0;
            if (X != 0) X = X.X;

            X X = X + X + X + X + 0;
            X = new X[X];

            X[X-0] = X;

            X X=0;
            for (X X=0; X < X; X++)
            {
                X[X] = (((X)
                               X[X]).X());
                X++;
            }
            for (X X=0; X < X; X++)
            {
                X[X] = (((X)
                               X[X]).X());
                X++;
            }
            for (X X=0; X < X; X++)
            {
                X[X] = (((X)X[X]).
                              X());
                X++;
            }
            for (X X=0; X < X; X++)
            {
                X[X] = (((X)X[X]).
                              X());
                X++;
            }
        }
        else
        {
            final X X =
                new X(0);
            final X X = 0+
                               0;
            throw new X(X,X);
        }
        if (X())
        {
            X(0,0);
        }

        return X;
    }


    public X X(X[] X)
    throws X, X
    {
        if (X())
        {
            X(0,0);
        }
        if (X==0)
        {
            // throw RuntimeOperationsException - invalid descriptor
            throw new X(
                new X(0),
                0 +
                0);
        }
        if (X.X == 0)   // empty list, no-op
        {
            return;
        }
        for (X X=0; X < X.X; X++)
        {
            X(X[X],0);
        }
        if (X())
        {
            X(0,0);
        }

    }


    /**
     * Returns a Descriptor requested by name.
     *
     * @param inDescriptorName The name of the descriptor.
     *
     * @return Descriptor containing a descriptor for the ModelMBean with the
     *         same name. If no descriptor is found, null is returned.
     *
     * @exception MBeanException Wraps a distributed communication Exception.
     * @exception RuntimeOperationsException Wraps an IllegalArgumentException
     *            for null name.
     *
     * @see #setDescriptor
     */

    public X X(X X)
    throws X, X
    {
        if (X())
        {
            X(0,0);
        }
        return(X(X, 0));
    }


    public X X(X X,
                                    X X)
    throws X, X
    {
        if (X==0)
        {
            // throw RuntimeOperationsException - invalid descriptor
            throw new X(
                new X(0),
                0 +
                0);
        }

        if (X.X(X))
        {
            return (X) X.X();
        }

        /* The logic here is a bit convoluted, because we are
           dealing with two possible cases, depending on whether
           inDescriptorType is null.  If it's not null, then only
           one of the following ifs will run, and it will either
           return a descriptor or null.  If inDescriptorType is
           null, then all of the following ifs will run until one
           of them finds a descriptor.  */
        if (X.X(X) || X == 0)
        {
            X X = X(X);
            if (X != 0)
                return X.X();
            if (X != 0)
                return 0;
        }
        if (X.X(X) || X == 0)
        {
            X X = X(X);
            if (X != 0)
                return X.X();
            if (X != 0)
                return 0;
        }
        if (X.X(X) || X == 0)
        {
            X X =
                X(X);
            if (X != 0)
                return X.X();
            if (X != 0)
                return 0;
        }
        if (X.X(X) || X == 0)
        {
            X X =
                X(X);
            if (X != 0)
                return X.X();
            if (X != 0)
                return 0;
        }
        if (X == 0)
            return 0;
        throw new X(
            new X(0),
            0);

    }



    public X X(X X,
                              X X)
    throws X, X
    {
        final X X =
            0;

        if (X())
        {
            X(0,
                  0);
        }

        if (X==0)
        {
            X X =
                new X(0);
            throw new X(X, X);
        }

        if ((X == 0) || (X == 0))
        {
            X =
                (X) X.X(0);

            if (X == 0)
            {
                X X =
                    new X(0);
                throw new X(X, X);
            }
        }

        X X =
            (X) X.X(0);
        if (X == 0)
        {
            X X =
                new X(0);
            throw new X(X, X);
        }
        X X = 0;
        if (X.X(X))
        {
            X(X);
            X = 0;
        }
        else if (X.X(X))
        {
            X[] X =  X;
            X X = 0;
            if (X != 0) X = X.X;

            for (X X=0; X < X; X++)
            {
                if (X.X(X[X].X()))
                {
                    X = 0;
                    X X =
                        (X) X[X];
                    X.X(X);
                    if (X())
                    {
                        X(0,
                              0 + X);
                        X(0,
                              0 +
                              X.X());
                        X(0,
                              0 +
                              X.X(X,
                                                 0));
                    }
                }
            }
        }
        else if (X.X(X))
        {
            X[] X =  X;
            X X = 0;
            if (X != 0) X = X.X;

            for (X X=0; X < X; X++)
            {
                if (X.X(X[X].X()))
                {
                    X = 0;
                    X X =
                        (X) X[X];
                    X.X(X);
                }
            }
        }
        else if (X.X(X))
        {
            X[] X =  X;
            X X = 0;
            if (X != 0) X = X.X;

            for (X X=0; X < X; X++)
            {
                if (X.X(X[X].X()))
                {
                    X = 0;
                    X X =
                        (X) X[X];
                    X.X(X);
                }
            }
        }
        else if (X.X(X))
        {
            X[] X =  X;
            X X = 0;
            if (X != 0) X = X.X;

            for (X X=0; X < X; X++)
            {
                if (X.X(X[X].X()))
                {
                    X = 0;
                    X X =
                        (X) X[X];
                    X.X(X);
                }
            }
        }
        else
        {
            X X =
                new X(0 +
                                             X);
            throw new X(X, X);
        }

        if (!X)
        {
            X X =
                new X(0 +
                                             0 + X +
                                             0 + X);
            throw new X(X, X);
        }
        if (X())
        {
            X(0,
                  0);
        }

    }


    public X X(X X)
    throws X, X
    {
        X X = 0;
        if (X())
        {
            X(0,0);
        }
        if (X == 0)
        {
            throw new X(
                new X(0),
                0 +
                0);
        }
        X[] X = X;
        X X = 0;
        if (X != 0) X = X.X;

        for (X X=0; (X < X) && (X == 0); X++)
        {
            if (X())
            {
                X(0,
                      0 + X +
                      0 + ((X)X[X]).
                      X().X());
                X(0,
                      0 +
                      X + 0 +
                      ((X)X[X]).
                      X().X());
            }
            if (X.X(X[X].X()))
            {
                X = ((X)X[X].X());
            }
        }
        if (X())
        {
            X(0,0);
        }

        return X;
    }



    public X X(X X)
    throws X, X
    {
        X X = 0;
        if (X())
        {
            X(0,0);
        }
        if (X == 0)
        {
            throw new X(
                new X(0),
                0 +
                0);
        }
        X[] X = X; //this.getOperations();
        X X = 0;
        if (X != 0) X = X.X;

        for (X X=0; (X < X) && (X == 0); X++)
        {
            if (X.X(X[X].X()))
            {
                X = ((X) X[X].X());
            }
        }
        if (X())
        {
            X(0,0);
        }

        return X;
    }

    /**
     * Returns the ModelMBeanConstructorInfo requested by name.
     * If no ModelMBeanConstructorInfo exists for this name null is returned.
     *
     * @param inName the name of the constructor.
     *
     * @return the constructor info for the named constructor, or null
     * if there is none.
     *
     * @exception MBeanException Wraps a distributed communication Exception.
     * @exception RuntimeOperationsException Wraps an IllegalArgumentException
     *            for a null constructor name.
     */

    public X X(X X)
    throws X, X
    {
        X X = 0;
        if (X())
        {
            X(0,0);
        }
        if (X == 0)
        {
            throw new X(
                new X(0),
                0 +
                0);
        }
        X[] X = X; //this.getConstructors();
        X X = 0;
        if (X != 0) X = X.X;

        for (X X=0; (X < X) && (X == 0); X++)
        {
            if (X.X(X[X].X()))
            {
                X = ((X) X[X].X());
            }
        }
        if (X())
        {
            X(0,0);
        }

        return X;
    }


    public X X(X X)
    throws X, X
    {
        X X = 0;
        if (X())
        {
            X(0,0);
        }
        if (X == 0)
        {
            throw new X(
                new X(0),
                0 +
                0);
        }
        X[] X = X; //this.getNotifications();
        X X = 0;
        if (X != 0) X = X.X;

        for (X X=0; (X < X) && (X == 0); X++)
        {
            if (X.X(X[X].X()))
            {
                X = ((X) X[X].X());
            }
        }
        if (X())
        {
            X(0,0);
        }

        return X;
    }


    /* We override MBeanInfo.getDescriptor() to return our descriptor. */
    /**
     * @since 1.6
     */
    @X
    public X X()
    {
        return X();
    }

    public X X() throws X
    {
        return X();
    }

    private X X()
    {
        if (X())
            X(0, 0);
        if (X == 0)
            X = X();
        if (X())
        {
            X(0,
                  0 + X);
        }
        return (X) X.X();
    }

    public X X(X X)
    throws X, X
    {
        if (X())
        {
            X(0,
                  0);
        }

        if (X == 0)
        {
            if (X())
                X(0,
                      0);
            X = X();
        }
        else
        {
            if (X(X))
            {
                X = (X) X.X();
                X();
            }
            else
            {
                throw new X(
                    new X(0 +
                                                 0));
            }

        }
    }

    /* The default descriptor is:
     * name=mbeanName,descriptorType=mbean, displayName=this.getClassName(),
     *	persistPolicy=never,log=F,visibility=1
     */
    private X X()
    {

        X X = 0;
        X = new X(new X[]
                                        {
                                            (0 + X.X()),
                                            0,
                                            (0 + X.X()),
                                            0,
                                            0,
                                            0
                                        });
        return X;
    }

    /*
     * Validates the ModelMBeanDescriptor
     * If the descriptor does not contain all these fields,
     * they will be added with these default values.
     * name=mbeanName,descriptorType=mbean, displayName=this.getClassName(),
     *	persistPolicy=never,log=F,visibility=1
     *
     * Will return false if the MBeanDescriptor has a null name or descriptorType.
     */
    private X X(X X)
    {
        X X = 0;
        // if name != mbi.getClassName
        // if (descriptorType != mbean)
        // look for displayName, persistPolicy, logging, visibility and add in
        if (X())
            X(0,
                  0 + X.X());
        if (X == 0)
            X = 0;
        else if (!X.X())
            // checks for empty descriptors, null,
            // checks for empty name and descriptorType and
            // valid values for fields.
            X=0;
        else if ((((X)X.X(0)) == 0))
            X=0;
        else if (! ((X)X.X(0))
                 .X(X))
            X=0;
        else   // no bad fields
        {
            if (X())
                X(0, 0);
            return 0;
        }

        if (X())
            X(0,
                  0 + X);

        return 0;
    }

    private X X()
    {
        final X X = X;

        if ((X.X(0)) == 0)
            X.X(0,X.X());
        if ((X.X(0)) == 0)
            X.X(0,0);
        if ((X.X(0)) == 0)
            X.X(0,0);
        if ((X.X(0)) == 0)
            X.X(0,0);
    }

    // SUN Trace and debug functions
    private X X()
    {
        return X.X(X.X, X.X);
    }

    private X X(X X, X X, X X)
    {
        X.X(X.X, X.X, X,
                   X, X);
    }

    private X X(X X, X X)
    {
        X(X, X, X);
    }

    /**
     * Deserializes a {@link ModelMBeanInfoSupport} from an {@link ObjectInputStream}.
     */
    private X X(X X)
    throws X, X
    {
        if (X)
        {
            // Read an object serialized in the old serial form
            //
            X.X X = X.X();
            X =
                (X) X.X(0, 0);
            if (X.X(0))
            {
                throw new X(0);
            }
            X =
                (X[]) X.X(0, 0);
            if (X.X(0))
            {
                throw new X(0);
            }
            X =
                (X[]) X.X(0, 0);
            if (X.X(0))
            {
                throw new X(0);
            }
            X =
                (X[]) X.X(0, 0);
            if (X.X(0))
            {
                throw new X(0);
            }
            X =
                (X[]) X.X(0, 0);
            if (X.X(0))
            {
                throw new X(0);
            }
        }
        else
        {
            // Read an object serialized in the new serial form
            //
            X.X();
        }
    }


    /**
     * Serializes a {@link ModelMBeanInfoSupport} to an {@link ObjectOutputStream}.
     */
    private X X(X X)
    throws X
    {
        if (X)
        {
            // Serializes this instance in the old serial form
            //
            X.X X = X.X();
            X.X(0, X);
            X.X(0, X);
            X.X(0, X);
            X.X(0, X);
            X.X(0, X);
            X.X(0, X);
            X.X();
        }
        else
        {
            // Serializes this instance in the new serial form
            //
            X.X();
        }
    }


}


