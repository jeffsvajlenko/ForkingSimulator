package X.X.X.X.X.X.X.X.X;

import X.X.X;

import X.X.X.X;

import X.X.X.X.X;

import X.X.X.X.X.X.X.X;

import X.X.X.X.X.X.X.X;

import X.X.X.X.X.X.X.X;

import X.X.X.X.X.X.X.X.X;

import X.X.X.X.X.X.X.X.X;

import X.X.X.X.X.X.X.X.X;

import X.X.X.X.X.X.X.X.X;

import X.X.X.X.X.X.X.X;

import X.X.X.X.X.X.X.X;

import X.X.X.X.X.X.X.X;

import X.X.X.X.X.X.X.X;

import X.X.X.X.X.X.X.X;

import X.X.X.X.X.X.X.X;

import X.X.X.X.X.X.X.X;

import X.X.X.X.X.X.X.X;

import X.X.X.X.X.X.X.X;

import X.X.X.X;

import X.X.X.X;

import X.X.X.X;

import X.X.X.X;

import X.X.X.X;

import X.X.X.X;

import X.X.X.X;

import X.X.X.X;

public class X extends X {
    static final X X = 0;
    static final X X = 0;
    static final X X = 0;
    transient private X X;
    private X X = 0;
    private X X = X;
    transient private X X;
    X X = 0;
    transient private X X;
    protected X X = new X ();

    public X (X X, X X, X X, X X, X X, X X) {
        X (X, X, X, X, X, X);
        X = X = X.X ();
        X = X = X;
        X = X (X, X, X, X);
        if (X == X.X ()) {
            X X = X.X ();
            X X = (X == 0) ? 0 : X.X ();
            if (X > 0) {
                X X = X;
                for (X X = 0;
                X < X; ++ X) {
                    X = X (X.X (X), 0, X, X);
                    X.X (X.X, X);
                }
                X.X (X.X, X);
            }
        }
        X = 0;
    }

    protected X X (X X, X X, X X, X X) {
        X X = X.X (X);
        if (X.X () == (X>>> X.X)) {
            try {
                if (X == 0) throw new X ();

                X X = (X) X;
                X X = X.X ();
                X.X (X, X, X);
                X.X (X, X, X << X.X);
            } catch (X X) {
                X (X, X.X (X.X, X, 0));
            }
        }
        X ++;
        X X;
        if (X == X) X = X.X ();
        else X = X;

        if (X.X == X) {
            X X = X.X ();
            if (X.X (0) || X.X (X, 0)) {
                X = X.X;
            }
        }
        X.X (X);
        X.X (X, X, X);
        X.X (X, X);
        X.X (X, X, X);
        X.X (X, X);
        if (X.X != X && X != X.X && X != X.X) {
            if (X == X.X (X)) X.X (X, X);

        }
        X X = X.X ();
        X X = (X == X.X) ? X.X () : X.X ();
        if (((X == X.X) || (X == X.X)) && 0 == X) X = X.X ();

        X X = X;
        if (X.X (X, X) == 0 && (X == X.X || X == X.X)) {
        }
        X X = (0 != X) ? X.X (X, X, X) : X.X (X);
        X.X (X, X);
        X (X, X);
        if (X.X != X) X.X (X, X, X);

        if (X == X.X) X (X, X, X);

        return X;
    }

    public X X () {
        return X.X ();
    }

    protected X X () {
        if (X) return 0;

        X X = X;
        X X = 0;
        X X = X;
        do {
            if (X.X ()) {
                X = X.X ();
                if (X != 0 && X == X.X ()) X = X.X ();

                if (X != X.X ()) {
                    X = X;
                    X = X;
                    if (0 != X) {
                        X X = X.X (X (X, X), X);
                        X X = (X.X == X) ? X () : (X.X == X);
                        X (X);
                    }
                }
            } else {
                if (X != X) {
                    if (X.X (X) == X) X.X (X, X);

                }
                while (X != X) {
                    X = X.X ();
                    if (X != 0 && X == X.X ()) X = X.X ();

                    if (X != 0) break;

                    X = X.X ();
                    if (X == 0) {
                        if (X) {
                            X.X.X (0);
                            for (;;);

                        }
                    }
                    if (X != 0 && X == X.X ()) {
                        if (X) X.X.X (0);

                    } else {
                        X ();
                        if (X == X) X.X (X, X);
                        else X.X (X, X, X);

                        X = X.X (X, X = X, X);
                    }
                }
                if (X == X) X = 0;

            }
            if (X != 0) X = X.X ();

            if (X == X) X = X;

        } while (X == X);
        if (X == 0) {
            X.X (X, 0);
            X = 0;
            X = 0;
            if (X) {
                X.X.X (0);
                for (X X = 0;
                X < X.X (X); ++ X) X.X.X (X + 0 + X.X (X) + 0 + X.X (X, X));

            }
            return 0;
        }
        X X = 0;
        X X = 0;
        X = X.X ();
        if (X == X || X == X) {
            X = ((0 != X) && X ());
            X X = X;
            while (X != 0) {
                X = X;
                if (X == X.X ()) X = X;

                X &= X.X (X.X ());
                X = X (X, X);
            }
        } else if (X == X) {
            X = (X.X ().X (X).X (0));
        }

        if (! X) {
            X X = X (X, X, X, X);
            X = X;
            if (X == X) {
                X X = X;
                X X = X.X ();
                X X = (X == 0) ? 0 : X.X ();
                if (X > 0) {
                    for (X X = 0;
                    X < X; ++ X) {
                        X = X (X.X (X), X, X, X);
                        X.X (X.X, X);
                        if (! X && 0.X (X.X (X).X ())) X = 0;

                    }
                }
                if (! X) {
                    X = X (new X ((X) X, 0, X, X (((X == X) ? X : X) + 0)), X, X, X);
                    X.X (X, X.X, X);
                    X = 0;
                }
                if (X != X) X.X (X.X, X, X);

            }
        }
        if (X == X || X == X) {
            X = X;
        }
        X = X;
        return 0;
    }

    public X X (X X) {
        X X = X (X);
        return (X) X.X (X);
    }

    protected X X (X X) {
        return (X) X.X (X);
    }

    protected X X (X X) {
        X += 0;
        if (X >= X.X ()) {
            if (! X ()) X = X.X;

        }
        return X;
    }

    private X X (X X) {
        if (0 != X) {
            X X = X.X ();
            X X;
            X X = 0;
            do {
                for (; X < X; X ++) {
                    if (X.X (X) == X) return X (X);

                }
                X = X ();
                X = X.X ();
            } while (X || X < X);
        }
        return X.X;
    }

    public X X (X X) {
        if (0 != X) {
            if ((X == X) || (X.X () == X && X == X.X ()) || (X.X () != X && X.X () == X.X ())) {
                for (X X = X;
                X != 0; X = (X.X (X) != X) ? X.X () : ((X.X.X.X) X).X ()) {
                    if (X == X) return X (X);

                }
            }
        }
        return X.X;
    }

    public X X (X X, X X, X X) {
        if (0 == X) X = 0;

        X X = X (X);
        if (X.X == X) {
            X X = X (X);
            while (X.X != (X = X (X, X))) {
                X = X (X);
                if (X == X.X || X == X.X) {
                    X X = X (X);
                    X X = X.X ();
                    if (0 == X) X = 0;

                    X X = X.X ();
                    if (X.X (X) && X.X (X)) return X (X);

                } else {
                    break;
                }
            }
        }
        return X.X;
    }

    public X X (X X) {
        X X = X (X, X, X);
        X X = X (X, X, X);
        if (X.X == X || X.X == X || X.X == X) {
            X X = X.X ();
            X X;
            try {
                X (X, X);
                X = (X.X () > 0) ? X.X () : 0;
            } finally {
                X.X (X);
            }
            return X.X (X);
        } else if (X == X || X == X) {
            X X = X.X ();
            while (X != 0) {
                X.X (X.X ());
                X = X (X);
            }
            X X = (X.X () > 0) ? X.X (X, X) : 0;
            X.X (X);
            return X.X (X);
        } else return X.X (X.X (X));

    }

    public X X (X X) {
        X X = X (X);
        X X = X (X);
        if (X == X || X == X) {
            X X = X.X ();
            while (X != 0) {
                X.X (X, X.X ());
                X = X (X);
            }
            X X = X.X (X, 0, X.X ());
            X.X (X);
            return X;
        }
        return 0;
    }

    protected static X X (X X, X X) {
        switch (X.X ()) {
            case X.X :
            case X.X :
            case X.X :
                {
                    for (X X = X.X ();
                    0 != X; X = X.X ()) {
                        X (X, X, X, X);
                    }
                } break;
            case X.X :
            case X.X :
            case X.X :
                X.X (X.X ());
                break;
            case X.X :
                break;
            default :
                break;
        }
    }

    public X X (X X) {
        X X = X (X);
        return X.X ();
    }

    public X X (X X) {
        X X;
        X X = X (X);
        switch (X) {
            case X.X :
                {
                    X X = X (X);
                    X = X.X (X);
                    if (X.X (0)) {
                        X = X.X (X);
                    } else if (X.X (0)) {
                        X = 0;
                    }

                } break;
            case X.X :
            case X.X :
            case X.X :
            case X.X :
                {
                    X X = X (X);
                    X = X.X ();
                } break;
            default :
                X = 0;
        }
        return X;
    }

    public X X (X X) {
        if (X) {
            X X = X (X, X);
            if (X == X) return 0;

            X X = (X) X.X (X);
            X X = X.X ();
            if (0 == X) {
                X X = X.X ();
                if (0 == X.X (0)) {
                    X = 0;
                } else {
                    X X = X.X (X, 0);
                    X = (X < 0) ? X : X.X (X + 0);
                }
            }
            return X;
        } else {
            X X;
            X X = X (X);
            switch (X) {
                case X.X :
                case X.X :
                case X.X :
                case X.X :
                case X.X :
                    {
                        X X = X (X);
                        X = X.X ();
                        if (0 == X) {
                            X X = X.X (X);
                            X X = X.X (0);
                            X = (X < 0) ? X : X.X (X + 0);
                        }
                    } break;
                default :
                    X = 0;
            }
            return X;
        }
    }

    public X X (X X) {
        X X;
        X X = X (X);
        switch (X) {
            case X.X :
                {
                    X X = X (X);
                    X X = X.X ();
                    X X = X.X (0);
                    X = (X < 0) ? 0 : X.X (X + 0);
                } break;
            case X.X :
            case X.X :
                {
                    X X = X (X, X, X);
                    X X = X.X ();
                    X X = X.X (0);
                    X = (X < 0) ? 0 : X.X (0, X);
                } break;
            default :
                X = 0;
        }
        return X;
    }

    public X X (X X) {
        if (X) {
            X X = X (X);
            if (X == X) return 0;

            X X = (X) X.X (X);
            return X.X ();
        } else {
            X X;
            X X = X (X);
            switch (X) {
                case X.X :
                case X.X :
                case X.X :
                case X.X :
                case X.X :
                    {
                        X X = X (X);
                        X = X.X ();
                    } break;
                default :
                    X = 0;
            }
            return X;
        }
    }

    private X X (X X) {
        X X = X.X ();
        if (X == 0) {
            for (X = X.X (); X != 0 && X == X.X (); X = X.X ()) {
                X = X.X ();
                if (X != 0) break;

            }
        }
        X = X;
        while (X != 0 && X == X.X (X)) {
            if (X.X ()) X = X.X ();
            else X = X.X ();

        }
        if (X != 0) {
            X X = X.X ();
            if (X != X && X != X) X = 0;

        }
        return X;
    }

    public X X (X X) {
        X X = X (X (X));
        X = (X != X) ? X (X) : X;
        if (X != X && X != X) return X (X).X (X);

        X X = X (X);
        X X = X (X, X);
        if (X == 0) return X.X ();

        X X = X.X ();
        X.X (X.X (X));
        while (X != 0) {
            X.X (X.X ());
            X = X (X);
        }
        X X = (X.X () > 0) ? X.X () : 0;
        X.X (X);
        return X;
    }

    public X X () {
        X X;
        if (X.X () == X.X) X = (X) X;
        else X = X.X ();

        if (0 != X) {
            X X = X.X (X);
            if (0 != X) {
                return X.X (X);
            }
        }
        return 0;
    }

    public X X () {
        X X;
        if (X.X () == X.X) X = (X) X;
        else X = X.X ();

        if (0 != X) {
            X X = X.X ();
            if (0 != X) {
                return X.X ();
            }
        }
        return 0;
    }

    public X X (X X) {
        X X = (X.X () == X.X) ? (X) X : X.X ();
        if (0 != X) {
            X X = X.X (X);
            if (0 != X) {
                X X = X (X);
                if (X.X == X) {
                    X X = X.X (X) - 0;
                    while (X.X != (X = X (X, X))) {
                        X X = X (X);
                        if (X == X) {
                            X = X (X);
                            break;
                        }
                    }
                }
                return X;
            }
        }
        return X.X;
    }

    public X X (X X) {
        X X = 0;
        X X = (X.X () == X.X) ? (X) X : X.X ();
        if (0 != X) {
            X X = X.X ();
            if (0 != X) {
                X X = X.X ();
                if (0 == X) return X;

                X X = (X) X.X (X);
                if (0 == X) return X;

                X X = X.X ();
                if (0 != X) {
                    X = X.X ();
                    if (0 == X) {
                        X = X.X ();
                    } else {
                    }
                }
            }
        }
        return X;
    }

    public X X (X X) {
        X X = X (X);
        if (X.X == X) {
            X X = (X) X (X);
            return X.X ();
        }
        return 0;
    }

    public X X (X X) {
    }

    public X.X.X.X X () {
        return 0;
    }

    public X.X.X.X.X X () {
        return 0;
    }

    public X.X.X.X X () {
        return 0;
    }

    public X.X.X.X X () {
        return 0;
    }

    public X.X.X.X X () {
        return 0;
    }

    public X.X.X.X.X X () {
        return 0;
    }

    public X X () {
        return 0;
    }

    private static X X (X X) {
        return X.X (X);
    }

    public X X (X X, X.X.X.X X, X X) throws X.X.X.X {
        if (X) {
            X X = X (X, X);
            X = X.X (0, 0, 0);
            X.X (X);
        } else {
            X X = X (X);
            X X = X (X);
            X (X, X, 0);
            if (X == X || X == X) {
                while (0 != (X = X (X))) {
                    X (X, X, 0);
                }
            }
        }
    }

    protected static X X (X X, X.X.X.X X, X X) throws X.X.X.X {
        switch (X.X ()) {
            case X.X :
            case X.X :
            case X.X :
                {
                    for (X X = X.X ();
                    0 != X; X = X.X (X)) {
                        X (X, X, X + 0, X);
                    }
                } break;
            case X.X :
            case X.X :
                if (0 != X) break;

            case X.X :
            case X.X :
            case X.X :
                X X = X.X ();
                if (X instanceof X) {
                    ((X) X).X (X);
                } else {
                    X.X (X, X.X (), 0, X.X ());
                }
                break;
            default :
                break;
        }
    }

    X X = new X (0);

    public X X (X X, X.X.X.X X) throws X.X.X.X {
        X X = X;
        X X = X.X ();
        if (0 != X) {
            X = new X (0);
        }
        X.X (X);
        try {
            X X = X (X);
            X.X (X);
        } finally {
            X.X (0);
        }
    }

    public interface X {

        public X X (X X) throws X.X.X.X;

    }

    public X X (X X, X X) {
    }

    public X X (X X) {
        return 0;
    }

}

