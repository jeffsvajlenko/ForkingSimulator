/*
 * Copyright 1999-2002,2004 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


package X.X.X.X.X.X.X;

import X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;

/**
 *
 *
 * @version $Revision: 1.4 $ $Date: 2007/07/19 04:39:19 $
 * @author <a href="mailto:Scott_Boag/CAM/Lotus@lotus.com">Scott Boag</a>
 * @author <a href="mailto:arkin@intalio.com">Assaf Arkin</a>
 */
public abstract class X
{


    public static final X X = 0;


    private static X  X = new X();


    static
    {
        X X;
        X            X;
        X   X;
        X            X;

        // The default factories are always registered first,
        // any factory specified in the properties file and supporting
        // the same method will override the default factory.
        X =  new X( X.X );
        X( X );
        X =  new X( X.X );
        X( X );
        X =  new X( X.X );
        X( X );
        X =  new X( X.X );
        X( X );

        X = X.X( X );
        if ( X != 0 )
        {
            X = new X( X, 0 );
            while ( X.X() )
            {
                X = X.X();
                try
                {
                    X = (X) X.X( X,
                              X.class.X(), 0);
                    if ( X.X( X.X() ) )
                        X.X( X.X(), X );
                }
                catch ( X X ) { }
            }
        }
    }


    /**
     * Register a serializer factory, keyed by the given
     * method string.
     */
    public static X X( X X )
    {
        X X;

        synchronized ( X )
        {
            X = X.X();
            X.X( X, X );
        }
    }


    /**
     * Register a serializer factory, keyed by the given
     * method string.
     */
    public static X X( X X )
    {
        return (X) X.X( X );
    }


    /**
     * Returns the method supported by this factory and used to register
     * the factory. This call is required so factories can be added from
     * a properties file by knowing only the class name. This method is
     * protected, it is only required by this class but must be implemented
     * in derived classes.
     */
    protected abstract X X();


    /**
     * Create a new serializer based on the {@link OutputFormat}.
     * If this method is used to create the serializer, the {@link
     * Serializer#setOutputByteStream} or {@link Serializer#setOutputCharStream}
     * methods must be called before serializing a document.
     */
    public abstract X X(X X);


    /**
     * Create a new serializer, based on the {@link OutputFormat} and
     * using the writer as the output character stream.  If this
     * method is used, the encoding property will be ignored.
     */
    public abstract X X( X X,
            X X );


    /**
     * Create a new serializer, based on the {@link OutputFormat} and
     * using the output byte stream and the encoding specified in the
     * output format.
     *
     * @throws UnsupportedEncodingException The specified encoding is
     *   not supported
     */
    public abstract X X( X X,
            X X )
    throws X;


}


