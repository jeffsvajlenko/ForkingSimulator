package javax.management.modelmbean;

import java.io.IOException;

import java.io.ObjectInputStream;

import java.io.ObjectOutputStream;

import java.io.ObjectStreamField;

import java.security.AccessController;

import java.security.PrivilegedAction;

import javax.management.Descriptor;

import javax.management.DescriptorAccess;

import javax.management.*;

import java.lang.reflect.*;

import com.sun.jmx.mbeanserver.GetPropertyAction;

import com.sun.jmx.trace.Trace;

public class ModelMBeanConstructorInfo extends MBeanConstructorInfo implements DescriptorAccess {
    private static final long oldSerialVersionUID = - 4440125391095574518L;
    private static final long newSerialVersionUID = 3862947819818064362L;
    private static final ObjectStreamField [] oldSerialPersistentFields = {new ObjectStreamField ("consDescriptor", Descriptor.class), new ObjectStreamField ("currClass", String.class)};
    private static final ObjectStreamField [] newSerialPersistentFields = {new ObjectStreamField ("consDescriptor", Descriptor.class)};
    private static final long serialVersionUID;
    private static final ObjectStreamField [] serialPersistentFields;
    private static boolean compat = false;

    static {
        try {
            GetPropertyAction act = new GetPropertyAction ("jmx.serial.form");
            String form = AccessController.doPrivileged (act);
            compat = (form != null && form.equals ("1.0"));
        } catch (Exception e) {
        }
        if (compat) {
            serialPersistentFields = oldSerialPersistentFields;
            serialVersionUID = oldSerialVersionUID;
        } else {
            serialPersistentFields = newSerialPersistentFields;
            serialVersionUID = newSerialVersionUID;
        }
    }

    private Descriptor consDescriptor = createDefaultDescriptor ();
    private final static String currClass = "ModelMBeanConstructorInfo";

    public ModelMBeanConstructorInfo (String description, Constructor constructorMethod) {
        super (description, constructorMethod);
        if (tracing ()) {
            trace ("ModelMBeanConstructorInfo(String, Method)", "Executed");
        }
        consDescriptor = createDefaultDescriptor ();
    }

    public ModelMBeanConstructorInfo (String description, Constructor constructorMethod, Descriptor descriptor) {
        super (description, constructorMethod);
        if (tracing ()) {
            trace ("ModelMBeanConstructorInfo(String, Method, Descriptor)", "Executed");
        }
        if (descriptor == null) {
            if (tracing ()) {
                trace ("ModelMBeanConstructorInfo(String, Method, Descriptor)", "Descriptor passed in is null, setting descriptor to default values");
            }
            consDescriptor = createDefaultDescriptor ();
        } else {
            if (isValid (descriptor)) {
                consDescriptor = (Descriptor) descriptor.clone ();
            } else {
                consDescriptor = createDefaultDescriptor ();
                throw new RuntimeOperationsException (new IllegalArgumentException ("Invalid descriptor passed in parameter"), ("Exception occurred in ModelMBeanConstructorInfo constructor"));
            }
        }
    }

    public ModelMBeanConstructorInfo (String name, String description, MBeanParameterInfo [] signature) {
        super (name, description, signature);
        if (tracing ()) {
            trace ("ModelMBeanConstructorInfo(String, String, MBeanParameterInfo[])", "Executed");
        }
        consDescriptor = createDefaultDescriptor ();
    }

    public ModelMBeanConstructorInfo (String name, String description, MBeanParameterInfo [] signature, Descriptor descriptor) {
        super (name, description, signature);
        if (tracing ()) {
            trace ("ModelMBeanConstructorInfo(String, String, MBeanParameterInfo[], Descriptor)", "Executed");
        }
        if (descriptor == null) {
            if (tracing ()) {
                trace ("ModelMBeanConstructorInfo(String, Method, Descriptor)", "Descriptor passed in is null, setting descriptor to default values");
            }
            consDescriptor = createDefaultDescriptor ();
        } else {
            if (isValid (descriptor)) {
                consDescriptor = (Descriptor) descriptor.clone ();
            } else {
                consDescriptor = createDefaultDescriptor ();
                throw new RuntimeOperationsException (new IllegalArgumentException ("Invalid descriptor passed in parameter"), ("Exception occurred in ModelMBeanConstructorInfo constructor"));
            }
        }
    }

    ModelMBeanConstructorInfo (ModelMBeanConstructorInfo old) {
        super (old.getName (), old.getDescription (), old.getSignature ());
        if (tracing ()) {
            trace ("ModelMBeanConstructorInfo(ModelMBeanConstructorInfo)", "Executed");
        }
        if (old.consDescriptor == null) {
            if (tracing ()) {
                trace ("ModelMBeanConstructorInfo(String, Method, Descriptor)", "Existing descriptor passed in is null, setting new descriptor to default values");
            }
            consDescriptor = createDefaultDescriptor ();
        } else {
            if (isValid (consDescriptor)) {
                consDescriptor = (Descriptor) old.consDescriptor.clone ();
            } else {
                consDescriptor = createDefaultDescriptor ();
                throw new RuntimeOperationsException (new IllegalArgumentException ("Invalid descriptor passed in parameter"), ("Exception occurred in ModelMBeanConstructorInfo constructor"));
            }
        }
    }

    public Object clone () {
        if (tracing ()) {
            trace ("ModelMBeanConstructorInfo.clone()", "Executed");
        }
        return (new ModelMBeanConstructorInfo (this));
    }

    public Descriptor getDescriptor () {
        if (tracing ()) {
            trace ("ModelMBeanConstructorInfo.getDescriptor()", "Executed");
        }
        if (consDescriptor == null) {
            consDescriptor = createDefaultDescriptor ();
        }
        return ((Descriptor) consDescriptor.clone ());
    }

    public void setDescriptor (Descriptor inDescriptor) {
        if (tracing ()) {
            trace ("ModelMBeanConstructorInfo.setDescriptor()", "Executed");
        }
        if (inDescriptor == null) {
            if (tracing ()) {
                trace ("ModelMBeanConstructorInfo(String, Method, Descriptor)", "Descriptor passed in is null, setting descriptor to default values");
            }
            consDescriptor = createDefaultDescriptor ();
        } else {
            if (isValid (inDescriptor)) {
                consDescriptor = (Descriptor) inDescriptor.clone ();
            } else {
                throw new RuntimeOperationsException (new IllegalArgumentException ("Invalid descriptor passed in parameter"), ("Exception occurred in ModelMBeanConstructorInfo setDescriptor"));
            }
        }
    }

    public String toString () {
        if (tracing ()) {
            trace ("ModelMBeanConstructorInfo.toString()", "Executed");
        }
        String retStr = "ModelMBeanConstructorInfo: " + this.getName () + " ; Description: " + this.getDescription () + " ; Descriptor: " + this.getDescriptor () + " ; Signature: ";
        MBeanParameterInfo [] pTypes = this.getSignature ();
        for (int i = 0;
        i < pTypes.length; i ++) {
            retStr = retStr.concat ((pTypes [i]).getType () + ", ");
        }
        return retStr;
    }

    private Descriptor createDefaultDescriptor () {
        if (tracing ()) {
            trace ("ModelMBeanConstructorInfo.createDefaultDescriptor()", "Executed");
        }
        return new DescriptorSupport (new String [] {"descriptorType=operation", "role=constructor", ("name=" + this.getName ()), ("displayname=" + this.getName ())});
    }

    private boolean isValid (Descriptor inDesc) {
        boolean results = true;
        String badField = "none";
        if (inDesc == null) {
            badField = "nullDescriptor";
            results = false;
        } else if (! inDesc.isValid ()) {
            badField = "invalidDescriptor";
            results = false;
        } else {
            if (! ((String) inDesc.getFieldValue ("name")).equalsIgnoreCase (this.getName ())) {
                badField = "name";
                results = false;
            }
            if (! ((String) inDesc.getFieldValue ("descriptorType")).equalsIgnoreCase ("operation")) {
                badField = "descriptorType";
                results = false;
            }
            if (inDesc.getFieldValue ("role") == null) {
                inDesc.setField ("role", "constructor");
            }
            if (! ((String) inDesc.getFieldValue ("role")).equalsIgnoreCase ("constructor")) {
                badField = "role";
                results = false;
            } else if ((inDesc.getFieldValue ("displayName")) == null) {
                inDesc.setField ("displayName", this.getName ());
            }

        }

        if (tracing ()) trace ("isValid()", ("Returning " + results + ": Invalid field is " + badField));

        return results;
    }

    private boolean tracing () {
        return Trace.isSelected (Trace.LEVEL_TRACE, Trace.INFO_MODELMBEAN);
    }

    private void trace (String inClass, String inMethod, String inText) {
        Trace.send (Trace.LEVEL_TRACE, Trace.INFO_MODELMBEAN, inClass, inMethod, Integer.toHexString (this.hashCode ()) + " " + inText);
    }

    private void trace (String inMethod, String inText) {
        trace (currClass, inMethod, inText);
    }

    private void readObject (ObjectInputStream in) throws IOException, ClassNotFoundException {
        in.defaultReadObject ();
    }

    private void writeObject (ObjectOutputStream out) throws IOException {
        if (compat) {
            ObjectOutputStream.PutField fields = out.putFields ();
            fields.put ("consDescriptor", consDescriptor);
            fields.put ("currClass", currClass);
            out.writeFields ();
        } else {
            out.defaultWriteObject ();
        }
    }

}

