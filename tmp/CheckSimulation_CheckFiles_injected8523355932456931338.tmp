package X.X.X.X.X.X.X.X.X;

import X.X.X.X.X.X.X.X;

import X.X.X.X.X.X.X.X.X;

public class X implements X {
    private static X X = 0;
    private static X X = 0;

    static {
        X = X.X ();
        X = X.X ();
    }

    private static final X X = 0;
    private X X [] = 0;
    private X X [] = 0;
    private X X = 0;
    private X X;
    private X X = 0;
    private X X [] = 0;
    private X X [] = 0;
    private X X = 0;
    private X X = 0;
    private X X [] = 0;
    private X X [] = 0;
    private X X [] [] = 0;
    private X X = 0;
    private X X = 0;
    private X X = new X ();

    public X (X X, X X, X X) {
        X = X;
        X = X;
        X (X);
    }

    public X X (X [] X, X X, X X) {
        if (X) X.X.X (0);

        if (X == 0) {
            if (X) {
                X.X.X (0);
                X.X.X ();
                for (X X = 0;
                X < X.X; X ++) {
                    X X = X [X].X;
                    X X = X [X].X;
                    X.X.X (0 + X + 0 + X + 0 + X + 0 + X + 0 + X + 0);
                }
                X.X.X (0 + X);
            }
            return X ? - 0 : 0;
        }
        X X = 0;
        for (X X = 0;
        X < X; X ++) {
            final X X = X [X + X];
            if (X && X.X == 0) {
                continue;
            }
            X X = 0;
            for (; X < X; X ++) {
                X X = X [X] & 0;
                if (X == X.X) {
                    if (X [X].X == X.X) {
                        break;
                    }
                } else if (X == X.X) {
                    X X = X [X].X;
                    if (X == 0 || X == X.X) {
                        break;
                    }
                } else if (X == X.X) {
                    if (X.X == 0) {
                        break;
                    }
                } else if (X == X.X) {
                    if (X [X].X != X.X) {
                        break;
                    }
                }

            }
            if (X == X) {
                if (X) {
                    X.X.X (0);
                    X.X.X (0 + X);
                    for (X X = 0;
                    X < X; X ++) {
                        X.X.X ();
                        X.X.X (0 + X + 0 + X [X]);
                    }
                }
                return X;
            }
            X = X [X] [X];
            if (X == - 0) {
                if (X) X.X.X (0);

                return X;
            }
        }
        if (X) X.X.X (0 + X + 0 + X);

        if (! X [X]) return X;

        return - 0;
    }

    private X X (X X) {
        X.X (0, X, X, 0);
        X X = new X ();
        X = new X (X.X, X, X);
        X = X;
        X.X (X ++);
        X = new X [X];
        X = new X [X];
        X (X, 0);
        X = new X [X];
        for (X X = 0;
        X < X; X ++) X [X] = new X (X);

        X ();
        X = new X [X];
        X = new X [X];
        X = 0;
        for (X X = 0;
        X < X; X ++) {
            X [X] = new X ();
            final X X = X [X].X ();
            X X = 0;
            for (; X < X; X ++) {
                if (X [X].X == X.X) {
                    break;
                }
            }
            if (X == X) {
                X [X].X (X);
                X [X] = X [X];
                X ++;
            }
        }
        X [] X = new X [X + X];
        X X = 0;
        for (X X = 0;
        X < X; X ++) {
            for (X X = 0;
            X < X; X ++) {
                final X X = X [X].X ();
                final X X = X [X];
                if (X.X == X.X) {
                    X [X ++] = X;
                }
            }
            X [X ++] = - 0;
        }
        X X = X * 0;
        X [] X = new X [X];
        X = new X [X];
        X = new X [X] [];
        X X = X.X ();
        X X = 0;
        X X = 0;
        X [X] = X ();
        X [X] = X;
        X ++;
        X.X.X X = new X.X.X ();
        while (X < X) {
            X = X [X];
            X [] X = X [X];
            X [X] = X.X (X);
            X ++;
            X X = 0;
            X X = 0;
            for (X X = 0;
            X < X; X ++) {
                if (X == 0) X = new X (X);
                else X.X ();

                X X = X [X ++];
                while (X != - 0) {
                    if (X.X (X)) {
                        X.X (X [X]);
                    }
                    X = X [X ++];
                }
                if (! X.X ()) {
                    X X = (X) X.X (X);
                    X X = (X == 0 ? X : X.X ());
                    if (X == X) {
                        X [X] = X;
                        X [X] = X ();
                        X.X (X, new X (X));
                        X ++;
                        X = 0;
                    }
                    X [X] = X;
                    if (X == X) {
                        final X X = (X) (X * 0);
                        X [] X = new X [X];
                        X [] X = new X [X];
                        X [] [] X = new X [X] [];
                        for (X X = 0;
                        X < X; X ++) {
                            X [X] = X [X];
                            X [X] = X [X];
                            X [X] = X [X];
                        }
                        X = X;
                        X = X;
                        X = X;
                        X = X;
                    }
                }
            }
        }
        X = ((X) X).X ().X ();
        if (X) X (X, 0);

        X = 0;
        X = 0;
        X = 0;
    }

    private X X (X X) {
        if (X.X () == X.X) {
            X ();
            X ();
        } else if (X.X () == X.X) {
            X (((X) X).X ());
            X (((X) X).X ());
            final X X = ((X) X).X ().X ();
            final X X = ((X) X).X ().X ();
            for (X X = 0;
            X < X; X ++) {
                if (X.X (X)) X [X].X (X);

            }
        } else if (X.X () == X.X || X.X () == X.X) {
            X (((X) X).X ());
            final X X = X.X ();
            final X X = X.X ();
            for (X X = 0;
            X < X; X ++) {
                if (X.X (X)) X [X].X (X);

            }
        } else if (X.X () == X.X) {
            X (((X) X).X ());
        }

    }

    private X X (X X, X X) {
        for (X X = 0;
        X < X; X ++) X.X.X (0);

        X X = X.X ();
        if ((X == X.X) || (X == X.X)) {
            if (X == X.X) X.X.X ();
            else X.X.X (0);

            if (X.X ()) X.X.X ();

            X.X.X (0);
            X.X.X (X.X ().X ());
            X.X.X (0);
            X.X.X (X.X ().X ());
            X (((X) X).X (), X + 0);
            X (((X) X).X (), X + 0);
        } else if (X.X () == X.X) {
            X.X.X (0);
            if (X.X ()) X.X.X ();

            X.X.X ();
            X.X.X (X.X ().X ());
            X.X.X (0);
            X.X.X (X.X ().X ());
            X (((X) X).X (), X + 0);
        } else if (X.X () == X.X) {
            X.X.X (0 + ((X) X).X () + 0 + ((X) X).X () + 0 + ((X) X).X () + 0);
            if (X.X ()) X.X.X (0);

            X.X.X (0);
            X.X.X (X.X ().X ());
            X.X.X (0);
            X.X.X (X.X ().X ());
        } else {
            throw new X (0);
        }

    }

    private X [] X () {
        X [] X = new X [X];
        for (X X = 0;
        X < X; X ++) X [X] = - 0;

        return X;
    }

    private X X (X X, X X) {
        X.X (X);
        if ((X.X () & 0) == X.X || (X.X () & 0) == X.X || (X.X () & 0) == X.X) {
            X X = new X (0, 0, ((X) X).X ());
            X [X] = new X (X);
            X [X] = X.X ();
            X ++;
        } else if ((X.X () == X.X) || (X.X () == X.X)) {
            X = X (((X) X).X (), X);
            X = X (((X) X).X (), X);
        } else if (X.X () == X.X || X.X () == X.X || X.X () == X.X) {
            X = X (((X) X).X (), X);
        } else if (X.X () == X.X) {
            final X X = ((X) X).X ();
            if (X.X != X) {
                X [X] = (X) X;
                X [X] = X.X;
                X ++;
            }
        } else {
            throw new X (0 + X.X ());
        }

        return X;
    }

}

