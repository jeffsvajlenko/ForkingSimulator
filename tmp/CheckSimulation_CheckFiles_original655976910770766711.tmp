package X.X.X.X.X.X.X;

import X.X.X;

import X.X.X;

import X.X.X;

import X.X.X;

import X.X.X.X;

import X.X.X.X;

import X.X.X.X;

import X.X.X.X.X;

import X.X.X.X;

import X.X.X.X;

import X.X.X.X;

import X.X.X.X;

import X.X.X.X;

import X.X.X.X;

import X.X.X.X.X.X.X;

import X.X.X.X.X.X.X;

import X.X.X.X.X.X.X;

public class X extends X.X.X.X implements X {
    private final X X;
    private X X;
    private X X;
    private X X = new X (0);
    private X X = 0;
    private X X = 0;
    private X X = 0;
    private X X;
    private X X;

    private X X (X X) {
        switch (X.X ()) {
            case X.X :
                return 0;
            case X.X :
                return 0;
            case X.X :
                return 0;
            case X.X :
                return 0;
        }
        return 0;
    }

    public X X () {
        return 0 + X + 0 + X (X) + 0 + X + 0 + X + 0;
    }

    X X () {
        return X;
    }

    X X () {
        return X;
    }

    private X X () {
        try {
            if (X) {
                X.X (X, 0 + X + 0 + X);
            }
            X ++;
            X ();
        } catch (X.X.X X) {
        } finally {
            X --;
            if (X) {
                X.X (X, 0 + X + 0 + X);
            }
        }
    }

    private X X () {
        if (X) {
            X.X (X, 0 + X + 0 + X);
        }
        if (X > 0) X ();

    }

    public X X () {
        return X;
    }

    X (X X, X X) {
        X.X = X;
        X.X (X);
        X.X = X;
        X = X.X ();
        X = X.X;
        X = X.X ().X;
        X = 0;
        if (X) {
            X.X (X, 0 + X);
        }
    }

    synchronized X X (X X) {
        if (X.X () == X.X) {
            X X = X.X ();
            throw X.X (X.X);
        }
        X.X (X);
    }

    synchronized X X (X X) {
        X.X (X);
        if (X.X ()) {
            X.X (X);
        }
    }

    public X X () {
        switch (X.X ()) {
            case X.X :
                return X.X;
            case X.X :
                return X.X;
            case X.X :
                return X.X;
            case X.X :
                return X.X;
            default :
                return X.X;
        }
    }

    public synchronized X X () throws X.X.X.X.X {
        X = 0;
        if (X) {
            X.X (X, 0 + X);
        }
        try {
            if (X.X () == X.X) throw new X.X.X.X.X ();

            X = X.X;
            X.X (X, X ());
            X ();
        } finally {
            if (X) {
                X.X (X, 0 + X);
            }
        }
    }

    public synchronized X X (X X) throws X.X.X.X.X {
        X = 0;
        if (X) {
            X.X (X, 0 + X);
        }
        try {
            if (X.X () == X.X) throw new X.X.X.X.X ();

            X = X.X;
            X.X (X, X ());
            X ();
            if (X) {
                while (X.X () == X.X && X > 0) {
                    X ();
                }
            }
        } finally {
            if (X) {
                X.X (X, 0 + X);
            }
        }
    }

    public synchronized X X (X X) throws X.X.X.X.X {
        X = 0;
        if (X) {
            X.X (X, 0 + X);
        }
        try {
            if (X.X () == X.X) throw new X.X.X.X.X ();

            X = X.X;
            X.X (X, X ());
            X ();
            if (X) {
                while (X.X () == X.X && X > 0) {
                    X ();
                }
            }
        } finally {
            if (X) {
                X.X (X, 0 + X);
            }
        }
    }

    public X X (X X, X X) throws X.X.X.X.X {
        X = 0;
        try {
            synchronized (X) {
                if (X) {
                    X.X (X, 0 + X);
                }
                if (X.X () == X.X) throw new X.X.X.X.X ();

                X = X.X;
                X.X (X, X ());
                X ();
            }
            X X = new X (X, X, X);
            if (X) X.X ();
            else {
                X X = new X (X);
                X.X ();
            }
        } finally {
            synchronized (X) {
                if (X) {
                    X.X (X, 0 + X);
                }
            }
        }
    }

    private class X implements X {
        private X X;
        private X X;
        private X X;

        X (X X, X X, X X) {
            X.X = X;
            X.X = X;
            X.X = X;
        }

        public X X () {
            try {
                synchronized (X) {
                    if (X) {
                        X.X (X, 0 + X + 0 + X);
                    }
                    while (X.X > 0) {
                        X ();
                    }
                }
                if (X) {
                    X X = 0;
                    synchronized (X) {
                        if (X) {
                            X.X (X, 0 + X);
                        }
                        X = (new X (X.X)).X ();
                    }
                    while (X.X ()) {
                        ((X) X.X ()).X ();
                    }
                    synchronized (X) {
                        if (X) {
                            X.X (X, 0 + 0 + X);
                        }
                        X.X (X);
                        X.X ();
                    }
                }
            } finally {
                if (X) {
                    synchronized (X) {
                        X.X (X, 0);
                    }
                }
            }
        }

    }

    public X.X.X.X.X X () {
        return X;
    }

    synchronized X X () {
        try {
            if (X) {
                X.X (X, 0 + X);
            }
            X ();
        } finally {
            if (X) {
                X.X (X, 0 + X);
            }
        }
    }

    private X X () {
        while (X.X () != X.X) {
            switch (X.X ()) {
                case X.X :
                    while (X.X () == X.X) {
                        X ();
                    }
                    break;
                case X.X :
                    throw X.X ().X ();
                case X.X :
                    throw X.X ().X ();
            }
        }
    }

    synchronized X X () {
        try {
            if (X) {
                X.X (X, 0 + X);
            }
            X ();
            X ++;
        } finally {
            if (X) {
                X.X (X, 0 + X);
            }
        }
    }

    synchronized X X () {
        try {
            if (X) {
                X.X (X, 0 + X);
            }
            X --;
            if (X == 0) {
                X ();
            }
        } finally {
            if (X) {
                X.X (X, 0 + X);
            }
        }
    }

    public synchronized X X () {
        if (! X) try {
            X ();
        } catch (X.X.X.X.X X) {
        }

    }

}

