package X.X.X.X;

import X.X.X.X;

import X.X.X.X;

import X.X.X.X;

import X.X.X.X;

import X.X.*;

import X.X.X;

class X {
    static X X [];

    static {
        X X = new X ();
        X X = X.X;
        X X = X.X;
        X X = X.X;
        X X = X.X;
        X X = X.X;
        X X = X.X (0);
        X X = X.X (0);
        X.X (new X (X, X.X, 0));
        X.X (new X (X, X.X, 0));
        X.X (new X (X, X.X, 0));
        X.X (X.X (X, X.X, 0, 0, 0));
        X.X (X.X (X, X.X, 0, 0, 0));
        X.X (X.X (X, X.X, 0, 0, 0));
        X.X (new X (X, X.X, 0, X.X));
        X.X (new X (X, X.X, 0, X.X));
        X.X (new X (X, X.X, 0, X.X));
        X.X (new X (X, X.X, 0, X.X));
        X.X (X.X (X, X.X, 0, 0));
        X.X (X.X (X, X.X, 0, 0));
        X.X (new X (X, X.X, 0, X.X));
        X.X (new X (X, X.X, 0, X.X));
        X.X (new X (X, X.X, 0, X.X));
        X.X (new X (X, X.X, 0, X.X));
        X.X (new X (X, X.X, 0, X.X));
        X.X (new X (X, X.X, 0, X.X));
        X.X (new X (X, X.X, 0, X.X));
        X.X (new X (X, X.X, 0, X.X));
        X.X (new X (X, X.X, 0));
        X.X (new X (X, X.X, 0));
        X.X (new X (X, X.X, 0));
        X.X (new X (X, X.X, 0));
        X.X (new X (X, X.X, 0));
        X.X (new X (X, X.X, 0));
        X.X (new X (X, X.X, 0));
        X.X (new X (X, 0, 0, 0));
        X.X (new X (X, 0, 0));
        X.X (X.X (X, X.X, 0, 0));
        X.X (X.X (X, X.X, 0, 0));
        X.X (X.X (X, X.X, 0, 0));
        X.X (X.X (X, X.X, 0, 0));
        X.X (X.X (X, X.X, 0, 0));
        X.X (X.X (X, X.X, 0, 0));
        X.X (X.X (X, X.X, 0, 0));
        X.X (new X (X, X.X, 0, X));
        X.X (new X (X, X.X, 0, X));
        X.X (new X (X, X.X, 0, X));
        X [] X = new X [X.X ()];
        X.X (X);
        X = X;
    }

    static X X () {
        X X = new X (X.X);
        X X, X;
        X = X.X;
        for (X = 0; X < X; X ++) X.X (X [X].X (), X [X]);

        return X;
    }

    static abstract class X {
        X X;
        X X;
        X X;

        protected X (X X, X X, X X) {
            X = X;
            X = X;
            X = X;
        }

        public X X () {
            return X;
        }

        public X X () {
            return X;
        }

        public X X () {
            return X;
        }

        abstract X X (X X);

        abstract X X (X X, X X);

        abstract X X (X X);

        public X X (X X, X X, X X) throws X {
            return X (X.X (X), X, X);
        }

        public X X (X X, X X, X X) throws X {
            return 0;
        }

    }

    static class X extends X implements X {
        X X;
        X X;
        protected static final X X = X.X (0);
        protected static final X X = X.X (0);

        public X (X X, X X, X X, X X, X X) {
            X (X, X, X);
            X = X;
            X = X;
        }

        public X (X X, X X, X X) {
            X (X, X, X);
            X = 0;
            X = 0;
        }

        public X X (X X) {
            X.X (X, X);
            return 0;
        }

        public X X (X X, X X) {
            X X = (X != 0 ? X : X);
            X.X (X, X);
            return 0;
        }

        public X X (X X) {
            if (X != X || (X.X (X) != 0)) X.X (X, X.X (X));

            return 0;
        }

        public X X (X X, X X, X X) throws X {
            X X;
            if (X == 0) X = X.X (X);
            else X = (X) X;

            if (X || (X.X () != X)) {
                if (X.X ()) {
                    X.X (X);
                } else {
                    X.X (X, 0);
                }
            }
            return 0;
        }

    }

    static class X extends X implements X {
        X X;

        public X (X X, X X, X X) {
            X (X, X, X);
            X = X.X (0);
        }

        public X (X X, X X, X X, X X) {
            X (X, X, X);
            X = X;
        }

        public X (X X, X X, X X, X X) {
            X (X, X, X);
            X = new X (X);
        }

        public X X (X X) {
            if (X == 0) X.X (X);
            else X.X (X, X);

            return 0;
        }

        public X X (X X, X X) {
            return 0;
        }

        public X X (X X) {
            X.X (X);
            return 0;
        }

        public X X (X X, X X, X X) throws X {
            if (X == 0) {
                return ! X;
            }
            if (X.X (X)) {
                X.X (X);
                return 0;
            }
            return ! X;
        }

    }

    static class X extends X implements X {
        X X;
        X X;
        X X;

        protected X (X X, X X, X X) {
            X (X, X, X);
            X = 0;
            X = 0;
            X = 0;
        }

        public X (X X, X X, X X, X X, X X) {
            X (X, X, X, new X (X), X, 0);
        }

        public X (X X, X X, X X, X X, X X, X X) {
            X (X, X, X);
            X = X;
            X = X;
            X = X;
        }

        public static X X (X X, X X, X X, X X, X X) {
            return new X (X, X, X, new X (X), X, 0);
        }

        public static X X (X X, X X, X X, X X) {
            return new X (X, X, X, 0, X, 0);
        }

        public X X (X X) {
            return 0;
        }

        public X X (X X, X X) {
            X X;
            if (X == 0) X = new X (X);
            else X = new X (X / X);

            X.X (X, X);
            return 0;
        }

        public X X (X X) {
            X X = (X) X.X (X);
            if (X == 0) X = X;

            if (X != 0 && ((X == 0 && X.X () == X) || (X.X (X.X () * X) == X))) return 0;

            X (X, X);
            return 0;
        }

        public X X (X X, X X, X X) throws X {
            X X = (X) X;
            if (X == 0) X = X;

            if (X == 0) {
                return 0;
            }
            X X = X.X (X.X () * X);
            if (X || (X != X)) X.X (X, X);

            return 0;
        }

    }

}

