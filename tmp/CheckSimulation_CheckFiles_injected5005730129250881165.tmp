/*
 * %W% %E%
 *
 * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
 * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 */

package X.X.X;

import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;


/**
 * A compiled representation of a regular expression.
 *
 * <p> A regular expression, specified as a string, must first be compiled into
 * an instance of this class.  The resulting pattern can then be used to create
 * a {@link Matcher} object that can match arbitrary {@link
 * java.lang.CharSequence </code>character sequences<code>} against the regular
 * expression.  All of the state involved in performing a match resides in the
 * matcher, so many matchers can share the same pattern.
 *
 * <p> A typical invocation sequence is thus
 *
 * <blockquote><pre>
 * Pattern p = Pattern.{@link #compile compile}("a*b");
 * Matcher m = p.{@link #matcher matcher}("aaaaab");
 * boolean b = m.{@link Matcher#matches matches}();</pre></blockquote>
 *
 * <p> A {@link #matches matches} method is defined by this class as a
 * convenience for when a regular expression is used just once.  This method
 * compiles an expression and matches an input sequence against it in a single
 * invocation.  The statement
 *
 * <blockquote><pre>
 * boolean b = Pattern.matches("a*b", "aaaaab");</pre></blockquote>
 *
 * is equivalent to the three statements above, though for repeated matches it
 * is less efficient since it does not allow the compiled pattern to be reused.
 *
 * <p> Instances of this class are immutable and are safe for use by multiple
 * concurrent threads.  Instances of the {@link Matcher} class are not safe for
 * such use.
 *
 *
 * <a name="sum">
 * <h4> Summary of regular-expression constructs </h4>
 *
 * <table border="0" cellpadding="1" cellspacing="0"
 *  summary="Regular expression constructs, and what they match">
 *
 * <tr align="left">
 * <th bgcolor="#CCCCFF" align="left" id="construct">Construct</th>
 * <th bgcolor="#CCCCFF" align="left" id="matches">Matches</th>
 * </tr>
 *
 * <tr><th>&nbsp;</th></tr>
 * <tr align="left"><th colspan="2" id="characters">Characters</th></tr>
 *
 * <tr><td valign="top" headers="construct characters"><i>x</i></td>
 *     <td headers="matches">The character <i>x</i></td></tr>
 * <tr><td valign="top" headers="construct characters"><tt>\\</tt></td>
 *     <td headers="matches">The backslash character</td></tr>
 * <tr><td valign="top" headers="construct characters"><tt>\0</tt><i>n</i></td>
 *     <td headers="matches">The character with octal value <tt>0</tt><i>n</i>
 *         (0&nbsp;<tt>&lt;=</tt>&nbsp;<i>n</i>&nbsp;<tt>&lt;=</tt>&nbsp;7)</td></tr>
 * <tr><td valign="top" headers="construct characters"><tt>\0</tt><i>nn</i></td>
 *     <td headers="matches">The character with octal value <tt>0</tt><i>nn</i>
 *         (0&nbsp;<tt>&lt;=</tt>&nbsp;<i>n</i>&nbsp;<tt>&lt;=</tt>&nbsp;7)</td></tr>
 * <tr><td valign="top" headers="construct characters"><tt>\0</tt><i>mnn</i></td>
 *     <td headers="matches">The character with octal value <tt>0</tt><i>mnn</i>
 *         (0&nbsp;<tt>&lt;=</tt>&nbsp;<i>m</i>&nbsp;<tt>&lt;=</tt>&nbsp;3,
 *         0&nbsp;<tt>&lt;=</tt>&nbsp;<i>n</i>&nbsp;<tt>&lt;=</tt>&nbsp;7)</td></tr>
 * <tr><td valign="top" headers="construct characters"><tt>\x</tt><i>hh</i></td>
 *     <td headers="matches">The character with hexadecimal&nbsp;value&nbsp;<tt>0x</tt><i>hh</i></td></tr>
 * <tr><td valign="top" headers="construct characters"><tt>&#92;u</tt><i>hhhh</i></td>
 *     <td headers="matches">The character with hexadecimal&nbsp;value&nbsp;<tt>0x</tt><i>hhhh</i></td></tr>
 * <tr><td valign="top" headers="matches"><tt>\t</tt></td>
 *     <td headers="matches">The tab character (<tt>'&#92;u0009'</tt>)</td></tr>
 * <tr><td valign="top" headers="construct characters"><tt>\n</tt></td>
 *     <td headers="matches">The newline (line feed) character (<tt>'&#92;u000A'</tt>)</td></tr>
 * <tr><td valign="top" headers="construct characters"><tt>\r</tt></td>
 *     <td headers="matches">The carriage-return character (<tt>'&#92;u000D'</tt>)</td></tr>
 * <tr><td valign="top" headers="construct characters"><tt>\f</tt></td>
 *     <td headers="matches">The form-feed character (<tt>'&#92;u000C'</tt>)</td></tr>
 * <tr><td valign="top" headers="construct characters"><tt>\a</tt></td>
 *     <td headers="matches">The alert (bell) character (<tt>'&#92;u0007'</tt>)</td></tr>
 * <tr><td valign="top" headers="construct characters"><tt>\e</tt></td>
 *     <td headers="matches">The escape character (<tt>'&#92;u001B'</tt>)</td></tr>
 * <tr><td valign="top" headers="construct characters"><tt>\c</tt><i>x</i></td>
 *     <td headers="matches">The control character corresponding to <i>x</i></td></tr>
 *
 * <tr><th>&nbsp;</th></tr>
 * <tr align="left"><th colspan="2" id="classes">Character classes</th></tr>
 *
 * <tr><td valign="top" headers="construct classes"><tt>[abc]</tt></td>
 *     <td headers="matches"><tt>a</tt>, <tt>b</tt>, or <tt>c</tt> (simple class)</td></tr>
 * <tr><td valign="top" headers="construct classes"><tt>[^abc]</tt></td>
 *     <td headers="matches">Any character except <tt>a</tt>, <tt>b</tt>, or <tt>c</tt> (negation)</td></tr>
 * <tr><td valign="top" headers="construct classes"><tt>[a-zA-Z]</tt></td>
 *     <td headers="matches"><tt>a</tt> through <tt>z</tt>
 *         or <tt>A</tt> through <tt>Z</tt>, inclusive (range)</td></tr>
 * <tr><td valign="top" headers="construct classes"><tt>[a-d[m-p]]</tt></td>
 *     <td headers="matches"><tt>a</tt> through <tt>d</tt>,
 *      or <tt>m</tt> through <tt>p</tt>: <tt>[a-dm-p]</tt> (union)</td></tr>
 * <tr><td valign="top" headers="construct classes"><tt>[a-z&&[def]]</tt></td>
 *     <td headers="matches"><tt>d</tt>, <tt>e</tt>, or <tt>f</tt> (intersection)</tr>
 * <tr><td valign="top" headers="construct classes"><tt>[a-z&&[^bc]]</tt></td>
 *     <td headers="matches"><tt>a</tt> through <tt>z</tt>,
 *         except for <tt>b</tt> and <tt>c</tt>: <tt>[ad-z]</tt> (subtraction)</td></tr>
 * <tr><td valign="top" headers="construct classes"><tt>[a-z&&[^m-p]]</tt></td>
 *     <td headers="matches"><tt>a</tt> through <tt>z</tt>,
 *          and not <tt>m</tt> through <tt>p</tt>: <tt>[a-lq-z]</tt>(subtraction)</td></tr>
 * <tr><th>&nbsp;</th></tr>
 *
 * <tr align="left"><th colspan="2" id="predef">Predefined character classes</th></tr>
 *
 * <tr><td valign="top" headers="construct predef"><tt>.</tt></td>
 *     <td headers="matches">Any character (may or may not match <a href="#lt">line terminators</a>)</td></tr>
 * <tr><td valign="top" headers="construct predef"><tt>\d</tt></td>
 *     <td headers="matches">A digit: <tt>[0-9]</tt></td></tr>
 * <tr><td valign="top" headers="construct predef"><tt>\D</tt></td>
 *     <td headers="matches">A non-digit: <tt>[^0-9]</tt></td></tr>
 * <tr><td valign="top" headers="construct predef"><tt>\s</tt></td>
 *     <td headers="matches">A whitespace character: <tt>[ \t\n\x0B\f\r]</tt></td></tr>
 * <tr><td valign="top" headers="construct predef"><tt>\S</tt></td>
 *     <td headers="matches">A non-whitespace character: <tt>[^\s]</tt></td></tr>
 * <tr><td valign="top" headers="construct predef"><tt>\w</tt></td>
 *     <td headers="matches">A word character: <tt>[a-zA-Z_0-9]</tt></td></tr>
 * <tr><td valign="top" headers="construct predef"><tt>\W</tt></td>
 *     <td headers="matches">A non-word character: <tt>[^\w]</tt></td></tr>
 *
 * <tr><th>&nbsp;</th></tr>
 * <tr align="left"><th colspan="2" id="posix">POSIX character classes</b> (US-ASCII only)<b></th></tr>
 *
 * <tr><td valign="top" headers="construct posix"><tt>\p{Lower}</tt></td>
 *     <td headers="matches">A lower-case alphabetic character: <tt>[a-z]</tt></td></tr>
 * <tr><td valign="top" headers="construct posix"><tt>\p{Upper}</tt></td>
 *     <td headers="matches">An upper-case alphabetic character:<tt>[A-Z]</tt></td></tr>
 * <tr><td valign="top" headers="construct posix"><tt>\p{ASCII}</tt></td>
 *     <td headers="matches">All ASCII:<tt>[\x00-\x7F]</tt></td></tr>
 * <tr><td valign="top" headers="construct posix"><tt>\p{Alpha}</tt></td>
 *     <td headers="matches">An alphabetic character:<tt>[\p{Lower}\p{Upper}]</tt></td></tr>
 * <tr><td valign="top" headers="construct posix"><tt>\p{Digit}</tt></td>
 *     <td headers="matches">A decimal digit: <tt>[0-9]</tt></td></tr>
 * <tr><td valign="top" headers="construct posix"><tt>\p{Alnum}</tt></td>
 *     <td headers="matches">An alphanumeric character:<tt>[\p{Alpha}\p{Digit}]</tt></td></tr>
 * <tr><td valign="top" headers="construct posix"><tt>\p{Punct}</tt></td>
 *     <td headers="matches">Punctuation: One of <tt>!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~</tt></td></tr>
 *     <!-- <tt>[\!"#\$%&'\(\)\*\+,\-\./:;\<=\>\?@\[\\\]\^_`\{\|\}~]</tt>
 *          <tt>[\X21-\X2F\X31-\X40\X5B-\X60\X7B-\X7E]</tt> -->
 * <tr><td valign="top" headers="construct posix"><tt>\p{Graph}</tt></td>
 *     <td headers="matches">A visible character: <tt>[\p{Alnum}\p{Punct}]</tt></td></tr>
 * <tr><td valign="top" headers="construct posix"><tt>\p{Print}</tt></td>
 *     <td headers="matches">A printable character: <tt>[\p{Graph}\x20]</tt></td></tr>
 * <tr><td valign="top" headers="construct posix"><tt>\p{Blank}</tt></td>
 *     <td headers="matches">A space or a tab: <tt>[ \t]</tt></td></tr>
 * <tr><td valign="top" headers="construct posix"><tt>\p{Cntrl}</tt></td>
 *     <td headers="matches">A control character: <tt>[\x00-\x1F\x7F]</tt></td></tr>
 * <tr><td valign="top" headers="construct posix"><tt>\p{XDigit}</tt></td>
 *     <td headers="matches">A hexadecimal digit: <tt>[0-9a-fA-F]</tt></td></tr>
 * <tr><td valign="top" headers="construct posix"><tt>\p{Space}</tt></td>
 *     <td headers="matches">A whitespace character: <tt>[ \t\n\x0B\f\r]</tt></td></tr>
 *
 * <tr><th>&nbsp;</th></tr>
 * <tr align="left"><th colspan="2">java.lang.Character classes (simple <a href="#jcc">java character type</a>)</th></tr>
 *
 * <tr><td valign="top"><tt>\p{javaLowerCase}</tt></td>
 *     <td>Equivalent to java.lang.Character.isLowerCase()</td></tr>
 * <tr><td valign="top"><tt>\p{javaUpperCase}</tt></td>
 *     <td>Equivalent to java.lang.Character.isUpperCase()</td></tr>
 * <tr><td valign="top"><tt>\p{javaWhitespace}</tt></td>
 *     <td>Equivalent to java.lang.Character.isWhitespace()</td></tr>
 * <tr><td valign="top"><tt>\p{javaMirrored}</tt></td>
 *     <td>Equivalent to java.lang.Character.isMirrored()</td></tr>
 *
 * <tr><th>&nbsp;</th></tr>
 * <tr align="left"><th colspan="2" id="unicode">Classes for Unicode blocks and categories</th></tr>
 *
 * <tr><td valign="top" headers="construct unicode"><tt>\p{InGreek}</tt></td>
 *     <td headers="matches">A character in the Greek&nbsp;block (simple <a href="#ubc">block</a>)</td></tr>
 * <tr><td valign="top" headers="construct unicode"><tt>\p{Lu}</tt></td>
 *     <td headers="matches">An uppercase letter (simple <a href="#ubc">category</a>)</td></tr>
 * <tr><td valign="top" headers="construct unicode"><tt>\p{Sc}</tt></td>
 *     <td headers="matches">A currency symbol</td></tr>
 * <tr><td valign="top" headers="construct unicode"><tt>\P{InGreek}</tt></td>
 *     <td headers="matches">Any character except one in the Greek block (negation)</td></tr>
 * <tr><td valign="top" headers="construct unicode"><tt>[\p{L}&&[^\p{Lu}]]&nbsp;</tt></td>
 *     <td headers="matches">Any letter except an uppercase letter (subtraction)</td></tr>
 *
 * <tr><th>&nbsp;</th></tr>
 * <tr align="left"><th colspan="2" id="bounds">Boundary matchers</th></tr>
 *
 * <tr><td valign="top" headers="construct bounds"><tt>^</tt></td>
 *     <td headers="matches">The beginning of a line</td></tr>
 * <tr><td valign="top" headers="construct bounds"><tt>$</tt></td>
 *     <td headers="matches">The end of a line</td></tr>
 * <tr><td valign="top" headers="construct bounds"><tt>\b</tt></td>
 *     <td headers="matches">A word boundary</td></tr>
 * <tr><td valign="top" headers="construct bounds"><tt>\B</tt></td>
 *     <td headers="matches">A non-word boundary</td></tr>
 * <tr><td valign="top" headers="construct bounds"><tt>\A</tt></td>
 *     <td headers="matches">The beginning of the input</td></tr>
 * <tr><td valign="top" headers="construct bounds"><tt>\G</tt></td>
 *     <td headers="matches">The end of the previous match</td></tr>
 * <tr><td valign="top" headers="construct bounds"><tt>\Z</tt></td>
 *     <td headers="matches">The end of the input but for the final
 *         <a href="#lt">terminator</a>, if&nbsp;any</td></tr>
 * <tr><td valign="top" headers="construct bounds"><tt>\z</tt></td>
 *     <td headers="matches">The end of the input</td></tr>
 *
 * <tr><th>&nbsp;</th></tr>
 * <tr align="left"><th colspan="2" id="greedy">Greedy quantifiers</th></tr>
 *
 * <tr><td valign="top" headers="construct greedy"><i>X</i><tt>?</tt></td>
 *     <td headers="matches"><i>X</i>, once or not at all</td></tr>
 * <tr><td valign="top" headers="construct greedy"><i>X</i><tt>*</tt></td>
 *     <td headers="matches"><i>X</i>, zero or more times</td></tr>
 * <tr><td valign="top" headers="construct greedy"><i>X</i><tt>+</tt></td>
 *     <td headers="matches"><i>X</i>, one or more times</td></tr>
 * <tr><td valign="top" headers="construct greedy"><i>X</i><tt>{</tt><i>n</i><tt>}</tt></td>
 *     <td headers="matches"><i>X</i>, exactly <i>n</i> times</td></tr>
 * <tr><td valign="top" headers="construct greedy"><i>X</i><tt>{</tt><i>n</i><tt>,}</tt></td>
 *     <td headers="matches"><i>X</i>, at least <i>n</i> times</td></tr>
 * <tr><td valign="top" headers="construct greedy"><i>X</i><tt>{</tt><i>n</i><tt>,</tt><i>m</i><tt>}</tt></td>
 *     <td headers="matches"><i>X</i>, at least <i>n</i> but not more than <i>m</i> times</td></tr>
 *
 * <tr><th>&nbsp;</th></tr>
 * <tr align="left"><th colspan="2" id="reluc">Reluctant quantifiers</th></tr>
 *
 * <tr><td valign="top" headers="construct reluc"><i>X</i><tt>??</tt></td>
 *     <td headers="matches"><i>X</i>, once or not at all</td></tr>
 * <tr><td valign="top" headers="construct reluc"><i>X</i><tt>*?</tt></td>
 *     <td headers="matches"><i>X</i>, zero or more times</td></tr>
 * <tr><td valign="top" headers="construct reluc"><i>X</i><tt>+?</tt></td>
 *     <td headers="matches"><i>X</i>, one or more times</td></tr>
 * <tr><td valign="top" headers="construct reluc"><i>X</i><tt>{</tt><i>n</i><tt>}?</tt></td>
 *     <td headers="matches"><i>X</i>, exactly <i>n</i> times</td></tr>
 * <tr><td valign="top" headers="construct reluc"><i>X</i><tt>{</tt><i>n</i><tt>,}?</tt></td>
 *     <td headers="matches"><i>X</i>, at least <i>n</i> times</td></tr>
 * <tr><td valign="top" headers="construct reluc"><i>X</i><tt>{</tt><i>n</i><tt>,</tt><i>m</i><tt>}?</tt></td>
 *     <td headers="matches"><i>X</i>, at least <i>n</i> but not more than <i>m</i> times</td></tr>
 *
 * <tr><th>&nbsp;</th></tr>
 * <tr align="left"><th colspan="2" id="poss">Possessive quantifiers</th></tr>
 *
 * <tr><td valign="top" headers="construct poss"><i>X</i><tt>?+</tt></td>
 *     <td headers="matches"><i>X</i>, once or not at all</td></tr>
 * <tr><td valign="top" headers="construct poss"><i>X</i><tt>*+</tt></td>
 *     <td headers="matches"><i>X</i>, zero or more times</td></tr>
 * <tr><td valign="top" headers="construct poss"><i>X</i><tt>++</tt></td>
 *     <td headers="matches"><i>X</i>, one or more times</td></tr>
 * <tr><td valign="top" headers="construct poss"><i>X</i><tt>{</tt><i>n</i><tt>}+</tt></td>
 *     <td headers="matches"><i>X</i>, exactly <i>n</i> times</td></tr>
 * <tr><td valign="top" headers="construct poss"><i>X</i><tt>{</tt><i>n</i><tt>,}+</tt></td>
 *     <td headers="matches"><i>X</i>, at least <i>n</i> times</td></tr>
 * <tr><td valign="top" headers="construct poss"><i>X</i><tt>{</tt><i>n</i><tt>,</tt><i>m</i><tt>}+</tt></td>
 *     <td headers="matches"><i>X</i>, at least <i>n</i> but not more than <i>m</i> times</td></tr>
 *
 * <tr><th>&nbsp;</th></tr>
 * <tr align="left"><th colspan="2" id="logical">Logical operators</th></tr>
 *
 * <tr><td valign="top" headers="construct logical"><i>XY</i></td>
 *     <td headers="matches"><i>X</i> followed by <i>Y</i></td></tr>
 * <tr><td valign="top" headers="construct logical"><i>X</i><tt>|</tt><i>Y</i></td>
 *     <td headers="matches">Either <i>X</i> or <i>Y</i></td></tr>
 * <tr><td valign="top" headers="construct logical"><tt>(</tt><i>X</i><tt>)</tt></td>
 *     <td headers="matches">X, as a <a href="#cg">capturing group</a></td></tr>
 *
 * <tr><th>&nbsp;</th></tr>
 * <tr align="left"><th colspan="2" id="backref">Back references</th></tr>
 *
 * <tr><td valign="bottom" headers="construct backref"><tt>\</tt><i>n</i></td>
 *     <td valign="bottom" headers="matches">Whatever the <i>n</i><sup>th</sup>
 *     <a href="#cg">capturing group</a> matched</td></tr>
 *
 * <tr><th>&nbsp;</th></tr>
 * <tr align="left"><th colspan="2" id="quot">Quotation</th></tr>
 *
 * <tr><td valign="top" headers="construct quot"><tt>\</tt></td>
 *     <td headers="matches">Nothing, but quotes the following character</td></tr>
 * <tr><td valign="top" headers="construct quot"><tt>\Q</tt></td>
 *     <td headers="matches">Nothing, but quotes all characters until <tt>\E</tt></td></tr>
 * <tr><td valign="top" headers="construct quot"><tt>\E</tt></td>
 *     <td headers="matches">Nothing, but ends quoting started by <tt>\Q</tt></td></tr>
 *     <!-- Metachars: !$()*+.<>?[\]^{|} -->
 *
 * <tr><th>&nbsp;</th></tr>
 * <tr align="left"><th colspan="2" id="special">Special constructs (non-capturing)</th></tr>
 *
 * <tr><td valign="top" headers="construct special"><tt>(?:</tt><i>X</i><tt>)</tt></td>
 *     <td headers="matches"><i>X</i>, as a non-capturing group</td></tr>
 * <tr><td valign="top" headers="construct special"><tt>(?idmsux-idmsux)&nbsp;</tt></td>
 *     <td headers="matches">Nothing, but turns match flags <a href="#CASE_INSENSITIVE">i</a>
 * <a href="#UNIX_LINES">d</a> <a href="#MULTILINE">m</a> <a href="#DOTALL">s</a>
 * <a href="#UNICODE_CASE">u</a> <a href="#COMMENTS">x</a> on - off</td></tr>
 * <tr><td valign="top" headers="construct special"><tt>(?idmsux-idmsux:</tt><i>X</i><tt>)</tt>&nbsp;&nbsp;</td>
 *     <td headers="matches"><i>X</i>, as a <a href="#cg">non-capturing group</a> with the
 *         given flags <a href="#CASE_INSENSITIVE">i</a> <a href="#UNIX_LINES">d</a>
 * <a href="#MULTILINE">m</a> <a href="#DOTALL">s</a> <a href="#UNICODE_CASE">u</a >
 * <a href="#COMMENTS">x</a> on - off</td></tr>
 * <tr><td valign="top" headers="construct special"><tt>(?=</tt><i>X</i><tt>)</tt></td>
 *     <td headers="matches"><i>X</i>, via zero-width positive lookahead</td></tr>
 * <tr><td valign="top" headers="construct special"><tt>(?!</tt><i>X</i><tt>)</tt></td>
 *     <td headers="matches"><i>X</i>, via zero-width negative lookahead</td></tr>
 * <tr><td valign="top" headers="construct special"><tt>(?&lt;=</tt><i>X</i><tt>)</tt></td>
 *     <td headers="matches"><i>X</i>, via zero-width positive lookbehind</td></tr>
 * <tr><td valign="top" headers="construct special"><tt>(?&lt;!</tt><i>X</i><tt>)</tt></td>
 *     <td headers="matches"><i>X</i>, via zero-width negative lookbehind</td></tr>
 * <tr><td valign="top" headers="construct special"><tt>(?&gt;</tt><i>X</i><tt>)</tt></td>
 *     <td headers="matches"><i>X</i>, as an independent, non-capturing group</td></tr>
 *
 * </table>
 *
 * <hr>
 *
 *
 * <a name="bs">
 * <h4> Backslashes, escapes, and quoting </h4>
 *
 * <p> The backslash character (<tt>'\'</tt>) serves to introduce escaped
 * constructs, as defined in the table above, as well as to quote characters
 * that otherwise would be interpreted as unescaped constructs.  Thus the
 * expression <tt>\\</tt> matches a single backslash and <tt>\{</tt> matches a
 * left brace.
 *
 * <p> It is an error to use a backslash prior to any alphabetic character that
 * does not denote an escaped construct; these are reserved for future
 * extensions to the regular-expression language.  A backslash may be used
 * prior to a non-alphabetic character regardless of whether that character is
 * part of an unescaped construct.
 *
 * <p> Backslashes within string literals in Java source code are interpreted
 * as required by the <a
 * href="http://java.sun.com/docs/books/jls">Java Language
 * Specification</a> as either <a
 * href="http://java.sun.com/docs/books/jls/third_edition/html/lexical.html#100850">Unicode
 * escapes</a> or other <a
 * href="http://java.sun.com/docs/books/jls/third_edition/html/lexical.html#101089">character
 * escapes</a>.  It is therefore necessary to double backslashes in string
 * literals that represent regular expressions to protect them from
 * interpretation by the Java bytecode compiler.  The string literal
 * <tt>"&#92;b"</tt>, for example, matches a single backspace character when
 * interpreted as a regular expression, while <tt>"&#92;&#92;b"</tt> matches a
 * word boundary.  The string literal <tt>"&#92;(hello&#92;)"</tt> is illegal
 * and leads to a compile-time error; in order to match the string
 * <tt>(hello)</tt> the string literal <tt>"&#92;&#92;(hello&#92;&#92;)"</tt>
 * must be used.
 *
 * <a name="cc">
 * <h4> Character Classes </h4>
 *
 *    <p> Character classes may appear within other character classes, and
 *    may be composed by the union operator (implicit) and the intersection
 *    operator (<tt>&amp;&amp;</tt>).
 *    The union operator denotes a class that contains every character that is
 *    in at least one of its operand classes.  The intersection operator
 *    denotes a class that contains every character that is in both of its
 *    operand classes.
 *
 *    <p> The precedence of character-class operators is as follows, from
 *    highest to lowest:
 *
 *    <blockquote><table border="0" cellpadding="1" cellspacing="0"
 *                 summary="Precedence of character class operators.">
 *      <tr><th>1&nbsp;&nbsp;&nbsp;&nbsp;</th>
 *	  <td>Literal escape&nbsp;&nbsp;&nbsp;&nbsp;</td>
 *	  <td><tt>\x</tt></td></tr>
 *     <tr><th>2&nbsp;&nbsp;&nbsp;&nbsp;</th>
 *	  <td>Grouping</td>
 *	  <td><tt>[...]</tt></td></tr>
 *     <tr><th>3&nbsp;&nbsp;&nbsp;&nbsp;</th>
 *	  <td>Range</td>
 *	  <td><tt>a-z</tt></td></tr>
 *      <tr><th>4&nbsp;&nbsp;&nbsp;&nbsp;</th>
 *	  <td>Union</td>
 *	  <td><tt>[a-e][i-u]</tt></td></tr>
 *      <tr><th>5&nbsp;&nbsp;&nbsp;&nbsp;</th>
 *	  <td>Intersection</td>
 *	  <td><tt>[a-z&&[aeiou]]</tt></td></tr>
 *    </table></blockquote>
 *
 *    <p> Note that a different set of metacharacters are in effect inside
 *    a character class than outside a character class. For instance, the
 *    regular expression <tt>.</tt> loses its special meaning inside a
 *    character class, while the expression <tt>-</tt> becomes a range
 *    forming metacharacter.
 *
 * <a name="lt">
 * <h4> Line terminators </h4>
 *
 * <p> A <i>line terminator</i> is a one- or two-character sequence that marks
 * the end of a line of the input character sequence.  The following are
 * recognized as line terminators:
 *
 * <ul>
 *
 *   <li> A newline (line feed) character&nbsp;(<tt>'\n'</tt>),
 *
 *   <li> A carriage-return character followed immediately by a newline
 *   character&nbsp;(<tt>"\r\n"</tt>),
 *
 *   <li> A standalone carriage-return character&nbsp;(<tt>'\r'</tt>),
 *
 *   <li> A next-line character&nbsp;(<tt>'&#92;u0085'</tt>),
 *
 *   <li> A line-separator character&nbsp;(<tt>'&#92;u2028'</tt>), or
 *
 *   <li> A paragraph-separator character&nbsp;(<tt>'&#92;u2029</tt>).
 *
 * </ul>
 * <p>If {@link #UNIX_LINES} mode is activated, then the only line terminators
 * recognized are newline characters.
 *
 * <p> The regular expression <tt>.</tt> matches any character except a line
 * terminator unless the {@link #DOTALL} flag is specified.
 *
 * <p> By default, the regular expressions <tt>^</tt> and <tt>$</tt> ignore
 * line terminators and only match at the beginning and the end, respectively,
 * of the entire input sequence. If {@link #MULTILINE} mode is activated then
 * <tt>^</tt> matches at the beginning of input and after any line terminator
 * except at the end of input. When in {@link #MULTILINE} mode <tt>$</tt>
 * matches just before a line terminator or the end of the input sequence.
 *
 * <a name="cg">
 * <h4> Groups and capturing </h4>
 *
 * <p> Capturing groups are numbered by counting their opening parentheses from
 * left to right.  In the expression <tt>((A)(B(C)))</tt>, for example, there
 * are four such groups: </p>
 *
 * <blockquote><table cellpadding=1 cellspacing=0 summary="Capturing group numberings">
 * <tr><th>1&nbsp;&nbsp;&nbsp;&nbsp;</th>
 *     <td><tt>((A)(B(C)))</tt></td></tr>
 * <tr><th>2&nbsp;&nbsp;&nbsp;&nbsp;</th>
 *     <td><tt>(A)</tt></td></tr>
 * <tr><th>3&nbsp;&nbsp;&nbsp;&nbsp;</th>
 *     <td><tt>(B(C))</tt></td></tr>
 * <tr><th>4&nbsp;&nbsp;&nbsp;&nbsp;</th>
 *     <td><tt>(C)</tt></td></tr>
 * </table></blockquote>
 *
 * <p> Group zero always stands for the entire expression.
 *
 * <p> Capturing groups are so named because, during a match, each subsequence
 * of the input sequence that matches such a group is saved.  The captured
 * subsequence may be used later in the expression, via a back reference, and
 * may also be retrieved from the matcher once the match operation is complete.
 *
 * <p> The captured input associated with a group is always the subsequence
 * that the group most recently matched.  If a group is evaluated a second time
 * because of quantification then its previously-captured value, if any, will
 * be retained if the second evaluation fails.  Matching the string
 * <tt>"aba"</tt> against the expression <tt>(a(b)?)+</tt>, for example, leaves
 * group two set to <tt>"b"</tt>.  All captured input is discarded at the
 * beginning of each match.
 *
 * <p> Groups beginning with <tt>(?</tt> are pure, <i>non-capturing</i> groups
 * that do not capture text and do not count towards the group total.
 *
 *
 * <h4> Unicode support </h4>
 *
 * <p> This class is in conformance with Level 1 of <a
 * href="http://www.unicode.org/reports/tr18/"><i>Unicode Technical
 * Standard #18: Unicode Regular Expression Guidelines</i></a>, plus RL2.1
 * Canonical Equivalents.
 *
 * <p> Unicode escape sequences such as <tt>&#92;u2014</tt> in Java source code
 * are processed as described in <a
 * href="http://java.sun.com/docs/books/jls/third_edition/html/lexical.html#100850">\u00A73.3</a>
 * of the Java Language Specification.  Such escape sequences are also
 * implemented directly by the regular-expression parser so that Unicode
 * escapes can be used in expressions that are read from files or from the
 * keyboard.  Thus the strings <tt>"&#92;u2014"</tt> and <tt>"\\u2014"</tt>,
 * while not equal, compile into the same pattern, which matches the character
 * with hexadecimal value <tt>0x2014</tt>.
 *
 * <a name="ubc"> <p>Unicode blocks and categories are written with the
 * <tt>\p</tt> and <tt>\P</tt> constructs as in
 * Perl. <tt>\p{</tt><i>prop</i><tt>}</tt> matches if the input has the
 * property <i>prop</i>, while <tt>\P{</tt><i>prop</i><tt>}</tt> does not match if
 * the input has that property.  Blocks are specified with the prefix
 * <tt>In</tt>, as in <tt>InMongolian</tt>.  Categories may be specified with
 * the optional prefix <tt>Is</tt>: Both <tt>\p{L}</tt> and <tt>\p{IsL}</tt>
 * denote the category of Unicode letters.  Blocks and categories can be used
 * both inside and outside of a character class.
 *
 * <p> The supported categories are those of
 * <a href="http://www.unicode.org/unicode/standard/standard.html">
 * <i>The Unicode Standard</i></a> in the version specified by the
 * {@link java.lang.Character Character} class. The category names are those
 * defined in the Standard, both normative and informative.
 * The block names supported by <code>Pattern</code> are the valid block names
 * accepted and defined by
 * {@link java.lang.Character.UnicodeBlock#forName(String) UnicodeBlock.forName}.
 *
 * <a name="jcc"> <p>Categories that behave like the java.lang.Character
 * boolean is<i>methodname</i> methods (except for the deprecated ones) are
 * available through the same <tt>\p{</tt><i>prop</i><tt>}</tt> syntax where
 * the specified property has the name <tt>java<i>methodname</i></tt>.
 *
 * <h4> Comparison to Perl 5 </h4>
 *
 * <p>The <code>Pattern</code> engine performs traditional NFA-based matching
 * with ordered alternation as occurs in Perl 5.
 *
 * <p> Perl constructs not supported by this class: </p>
 *
 * <ul>
 *
 *    <li><p> The conditional constructs <tt>(?{</tt><i>X</i><tt>})</tt> and
 *    <tt>(?(</tt><i>condition</i><tt>)</tt><i>X</i><tt>|</tt><i>Y</i><tt>)</tt>,
 *    </p></li>
 *
 *    <li><p> The embedded code constructs <tt>(?{</tt><i>code</i><tt>})</tt>
 *    and <tt>(??{</tt><i>code</i><tt>})</tt>,</p></li>
 *
 *    <li><p> The embedded comment syntax <tt>(?#comment)</tt>, and </p></li>
 *
 *    <li><p> The preprocessing operations <tt>\l</tt> <tt>&#92;u</tt>,
 *    <tt>\L</tt>, and <tt>\U</tt>.  </p></li>
 *
 * </ul>
 *
 * <p> Constructs supported by this class but not by Perl: </p>
 *
 * <ul>
 *
 *    <li><p> Possessive quantifiers, which greedily match as much as they can
 *    and do not back off, even when doing so would allow the overall match to
 *    succeed.  </p></li>
 *
 *    <li><p> Character-class union and intersection as described
 *    <a href="#cc">above</a>.</p></li>
 *
 * </ul>
 *
 * <p> Notable differences from Perl: </p>
 *
 * <ul>
 *
 *    <li><p> In Perl, <tt>\1</tt> through <tt>\9</tt> are always interpreted
 *    as back references; a backslash-escaped number greater than <tt>9</tt> is
 *    treated as a back reference if at least that many subexpressions exist,
 *    otherwise it is interpreted, if possible, as an octal escape.  In this
 *    class octal escapes must always begin with a zero. In this class,
 *    <tt>\1</tt> through <tt>\9</tt> are always interpreted as back
 *    references, and a larger number is accepted as a back reference if at
 *    least that many subexpressions exist at that point in the regular
 *    expression, otherwise the parser will drop digits until the number is
 *    smaller or equal to the existing number of groups or it is one digit.
 *    </p></li>
 *
 *    <li><p> Perl uses the <tt>g</tt> flag to request a match that resumes
 *    where the last match left off.  This functionality is provided implicitly
 *    by the {@link Matcher} class: Repeated invocations of the {@link
 *    Matcher#find find} method will resume where the last match left off,
 *    unless the matcher is reset.  </p></li>
 *
 *    <li><p> In Perl, embedded flags at the top level of an expression affect
 *    the whole expression.  In this class, embedded flags always take effect
 *    at the point at which they appear, whether they are at the top level or
 *    within a group; in the latter case, flags are restored at the end of the
 *    group just as in Perl.  </p></li>
 *
 *    <li><p> Perl is forgiving about malformed matching constructs, as in the
 *    expression <tt>*a</tt>, as well as dangling brackets, as in the
 *    expression <tt>abc]</tt>, and treats them as literals.  This
 *    class also accepts dangling brackets but is strict about dangling
 *    metacharacters like +, ? and *, and will throw a
 *    {@link PatternSyntaxException} if it encounters them. </p></li>
 *
 * </ul>
 *
 *
 * <p> For a more precise description of the behavior of regular expression
 * constructs, please see <a href="http://www.oreilly.com/catalog/regex3/">
 * <i>Mastering Regular Expressions, 3nd Edition</i>, Jeffrey E. F. Friedl,
 * O'Reilly and Associates, 2006.</a>
 * </p>
 *
 * @see java.lang.String#split(String, int)
 * @see java.lang.String#split(String)
 *
 * @author      Mike McCloskey
 * @author      Mark Reinhold
 * @author	JSR-51 Expert Group
 * @version 	%I%, %E%
 * @since       1.4
 * @spec	JSR-51
 */

public final class X
    implements X.X.X
{

    /**
     * Regular expression modifier values.  Instead of being passed as
     * arguments, they can also be passed as inline modifiers.
     * For example, the following statements have the same effect.
     * <pre>
     * RegExp r1 = RegExp.compile("abc", Pattern.I|Pattern.M);
     * RegExp r2 = RegExp.compile("(?im)abc", 0);
     * </pre>
     *
     * The flags are duplicated so that the familiar Perl match flag
     * names are available.
     */

    /**
     * Enables Unix lines mode.
     *
     * <p> In this mode, only the <tt>'\n'</tt> line terminator is recognized
     * in the behavior of <tt>.</tt>, <tt>^</tt>, and <tt>$</tt>.
     *
     * <p> Unix lines mode can also be enabled via the embedded flag
     * expression&nbsp;<tt>(?d)</tt>.
     */
    public static final X X = 0;

    /**
     * Enables case-insensitive matching.
     *
     * <p> By default, case-insensitive matching assumes that only characters
     * in the US-ASCII charset are being matched.  Unicode-aware
     * case-insensitive matching can be enabled by specifying the {@link
     * #UNICODE_CASE} flag in conjunction with this flag.
     *
     * <p> Case-insensitive matching can also be enabled via the embedded flag
     * expression&nbsp;<tt>(?i)</tt>.
     *
     * <p> Specifying this flag may impose a slight performance penalty.  </p>
     */
    public static final X X = 0;

    /**
     * Permits whitespace and comments in pattern.
     *
     * <p> In this mode, whitespace is ignored, and embedded comments starting
     * with <tt>#</tt> are ignored until the end of a line.
     *
     * <p> Comments mode can also be enabled via the embedded flag
     * expression&nbsp;<tt>(?x)</tt>.
     */
    public static final X X = 0;

    /**
     * Enables multiline mode.
     *
     * <p> In multiline mode the expressions <tt>^</tt> and <tt>$</tt> match
     * just after or just before, respectively, a line terminator or the end of
     * the input sequence.  By default these expressions only match at the
     * beginning and the end of the entire input sequence.
     *
     * <p> Multiline mode can also be enabled via the embedded flag
     * expression&nbsp;<tt>(?m)</tt>.  </p>
     */
    public static final X X = 0;

    /**
     * Enables literal parsing of the pattern.
     *
     * <p> When this flag is specified then the input string that specifies
     * the pattern is treated as a sequence of literal characters.
     * Metacharacters or escape sequences in the input sequence will be
     * given no special meaning.
     *
     * <p>The flags CASE_INSENSITIVE and UNICODE_CASE retain their impact on
     * matching when used in conjunction with this flag. The other flags
     * become superfluous.
     *
     * <p> There is no embedded flag character for enabling literal parsing.
     * @since 1.5
     */
    public static final X X = 0;

    /**
     * Enables dotall mode.
     *
     * <p> In dotall mode, the expression <tt>.</tt> matches any character,
     * including a line terminator.  By default this expression does not match
     * line terminators.
     *
     * <p> Dotall mode can also be enabled via the embedded flag
     * expression&nbsp;<tt>(?s)</tt>.  (The <tt>s</tt> is a mnemonic for
     * "single-line" mode, which is what this is called in Perl.)  </p>
     */
    public static final X X = 0;

    /**
     * Enables Unicode-aware case folding.
     *
     * <p> When this flag is specified then case-insensitive matching, when
     * enabled by the {@link #CASE_INSENSITIVE} flag, is done in a manner
     * consistent with the Unicode Standard.  By default, case-insensitive
     * matching assumes that only characters in the US-ASCII charset are being
     * matched.
     *
     * <p> Unicode-aware case folding can also be enabled via the embedded flag
     * expression&nbsp;<tt>(?u)</tt>.
     *
     * <p> Specifying this flag may impose a performance penalty.  </p>
     */
    public static final X X = 0;

    /**
     * Enables canonical equivalence.
     *
     * <p> When this flag is specified then two characters will be considered
     * to match if, and only if, their full canonical decompositions match.
     * The expression <tt>"a&#92;u030A"</tt>, for example, will match the
     * string <tt>"&#92;u00E5"</tt> when this flag is specified.  By default,
     * matching does not take canonical equivalence into account.
     *
     * <p> There is no embedded flag character for enabling canonical
     * equivalence.
     *
     * <p> Specifying this flag may impose a performance penalty.  </p>
     */
    public static final X X = 0;

    /* Pattern has only two serialized components: The pattern string
     * and the flags, which are all that is needed to recompile the pattern
     * when it is deserialized.
     */

    /** use serialVersionUID from Merlin b59 for interoperability */
    private static final X X = 0;

    /**
     * The original regular-expression pattern string.
     *
     * @serial
     */
    private X X;

    /**
     * The original pattern flags.
     *
     * @serial
     */
    private X X;

    /**
     * Boolean indicating this Pattern is compiled; this is necessary in order
     * to lazily compile deserialized Patterns.
     */
    private transient volatile X X = 0;

    /**
     * The normalized pattern string.
     */
    private transient X X;

    /**
     * The starting point of state machine for the find operation.  This allows
     * a match to start anywhere in the input.
     */
    transient X X;

    /**
     * The root of object tree for a match operation.  The pattern is matched
     * at the beginning.  This may include a find that uses BnM or a First
     * node.
     */
    transient X X;

    /**
     * Temporary storage used by parsing pattern slice.
     */
    transient X[] X;

    /**
     * Temporary storage used while parsing group references.
     */
    transient X[] X;

    /**
     * Temporary null terminated code point array used by pattern compiling.
     */
    private transient X[] X;

    /**
     * The number of capturing groups in this Pattern. Used by matchers to
     * allocate storage needed to perform a match.
     */
    transient X X;

    /**
     * The local variable count used by parsing tree. Used by matchers to
     * allocate storage needed to perform a match.
     */
    transient X X;

    /**
     * Index into the pattern string that keeps track of how much has been
     * parsed.
     */
    private transient X X;

    /**
     * Holds the length of the pattern string.
     */
    private transient X X;

    /**
     * Compiles the given regular expression into a pattern.  </p>
     *
     * @param  regex
     *         The expression to be compiled
     *
     * @throws  PatternSyntaxException
     *          If the expression's syntax is invalid
     */
    public static X X(X X)
    {
        return new X(X, 0);
    }

    /**
     * Compiles the given regular expression into a pattern with the given
     * flags.  </p>
     *
     * @param  regex
     *         The expression to be compiled
     *
     * @param  flags
     *         Match flags, a bit mask that may include
     *         {@link #CASE_INSENSITIVE}, {@link #MULTILINE}, {@link #DOTALL},
     *         {@link #UNICODE_CASE}, {@link #CANON_EQ}, {@link #UNIX_LINES},
     *         {@link #LITERAL} and {@link #COMMENTS}
     *
     * @throws  IllegalArgumentException
     *          If bit values other than those corresponding to the defined
     *          match flags are set in <tt>flags</tt>
     *
     * @throws  PatternSyntaxException
     *          If the expression's syntax is invalid
     */
    public static X X(X X, X X)
    {
        return new X(X, X);
    }

    /**
     * Returns the regular expression from which this pattern was compiled.
     * </p>
     *
     * @return  The source of this pattern
     */
    public X X()
    {
        return X;
    }

    /**
     * <p>Returns the string representation of this pattern. This
     * is the regular expression from which this pattern was
     * compiled.</p>
     *
     * @return  The string representation of this pattern
     * @since 1.5
     */
    public X X()
    {
        return X;
    }

    /**
     * Creates a matcher that will match the given input against this pattern.
     * </p>
     *
     * @param  input
     *         The character sequence to be matched
     *
     * @return  A new matcher for this pattern
     */
    public X X(X X)
    {
        if (!X)
        {
            synchronized(X)
            {
                if (!X)
                    X();
            }
        }
        X X = new X(X, X);
        return X;
    }

    /**
     * Returns this pattern's match flags.  </p>
     *
     * @return  The match flags specified when this pattern was compiled
     */
    public X X()
    {
        return X;
    }

    /**
     * Compiles the given regular expression and attempts to match the given
     * input against it.
     *
     * <p> An invocation of this convenience method of the form
     *
     * <blockquote><pre>
     * Pattern.matches(regex, input);</pre></blockquote>
     *
     * behaves in exactly the same way as the expression
     *
     * <blockquote><pre>
     * Pattern.compile(regex).matcher(input).matches()</pre></blockquote>
     *
     * <p> If a pattern is to be used multiple times, compiling it once and reusing
     * it will be more efficient than invoking this method each time.  </p>
     *
     * @param  regex
     *         The expression to be compiled
     *
     * @param  input
     *         The character sequence to be matched
     *
     * @throws  PatternSyntaxException
     *          If the expression's syntax is invalid
     */
    public static X X(X X, X X)
    {
        X X = X.X(X);
        X X = X.X(X);
        return X.X();
    }

    /**
     * Splits the given input sequence around matches of this pattern.
     *
     * <p> The array returned by this method contains each substring of the
     * input sequence that is terminated by another subsequence that matches
     * this pattern or is terminated by the end of the input sequence.  The
     * substrings in the array are in the order in which they occur in the
     * input.  If this pattern does not match any subsequence of the input then
     * the resulting array has just one element, namely the input sequence in
     * string form.
     *
     * <p> The <tt>limit</tt> parameter controls the number of times the
     * pattern is applied and therefore affects the length of the resulting
     * array.  If the limit <i>n</i> is greater than zero then the pattern
     * will be applied at most <i>n</i>&nbsp;-&nbsp;1 times, the array's
     * length will be no greater than <i>n</i>, and the array's last entry
     * will contain all input beyond the last matched delimiter.  If <i>n</i>
     * is non-positive then the pattern will be applied as many times as
     * possible and the array can have any length.  If <i>n</i> is zero then
     * the pattern will be applied as many times as possible, the array can
     * have any length, and trailing empty strings will be discarded.
     *
     * <p> The input <tt>"boo:and:foo"</tt>, for example, yields the following
     * results with these parameters:
     *
     * <blockquote><table cellpadding=1 cellspacing=0
     *              summary="Split examples showing regex, limit, and result">
     * <tr><th><P align="left"><i>Regex&nbsp;&nbsp;&nbsp;&nbsp;</i></th>
     *     <th><P align="left"><i>Limit&nbsp;&nbsp;&nbsp;&nbsp;</i></th>
     *     <th><P align="left"><i>Result&nbsp;&nbsp;&nbsp;&nbsp;</i></th></tr>
     * <tr><td align=center>:</td>
     *     <td align=center>2</td>
     *     <td><tt>{ "boo", "and:foo" }</tt></td></tr>
     * <tr><td align=center>:</td>
     *     <td align=center>5</td>
     *     <td><tt>{ "boo", "and", "foo" }</tt></td></tr>
     * <tr><td align=center>:</td>
     *     <td align=center>-2</td>
     *     <td><tt>{ "boo", "and", "foo" }</tt></td></tr>
     * <tr><td align=center>o</td>
     *     <td align=center>5</td>
     *     <td><tt>{ "b", "", ":and:f", "", "" }</tt></td></tr>
     * <tr><td align=center>o</td>
     *     <td align=center>-2</td>
     *     <td><tt>{ "b", "", ":and:f", "", "" }</tt></td></tr>
     * <tr><td align=center>o</td>
     *     <td align=center>0</td>
     *     <td><tt>{ "b", "", ":and:f" }</tt></td></tr>
     * </table></blockquote>
     *
     *
     * @param  input
     *         The character sequence to be split
     *
     * @param  limit
     *         The result threshold, as described above
     *
     * @return  The array of strings computed by splitting the input
     *          around matches of this pattern
     */
    public X[] X(X X, X X)
    {
        X X = 0;
        X X = X > 0;
        X<X> X = new X<X>();
        X X = X(X);

        // Add segments before each match found
        while(X.X())
        {
            if (!X || X.X() < X - 0)
            {
                X X = X.X(X, X.X()).X();
                X.X(X);
                X = X.X();
            }
            else if (X.X() == X - 0)     // last one
            {
                X X = X.X(X,
                                                 X.X()).X();
                X.X(X);
                X = X.X();
            }
        }

        // If no match was found, return this
        if (X == 0)
            return new X[] {X.X()};

        // Add remaining segment
        if (!X || X.X() < X)
            X.X(X.X(X, X.X()).X());

        // Construct result
        X X = X.X();
        if (X == 0)
            while (X > 0 && X.X(X-0).X(0))
                X--;
        X[] X = new X[X];
        return X.X(0, X).X(X);
    }

    /**
     * Splits the given input sequence around matches of this pattern.
     *
     * <p> This method works as if by invoking the two-argument {@link
     * #split(java.lang.CharSequence, int) split} method with the given input
     * sequence and a limit argument of zero.  Trailing empty strings are
     * therefore not included in the resulting array. </p>
     *
     * <p> The input <tt>"boo:and:foo"</tt>, for example, yields the following
     * results with these expressions:
     *
     * <blockquote><table cellpadding=1 cellspacing=0
     *              summary="Split examples showing regex and result">
     * <tr><th><P align="left"><i>Regex&nbsp;&nbsp;&nbsp;&nbsp;</i></th>
     *     <th><P align="left"><i>Result</i></th></tr>
     * <tr><td align=center>:</td>
     *     <td><tt>{ "boo", "and", "foo" }</tt></td></tr>
     * <tr><td align=center>o</td>
     *     <td><tt>{ "b", "", ":and:f" }</tt></td></tr>
     * </table></blockquote>
     *
     *
     * @param  input
     *         The character sequence to be split
     *
     * @return  The array of strings computed by splitting the input
     *          around matches of this pattern
     */
    public X[] X(X X)
    {
        return X(X, 0);
    }

    /**
     * Returns a literal pattern <code>String</code> for the specified
     * <code>String</code>.
     *
     * <p>This method produces a <code>String</code> that can be used to
     * create a <code>Pattern</code> that would match the string
     * <code>s</code> as if it were a literal pattern.</p> Metacharacters
     * or escape sequences in the input sequence will be given no special
     * meaning.
     *
     * @param  s The string to be literalized
     * @return  A literal string replacement
     * @since 1.5
     */
    public static X X(X X)
    {
        X X = X.X(0);
        if (X == -0)
            return 0 + X + 0;

        X X = new X(X.X() * 0);
        X.X(0);
        X = 0;
        X X = 0;
        while ((X = X.X(0, X)) != -0)
        {
            X.X(X.X(X, X));
            X = X + 0;
            X.X(0);
        }
        X.X(X.X(X, X.X()));
        X.X(0);
        return X.X();
    }

    /**
     * Recompile the Pattern instance from a stream.  The original pattern
     * string is read in and the object tree is recompiled from it.
     */
    private X X(X.X.X X)
    throws X.X.X, X
    {

        // Read in all fields
        X.X();

        // Initialize counts
        X = 0;
        X = 0;

        // if length > 0, the Pattern is lazily compiled
        X = 0;
        if (X.X() == 0)
        {
            X = new X(X);
            X = X;
            X = 0;
        }
    }

    /**
     * This private constructor is used to create all Patterns. The pattern
     * string and match flags are all that is needed to completely describe
     * a Pattern. An empty pattern string results in an object tree with
     * only a Start node and a LastNode node.
     */
    private X(X X, X X)
    {
        X = X;
        X = X;

        // Reset group index count
        X = 0;
        X = 0;

        if (X.X() > 0)
        {
            X();
        }
        else
        {
            X = new X(X);
            X = X;
        }
    }

    /**
     * The pattern is converted to normalizedD form and then a pure group
     * is constructed to match canonical equivalences of the characters.
     */
    private X X()
    {
        X X = 0;
        X X = -0;

        // Convert pattern into normalizedD form
        X = X.X(X, X.X.X);
        X = X.X();

        // Modify pattern to match canonical equivalences
        X X = new X(X);
        for(X X=0; X<X; )
        {
            X X = X.X(X);
            X X;
            if ((X.X(X) == X.X)
                    && (X != -0))
            {
                X = new X();
                X.X(X);
                X.X(X);
                while(X.X(X) == X.X)
                {
                    X += X.X(X);
                    if (X >= X)
                        break;
                    X = X.X(X);
                    X.X(X);
                }
                X X = X(
                                X.X());
                X.X(X.X()-X.X(X));
                X.X(0).X(X).X(0);
            }
            else if (X == 0 && X != 0)
            {
                X = X(X, X);
            }
            else
            {
                X.X(X);
            }
            X = X;
            X += X.X(X);
        }
        X = X.X();
    }

    /**
     * Complete the character class being parsed and add a set
     * of alternations to it that will match the canonical equivalences
     * of the characters within the class.
     */
    private X X(X X, X X)
    {
        X X = new X();
        X X = 0;
        X X = -0;
        X X;

        X++;
        X.X(0);
        while(0)
        {
            X X = X.X(X);
            X X;

            if (X == 0 && X != 0)
            {
                X.X((X)X);
                break;
            }
            else if (X.X(X) == X.X)
            {
                X = new X();
                X.X(X);
                while(X.X(X) == X.X)
                {
                    X.X(X);
                    X += X.X(X);
                    if (X >= X.X())
                        break;
                    X = X.X(X);
                }
                X X = X(
                                X.X());

                X.X(X.X()-X.X(X));
                if (X == 0)
                    X = new X();
                X.X(0);
                X.X(X);
            }
            else
            {
                X.X(X);
                X++;
            }
            if (X == X.X())
                throw X(0);
            X = X;
        }

        if (X != 0)
        {
            X = 0+X.X()+X.X()+0;
        }
        else
        {
            X = X.X();
        }

        X.X(X);
        return X;
    }

    /**
     * Given a specific sequence composed of a regular character and
     * combining marks that follow it, produce the alternation that will
     * match all canonical equivalences of that sequence.
     */
    private X X(X X)
    {
        X X = X(X, 0, 0);
        if (X.X() == X)
            // source has one character.
            return X;

        X X = X.X(0,X);
        X X = X.X(X);

        X[] X = X(X);
        X X = new X(X);

        // Add combined permutations
        for(X X=0; X<X.X; X++)
        {
            X X = X + X[X];
            if (X>0)
                X.X(0+X);
            X = X(X);
            if (X != 0)
                X.X(0+X(X));
        }
        return X.X();
    }

    /**
     * Returns an array of strings that have all the possible
     * permutations of the characters in the input string.
     * This is used to get a list of all possible orderings
     * of a set of combining marks. Note that some of the permutations
     * are invalid because of combining class collisions, and these
     * possibilities must be removed because they are not canonically
     * equivalent.
     */
    private X[] X(X X)
    {
        if (X.X() == X(X, 0, 0))
            return new X[] {X};

        if (X.X() == X(X, 0, 0))
        {
            X X = X.X(X, 0);
            X X = X.X(X, X.X(X));
            if (X(X) == X(X))
            {
                return new X[] {X};
            }
            X[] X = new X[0];
            X[0] = X;
            X X = new X(0);
            X.X(X);
            X.X(X);
            X[0] = X.X();
            return X;
        }

        X X = 0;
        X X = X(X);
        for(X X=0; X<X; X++)
            X = X * (X+0);

        X[] X = new X[X];

        X X[] = new X[X];
        for(X X=0, X=0; X<X; X++)
        {
            X X = X.X(X, X);
            X[X] = X(X);
            X +=  X.X(X);
        }

        // For each char, take it out and add the permutations
        // of the remaining chars
        X X = 0;
        X X;
        // offset maintains the index in code units.
        X:   for(X X=0, X=0; X<X; X++, X+=X)
        {
            X = X(X, X, 0);
            X X = 0;
            for(X X=X-0; X>=0; X--)
            {
                if (X[X] == X[X])
                {
                    continue X;
                }
            }
            X X = new X(X);
            X X = X.X(X, X+X).X();
            X[] X = X(X);

            X X = X.X(X, X+X);
            for(X X=0; X<X.X; X++)
                X[X++] =  X + X[X];
        }
        X[] X = new X[X];
        for (X X=0; X<X; X++)
            X[X] = X[X];
        return X;
    }

    private X X(X X)
    {
        return X.X.X.X(X);
    }

    /**
     * Attempts to compose input by combining the first character
     * with the first combining mark following it. Returns a String
     * that is the composition of the leading character with its first
     * combining mark followed by the remaining combining marks. Returns
     * null if the first two characters cannot be further composed.
     */
    private X X(X X)
    {
        X X = X(X, 0, 0);
        X X = X.X(0, X);
        X X = X.X(X, X.X.X);

        if (X.X(X))
            return 0;
        else
        {
            X X = X.X(X);
            return X + X;
        }
    }

    /**
     * Preprocess any \Q...\E sequences in `temp', meta-quoting them.
     * See the description of `quotemeta' in perlfunc(1).
     */
    private X X()
    {
        final X X = X;
        X X = 0;
        while (X < X-0)
        {
            if (X[X] != 0)
                X += 0;
            else if (X[X + 0] != 0)
                X += 0;
            else
                break;
        }
        if (X >= X - 0)    // No \Q sequence found
            return;
        X X = X;
        X += 0;
        X[] X = new X[X + 0*(X-X) + 0];
        X.X(X, 0, X, 0, X);

        X X = 0;
        while (X < X)
        {
            X X = X[X++];
            if (! X.X(X) || X.X(X))
            {
                X[X++] = X;
            }
            else if (X != 0)
            {
                if (X) X[X++] = 0;
                X[X++] = X;
            }
            else if (X)
            {
                if (X[X] == 0)
                {
                    X++;
                    X = 0;
                }
                else
                {
                    X[X++] = 0;
                    X[X++] = 0;
                }
            }
            else
            {
                if (X[X] == 0)
                {
                    X++;
                    X = 0;
                }
                else
                {
                    X[X++] = X;
                    if (X != X)
                        X[X++] = X[X++];
                }
            }
        }

        X = X;
        X = X.X(X, X + 0); // double zero termination
    }

    /**
     * Copies regular expression to an int array and invokes the parsing
     * of the expression which will create the object tree.
     */
    private X X()
    {
        // Handle canonical equivalences
        if (X(X) && !X(X))
        {
            X();
        }
        else
        {
            X = X;
        }
        X = X.X();

        // Copy pattern to int array for convenience
        // Use double zero to terminate pattern
        X = new X[X + 0];

        X X = 0;
        X X, X = 0;
        // Convert all chars into code points
        for (X X = 0; X < X; X += X.X(X))
        {
            X = X.X(X);
            if (X(X))
            {
                X = 0;
            }
            X[X++] = X;
        }

        X = X;   // patternLength now in code points

        if (! X(X))
            X();

        // Allocate all temporary objects here.
        X = new X[0];
        X = new X[0];

        if (X(X))
        {
            // Literal pattern handling
            X = X(X, X, X);
            X.X = X;
        }
        else
        {
            // Start recursive descent parsing
            X = X(X);
            // Check extra pattern characters
            if (X != X)
            {
                if (X() == 0)
                {
                    throw X(0);
                }
                else
                {
                    throw X(0);
                }
            }
        }

        // Peephole optimization
        if (X instanceof X)
        {
            X = X.X(X);
            if (X == X)
            {
                X = X ? new X(X) : new X(X);
            }
        }
        else if (X instanceof X || X instanceof X)
        {
            X = X;
        }
        else
        {
            X = X ? new X(X) : new X(X);
        }

        // Release temporary storage
        X = 0;
        X = 0;
        X = 0;
        X = 0;
        X = 0;
    }

    /**
     * Used to print out a subtree of the Pattern to help with debugging.
     */
    private static X X(X X)
    {
        while(X != 0)
        {
            if (X instanceof X)
            {
                X.X.X(X);
                X(((X)X).X);
                X.X.X(0);
            }
            else if (X instanceof X)
            {
                X.X.X(X);
                X(((X)X).X);
                X.X.X(0);
            }
            else if (X instanceof X)
            {
                X.X.X(X);
                X(((X)X).X);
                X.X.X(0);
            }
            else if (X instanceof X)
            {
                X.X.X(X);
                X(((X)X).X);
                X.X.X(0);
            }
            else if (X instanceof X)
            {
                X.X.X(X);
                X.X.X(0+X.X);
                return;
            }
            else
            {
                X.X.X(X);
            }
            X = X.X;
            if (X != 0)
                X.X.X(0);
            if (X == X.X)
            {
                X.X.X(0);
                X = 0;
            }
        }
    }

    /**
     * Used to accumulate information about a subtree of the object graph
     * so that optimizations can be applied to the subtree.
     */
    static final class X
    {
        X X;
        X X;
        X X;
        X X;

        X()
        {
            X();
        }
        X X()
        {
            X = 0;
            X = 0;
            X = 0;
            X = 0;
        }
    }

    /*
     * The following private methods are mainly used to improve the
     * readability of the code. In order to let the Java compiler easily
     * inline them, we should not put many assertions or error checks in them.
     */

    /**
     * Indicates whether a particular flag is set or not.
     */
    private X X(X X)
    {
        return (X & X) != 0;
    }

    /**
     * Match next character, signal error if failed.
     */
    private X X(X X, X X)
    {
        X X = X[X++];
        if (X(X))
            X = X(X);
        if (X != X)
        {
            throw X(X);
        }
    }

    /**
     * Mark the end of pattern with a specific character.
     */
    private X X(X X)
    {
        X[X] = X;
    }

    /**
     * Peek the next character, and do not advance the cursor.
     */
    private X X()
    {
        X X = X[X];
        if (X(X))
            X = X(X);
        return X;
    }

    /**
     * Read the next character, and advance the cursor by one.
     */
    private X X()
    {
        X X = X[X++];
        if (X(X))
            X = X(X);
        return X;
    }

    /**
     * Read the next character, and advance the cursor by one,
     * ignoring the COMMENTS setting
     */
    private X X()
    {
        X X = X[X++];
        return X;
    }

    /**
     * Advance the cursor by one, and peek the next character.
     */
    private X X()
    {
        X X = X[++X];
        if (X(X))
            X = X(X);
        return X;
    }

    /**
     * Advance the cursor by one, and peek the next character,
     * ignoring the COMMENTS setting
     */
    private X X()
    {
        X X = X[++X];
        return X;
    }

    /**
     * If in xmode peek past whitespace and comments.
     */
    private X X(X X)
    {
        while (X.X(X) || X == 0)
        {
            while (X.X(X))
                X = X[++X];
            if (X == 0)
            {
                X = X();
            }
        }
        return X;
    }

    /**
     * If in xmode parse past whitespace and comments.
     */
    private X X(X X)
    {
        while (X.X(X) || X == 0)
        {
            while (X.X(X))
                X = X[X++];
            if (X == 0)
                X = X();
        }
        return X;
    }

    /**
     * xmode parse past comment to end of line.
     */
    private X X()
    {
        X X = X[X++];
        while (X != 0 && !X(X))
            X = X[X++];
        return X;
    }

    /**
     * xmode peek past comment to end of line.
     */
    private X X()
    {
        X X = X[++X];
        while (X != 0 && !X(X))
            X = X[++X];
        return X;
    }

    /**
     * Determines if character is a line separator in the current mode
     */
    private X X(X X)
    {
        if (X(X))
        {
            return X == 0;
        }
        else
        {
            return (X == 0 ||
                    X == 0 ||
                    (X|0) == 0 ||
                    X == 0);
        }
    }

    /**
     * Read the character after the next one, and advance the cursor by two.
     */
    private X X()
    {
        X X = X;
        X X = X[X+0];
        X = X + 0;
        return X;
    }

    /**
     * Unread one next character, and retreat cursor by one.
     */
    private X X()
    {
        X--;
    }

    /**
     * Internal method used for handling all syntax errors. The pattern is
     * displayed with a pointer to aid in locating the syntax error.
     */
    private X X(X X)
    {
        return new X(X, X,  X - 0);
    }

    /**
     * Determines if there is any supplementary character or unpaired
     * surrogate in the specified range.
     */
    private X X(X X, X X)
    {
        for (X X = X; X < X; X++)
        {
            if (X(X[X]))
                return 0;
        }
        return 0;
    }

    /**
     * Determines if the specified code point is a supplementary
     * character or unpaired surrogate.
     */
    private static final X X(X X)
    {
        return X >= X.X || X(X);
    }

    /**
     *  The following methods handle the main parsing. They are sorted
     *  according to their precedence order, the lowest one first.
     */

    /**
     * The expression is parsed with branch nodes added for alternations.
     * This may be called recursively to parse sub expressions that may
     * contain alternations.
     */
    private X X(X X)
    {
        X X = 0;
        X X = 0;
        X X = 0;

        for (;;)
        {
            X X = X(X);
            X X = X;      //double return
            if (X == 0)
            {
                X = X;
                X = X;
            }
            else
            {
                // Branch
                if (X == 0)
                {
                    X = new X();
                    X.X = X;
                }
                if (X == X)
                {
                    // if the node returned from sequence() is "end"
                    // we have an empty expr, set a null atom into
                    // the branch to indicate to go "next" directly.
                    X = 0;
                }
                else
                {
                    // the "tail.next" of each atom goes to branchConn
                    X.X = X;
                }
                if (X instanceof X)
                {
                    ((X)X).X(X);
                }
                else
                {
                    if (X == X)
                    {
                        X = 0;
                    }
                    else
                    {
                        // replace the "end" with "branchConn" at its tail.next
                        // when put the "prev" into the branch as the first atom.
                        X.X = X;
                    }
                    X = new X(X, X, X);
                }
            }
            if (X() != 0)
            {
                return X;
            }
            X();
        }
    }

    /**
     * Parsing of sequences between alternations.
     */
    private X X(X X)
    {
        X X = 0;
        X X = 0;
        X X = 0;
        X:
        for (;;)
        {
            X X = X();
            switch (X)
            {
            case 0:
                // Because group handles its own closure,
                // we need to treat it differently
                X = X();
                // Check for comment or flag group
                if (X == 0)
                    continue;
                if (X == 0)
                    X = X;
                else
                    X.X = X;
                // Double return: Tail was returned in root
                X = X;
                continue;
            case 0:
                X = X(0);
                break;
            case 0:
                X = X();
                if (X == 0 || X == 0)
                {
                    X X = 0;
                    X X = (X == 0);
                    X = X(); // Consume { if present
                    if (X != 0)
                    {
                        X();
                    }
                    else
                    {
                        X = 0;
                    }
                    X = X(X).X(X);
                }
                else
                {
                    X();
                    X = X();
                }
                break;
            case 0:
                X();
                if (X(X))
                {
                    if (X(X))
                        X = new X();
                    else
                        X = new X();
                }
                else
                {
                    X = new X();
                }
                break;
            case 0:
                X();
                if (X(X))
                    X = new X(X(X));
                else
                    X = new X(X(X));
                break;
            case 0:
                X();
                if (X(X))
                {
                    X = new X();
                }
                else
                {
                    if (X(X))
                        X = new X();
                    else
                    {
                        X = new X();
                    }
                }
                break;
            case 0:
            case 0:
                break X;
            case 0: // Now interpreting dangling ] and } as literals
            case 0:
                X = X();
                break;
            case 0:
            case 0:
            case 0:
                X();
                throw X(0 + ((X)X) + 0);
            case 0:
                if (X >= X)
                {
                    break X;
                }
                // Fall through
            default:
                X = X();
                break;
            }

            X = X(X);

            if (X == 0)
            {
                X = X = X;
            }
            else
            {
                X.X = X;
                X = X;
            }
        }
        if (X == 0)
        {
            return X;
        }
        X.X = X;
        X = X;      //double return
        return X;
    }

    /**
     * Parse and add a new Single or Slice.
     */
    private X X()
    {
        X X = 0;
        X X = -0;
        X X = 0;
        X X = X();
        for (;;)
        {
            switch (X)
            {
            case 0:
            case 0:
            case 0:
            case 0:
                if (X > 0)
                {
                    X = X;    // Unwind one character
                    X--;
                }
                break;
            case 0:
            case 0:
            case 0:
            case 0:
            case 0:
            case 0:
            case 0:
                break;
            case 0:
                X = X();
                if (X == 0 || X == 0)   // Property
                {
                    if (X > 0)   // Slice is waiting; handle it first
                    {
                        X();
                        break;
                    }
                    else     // No slice; just return the family node
                    {
                        X X = (X == 0);
                        X X = 0;
                        X = X(); // Consume { if present
                        if (X != 0)
                            X();
                        else
                            X = 0;
                        return X(X).X(X);
                    }
                }
                X();
                X = X;
                X = X(0, X == 0);
                if (X >= 0)
                {
                    X(X, X);
                    X++;
                    if (X(X))
                    {
                        X = 0;
                    }
                    X = X();
                    continue;
                }
                else if (X == 0)
                {
                    return X;
                }
                // Unwind meta escape sequence
                X = X;
                break;
            case 0:
                if (X >= X)
                {
                    break;
                }
                // Fall through
            default:
                X = X;
                X(X, X);
                X++;
                if (X(X))
                {
                    X = 0;
                }
                X = X();
                continue;
            }
            break;
        }
        if (X == 0)
        {
            return X(X[0]);
        }
        else
        {
            return X(X, X, X);
        }
    }

    private X X(X X, X X)
    {
        if (X >= X.X)
        {
            X[] X = new X[X+X];
            X.X(X, 0, X, 0, X);
            X = X;
        }
        X[X] = X;
    }

    /**
     * Parses a backref greedily, taking as many numbers as it
     * can. The first digit is always treated as a backref, but
     * multi digit numbers are only treated as a backref if at
     * least that many backrefs exist at this point in the regex.
     */
    private X X(X X)
    {
        X X = 0;
        while(!X)
        {
            X X = X();
            switch(X)
            {
            case 0:
            case 0:
            case 0:
            case 0:
            case 0:
            case 0:
            case 0:
            case 0:
            case 0:
            case 0:
                X X = (X * 0) + (X - 0);
                // Add another number if it doesn't make a group
                // that doesn't exist
                if (X - 0 < X)
                {
                    X = 0;
                    break;
                }
                X = X;
                X();
                break;
            default:
                X = 0;
                break;
            }
        }
        if (X(X))
            return new X(X, X(X));
        else
            return new X(X);
    }

    /**
     * Parses an escape sequence to determine the actual value that needs
     * to be matched.
     * If -1 is returned and create was true a new object was added to the tree
     * to handle the escape sequence.
     * If the returned value is greater than zero, it is the value that
     * matches the escape sequence.
     */
    private X X(X X, X X)
    {
        X X = X();
        switch (X)
        {
        case 0:
            return X();
        case 0:
        case 0:
        case 0:
        case 0:
        case 0:
        case 0:
        case 0:
        case 0:
        case 0:
            if (X) break;
            if (X)
            {
                X = X((X - 0));
            }
            return -0;
        case 0:
            if (X) break;
            if (X) X = new X();
            return -0;
        case 0:
            if (X) break;
            if (X) X = new X(X.X);
            return -0;
        case 0:
            break;
        case 0:
            if (X) X = new X(X.X).X();
            return -0;
        case 0:
        case 0:
            break;
        case 0:
            if (X) break;
            if (X) X = new X();
            return -0;
        case 0:
        case 0:
        case 0:
        case 0:
        case 0:
        case 0:
        case 0:
        case 0:
        case 0:
        case 0:
        case 0:
            break;
        case 0:
            if (X) X = new X(X.X).X();
            return -0;
        case 0:
        case 0:
        case 0:
            break;
        case 0:
            if (X) X = new X(X.X).X();
            return -0;
        case 0:
        case 0:
            break;
        case 0:
            if (X) break;
            if (X)
            {
                if (X(X))
                    X = new X(0);
                else
                    X = new X(0);
            }
            return -0;
        case 0:
            return 0;
        case 0:
            if (X) break;
            if (X) X = new X(X.X);
            return -0;
        case 0:
            return X();
        case 0:
            if (X) X = new X(X.X);
            return -0;
        case 0:
            return 0;
        case 0:
            return 0;
        case 0:
        case 0:
        case 0:
        case 0:
        case 0:
        case 0:
        case 0:
            break;
        case 0:
            return 0;
        case 0:
        case 0:
        case 0:
            break;
        case 0:
            return 0;
        case 0:
            if (X) X = new X(X.X);
            return -0;
        case 0:
            return 0;
        case 0:
            return X();
        case 0:
            return 0;
        case 0:
            if (X) X = new X(X.X);
            return -0;
        case 0:
            return X();
        case 0:
            break;
        case 0:
            if (X) break;
            if (X) X = new X();
            return -0;
        default:
            return X;
        }
        throw X(0);
    }

    /**
     * Parse a character class, and return the node that matches it.
     *
     * Consumes a ] on the way out if consume is true. Usually consume
     * is true except for the case of [abc&&def] where def is a separate
     * right hand node with "understood" brackets.
     */
    private X X(X X)
    {
        X X = 0;
        X X = 0;
        X X = new X();
        X X = 0;
        X X = 0;
        X X = X();
        for (;;)
        {
            switch (X)
            {
            case 0:
                // Negates if first char in a class, otherwise literal
                if (X)
                {
                    if (X[X-0] != 0)
                        break;
                    X = X();
                    X = !X;
                    continue;
                }
                else
                {
                    // ^ not first in class, treat as literal
                    break;
                }
            case 0:
                X = 0;
                X = X(0);
                if (X == 0)
                    X = X;
                else
                    X = X(X, X);
                X = X();
                continue;
            case 0:
                X = 0;
                X = X();
                if (X == 0)
                {
                    X = X();
                    X X = 0;
                    while (X != 0 && X != 0)
                    {
                        if (X == 0)
                        {
                            if (X == 0)
                                X = X(0);
                            else
                                X = X(X, X(0));
                        }
                        else     // abc&&def
                        {
                            X();
                            X = X(0);
                        }
                        X = X();
                    }
                    if (X != 0)
                        X = X;
                    if (X == 0)
                    {
                        if (X == 0)
                            throw X(0);
                        else
                            X = X;
                    }
                    else
                    {
                        X = X(X, X);
                    }
                }
                else
                {
                    // treat as a literal &
                    X();
                    break;
                }
                continue;
            case 0:
                X = 0;
                if (X >= X)
                    throw X(0);
                break;
            case 0:
                X = 0;
                if (X != 0)
                {
                    if (X)
                        X();
                    return X;
                }
                break;
            default:
                X = 0;
                break;
            }
            X = X(X);
            if (X)
            {
                if (X == 0)
                {
                    X = X;
                }
                else
                {
                    if (X != X)
                        X = X(X, X);
                }
            }
            else
            {
                if (X == 0)
                {
                    X = X.X();
                }
                else
                {
                    if (X != X)
                        X = X(X, X);
                }
            }
            X = X();
        }
    }

    private X X(X X, X X)
    {
        /* Bits can only handle codepoints in [u+0000-u+00ff] range.
           Use "single" node instead of bits when dealing with unicode
           case folding for codepoints listed below.
           (1)Uppercase out of range: u+00ff, u+00b5
              toUpperCase(u+00ff) -> u+0178
              toUpperCase(u+00b5) -> u+039c
               (2)LatinSmallLetterLongS u+17f
              toUpperCase(u+017f) -> u+0053
           (3)LatinSmallLetterDotlessI u+131
              toUpperCase(u+0131) -> u+0049
           (4)LatinCapitalLetterIWithDotAbove u+0130
              toLowerCase(u+0130) -> u+0069
           (5)KelvinSign u+212a
              toLowerCase(u+212a) ==> u+006B
           (6)AngstromSign u+212b
              toLowerCase(u+212b) ==> u+00e5
        */
        X X;
        if (X < 0 &&
                !(X(X) && X(X) &&
                  (X == 0 || X == 0 ||
                   X == 0 || X == 0 ||  //I and i
                   X == 0 || X == 0 ||  //S and s
                   X == 0 || X == 0 ||  //K and k
                   X == 0 || X == 0)))  //A+ring
            return X.X(X, X());
        return X(X);
    }

    /**
     * Parse a single character or a character range in a character class
     * and return its representative node.
     */
    private X X(X X)
    {
        X X = X();
        if (X == 0)
        {
            X = X();
            if (X == 0 || X == 0)   // A property
            {
                X X = (X == 0);
                X X = 0;
                // Consume { if present
                X = X();
                if (X != 0)
                    X();
                else
                    X = 0;
                return X(X).X(X);
            }
            else     // ordinary escape
            {
                X();
                X = X(0, 0);
                if (X == -0)
                    return (X) X;
            }
        }
        else
        {
            X = X();
        }
        if (X >= 0)
        {
            if (X() == 0)
            {
                X X = X[X+0];
                if (X == 0)
                {
                    return X(X, X);
                }
                if (X != 0)
                {
                    X();
                    X X = X();
                    if (X < X)
                        throw X(0);
                    if (X(X))
                        return X(X, X);
                    else
                        return X(X, X);
                }
            }
            return X(X, X);
        }
        throw X(0+((X)X)+0);
    }

    private X X()
    {
        X X = X();
        switch (X)
        {
        case 0:
            return X(0, 0);
        default:
            X();
            return X;
        }
    }

    /**
     * Parses a Unicode character family and returns its representative node.
     */
    private X X(X X)
    {
        X();
        X X;

        if (X)
        {
            X X = X[X];
            if (!X.X(X))
            {
                X = X.X((X)X);
            }
            else
            {
                X = new X(X, X, 0);
            }
            X();
        }
        else
        {
            X X = X;
            X(0);
            while(X() != 0)
            {
            }
            X(0);
            X X = X;
            if (X > X)
                throw X(0);
            if (X + 0 >= X)
                throw X(0);
            X = new X(X, X, X-X-0);
        }

        if (X.X(0))
        {
            return X(X.X(0));
        }
        else
        {
            if (X.X(0))
                X = X.X(0);
            return X(X);
        }
    }

    /**
     * Returns a CharProperty matching all characters in a UnicodeBlock.
     */
    private X X(X X)
    {
        final X.X X;
        try
        {
            X = X.X.X(X);
        }
        catch (X X)
        {
            throw X(0 + X + 0);
        }
        return new X()
        {
            X X(X X)
            {
                return X == X.X.X(X);
            }
        };
    }

    /**
     * Returns a CharProperty matching all characters in a named property.
     */
    private X X(X X)
    {
        X X = X.X(X);
        if (X == 0)
            throw X(0 + X + 0);
        return X;
    }

    /**
     * Parses a group and returns the head node of a set of nodes that process
     * the group. Sometimes a double return system is used where the tail is
     * returned in root.
     */
    private X X()
    {
        X X = 0;
        X X = 0;
        X X = 0;
        X X = X;
        X = 0;
        X X = X();
        if (X == 0)
        {
            X = X();
            switch (X)
            {
            case 0:   //  (?:xxx) pure group
                X = X(0);
                X = X;
                X.X = X(X);
                break;
            case 0:   // (?=xxx) and (?!xxx) lookahead
            case 0:
                X = X(0);
                X = X;
                X.X = X(X);
                if (X == 0)
                {
                    X = X = new X(X);
                }
                else
                {
                    X = X = new X(X);
                }
                break;
            case 0:   // (?>xxx)  independent group
                X = X(0);
                X = X;
                X.X = X(X);
                X = X = new X(X, X);
                break;
            case 0:   // (?<xxx)  look behind
                X = X();
                X X = X;
                X = X(0);
                X = X;
                X.X = X(X);
                X.X = X;
                X X = new X();
                X.X(X);
                if (X.X == 0)
                {
                    throw X(0
                                + 0);
                }
                X X = X(X, X);
                if (X == 0)
                {
                    X = X = (X ?
                                   new X(X, X.X,
                                               X.X) :
                                   new X(X, X.X,
                                              X.X));
                }
                else if (X == 0)
                {
                    X = X = (X ?
                                   new X(X, X.X,
                                                  X.X) :
                                   new X(X, X.X,
                                                 X.X));
                }
                else
                {
                    throw X(0);
                }
                break;
            case 0:
            case 0:
                throw X(0);
            default:    // (?xxx:) inlined match flags
                X();
                X();
                X = X();
                if (X == 0)
                {
                    return 0;    // Inline modifier only
                }
                if (X != 0)
                {
                    throw X(0);
                }
                X = X(0);
                X = X;
                X.X = X(X);
                break;
            }
        }
        else     // (xxx) a regular group
        {
            X = 0;
            X = X(0);
            X = X;
            X.X = X(X);
        }

        X(0, 0);
        X = X;

        // Check for quantifiers
        X X = X(X);
        if (X == X)   // No closure
        {
            X = X;
            return X;    // Dual return
        }
        if (X == X)   // Zero length assertion
        {
            X = X;
            return X;    // Dual return
        }

        if (X instanceof X)
        {
            X X = (X) X;
            if (X.X == X)
            {
                X = X;
                return X;
            }
            X.X = new X();
            X = X.X;
            if (X.X == X)
            {
                X = new X(X, 0, X);
            }
            else     // Reluctant quantifier
            {
                X = new X(0, X, X);
            }
            X = X;
            return X;
        }
        else if (X instanceof X)
        {
            X X = (X) X;
            if (X.X == X)
            {
                X = X;
                return X;
            }
            // Discover if the group is deterministic
            X X = new X();
            if (X.X(X))   // Deterministic
            {
                X X = (X) X;
                X = X = new X(X.X, X.X,
                                             X.X, X.X,
                                             ((X)X).X,
                                             ((X)X).X,
                                             X);
                return X;
            }
            else     // Non-deterministic
            {
                X X = ((X) X).X;
                X X;
                if (X.X == X)
                    X = new X(X.X, X);
                else  // Reluctant Curly
                    X = new X(X.X, X);
                X X = new X(X);
                X.X += 0;
                X.X = X.X;
                X.X = X.X;
                X.X = X;
                X.X = X;
                X = X;
                return X; // Dual return
            }
        }
        throw X(0);
    }

    /**
     * Create group head and tail nodes using double return. If the group is
     * created with anonymous true then it is a pure group and should not
     * affect group counting.
     */
    private X X(X X)
    {
        X X = X++;
        X X = 0;
        if (!X)
            X = X++;
        X X = new X(X);
        X = new X(X, X);
        if (!X && X < 0)
            X[X] = X;
        return X;
    }

    /**
     * Parses inlined match flags and set them appropriately.
     */
    private X X()
    {
        X X = X();
        for (;;)
        {
            switch (X)
            {
            case 0:
                X |= X;
                break;
            case 0:
                X |= X;
                break;
            case 0:
                X |= X;
                break;
            case 0:
                X |= X;
                break;
            case 0:
                X |= X;
                break;
            case 0:
                X |= X;
                break;
            case 0:
                X |= X;
                break;
            case 0: // subFlag then fall through
                X = X();
                X();
            default:
                return;
            }
            X = X();
        }
    }

    /**
     * Parses the second part of inlined match flags and turns off
     * flags appropriately.
     */
    private X X()
    {
        X X = X();
        for (;;)
        {
            switch (X)
            {
            case 0:
                X &= ~X;
                break;
            case 0:
                X &= ~X;
                break;
            case 0:
                X &= ~X;
                break;
            case 0:
                X &= ~X;
                break;
            case 0:
                X &= ~X;
                break;
            case 0:
                X &= ~X;
                break;
            case 0:
                X &= ~X;
                break;
            default:
                return;
            }
            X = X();
        }
    }

    static final X X   = 0;

    static final X X     = 0;

    static final X X       = 0;

    static final X X = 0;

    static final X X = 0;

    /**
     * Processes repetition. If the next character peeked is a quantifier
     * then new nodes must be appended to handle the repetition.
     * Prev could be a single or a group, so it could be a chain of nodes.
     */
    private X X(X X)
    {
        X X;
        X X = X();
        switch (X)
        {
        case 0:
            X = X();
            if (X == 0)
            {
                X();
                return new X(X, X);
            }
            else if (X == 0)
            {
                X();
                return new X(X, X);
            }
            return new X(X, X);
        case 0:
            X = X();
            if (X == 0)
            {
                X();
                return new X(X, 0, X, X);
            }
            else if (X == 0)
            {
                X();
                return new X(X, 0, X, X);
            }
            return new X(X, 0, X, X);
        case 0:
            X = X();
            if (X == 0)
            {
                X();
                return new X(X, 0, X, X);
            }
            else if (X == 0)
            {
                X();
                return new X(X, 0, X, X);
            }
            return new X(X, 0, X, X);
        case 0:
            X = X[X+0];
            if (X.X(X))
            {
                X();
                X X = 0;
                do
                {
                    X = X * 0 + (X - 0);
                }
                while (X.X(X = X()));
                X X = X;
                if (X == 0)
                {
                    X = X();
                    X = X;
                    if (X != 0)
                    {
                        X = 0;
                        while (X.X(X))
                        {
                            X = X * 0 + (X - 0);
                            X = X();
                        }
                    }
                }
                if (X != 0)
                    throw X(0);
                if (((X) | (X) | (X - X)) < 0)
                    throw X(0);
                X X;
                X = X();
                if (X == 0)
                {
                    X();
                    X = new X(X, X, X, X);
                }
                else if (X == 0)
                {
                    X();
                    X = new X(X, X, X, X);
                }
                else
                {
                    X = new X(X, X, X, X);
                }
                return X;
            }
            else
            {
                throw X(0);
            }
        default:
            return X;
        }
    }

    /**
     *  Utility method for parsing control escape sequences.
     */
    private X X()
    {
        if (X < X)
        {
            return X() ^ 0;
        }
        throw X(0);
    }

    /**
     *  Utility method for parsing octal escape sequences.
     */
    private X X()
    {
        X X = X();
        if (((X-0)|(0-X)) >= 0)
        {
            X X = X();
            if (((X-0)|(0-X)) >= 0)
            {
                X X = X();
                if ((((X-0)|(0-X)) >= 0) && (((X-0)|(0-X)) >= 0))
                {
                    return (X - 0) * 0 + (X - 0) * 0 + (X - 0);
                }
                X();
                return (X - 0) * 0 + (X - 0);
            }
            X();
            return (X - 0);
        }
        throw X(0);
    }

    /**
     *  Utility method for parsing hexadecimal escape sequences.
     */
    private X X()
    {
        X X = X();
        if (X.X(X))
        {
            X X = X();
            if (X.X(X))
            {
                return X.X(X) * 0 + X.X(X);
            }
        }
        throw X(0);
    }

    /**
     *  Utility method for parsing unicode escape sequences.
     */
    private X X()
    {
        X X = 0;
        for (X X = 0; X < 0; X++)
        {
            X X = X();
            if (!X.X(X))
            {
                throw X(0);
            }
            X = X * 0 + X.X(X);
        }
        return X;
    }

    //
    // Utility methods for code point support
    //

    /**
     * Tests a surrogate value.
     */
    private static final X X(X X)
    {
        return X >= X.X && X <= X.X;
    }

    private static final X X(X X, X X,
                                        X X)
    {
        // optimization
        if (X == 0 && !X.X(X.X(X)))
        {
            assert (X >= 0 && X < X.X());
            return 0;
        }
        X X = X.X();
        X X = X;
        if (X >= 0)
        {
            assert (X >= 0 && X < X);
            for (X X = 0; X < X && X < X; X++)
            {
                if (X.X(X.X(X++)))
                {
                    if (X < X && X.X(X.X(X)))
                    {
                        X++;
                    }
                }
            }
            return X - X;
        }

        assert (X >= 0 && X <= X);
        if (X == 0)
        {
            return 0;
        }
        X X = -X;
        for (X X = 0; X > 0 && X < X; X++)
        {
            if (X.X(X.X(--X)))
            {
                if (X > 0 && X.X(X.X(X-0)))
                {
                    X--;
                }
            }
        }
        return X - X;
    }

    private static final X X(X X)
    {
        X X = X.X();
        X X = 0;
        for (X X = 0; X < X; )
        {
            X++;
            if (X.X(X.X(X++)))
            {
                if (X < X && X.X(X.X(X)))
                {
                    X++;
                }
            }
        }
        return X;
    }

    /**
     *  Creates a bit vector for matching Latin-1 values. A normal BitClass
     *  never matches values above Latin-1, and a complemented BitClass always
     *  matches values above Latin-1.
     */
    private static final class X extends X
    {
        final X[] X;
        X()
        {
            X = new X[0];
        }
        private X(X[] X)
        {
            X.X = X;
        }
        X X(X X, X X)
        {
            assert X >= 0 && X <= 0;
            if ((X & X) != 0)
            {
                if (X.X(X))
                {
                    X[X.X(X)] = 0;
                    X[X.X(X)] = 0;
                }
                else if ((X & X) != 0)
                {
                    X[X.X(X)] = 0;
                    X[X.X(X)] = 0;
                }
            }
            X[X] = 0;
            return X;
        }
        X X(X X)
        {
            return X < 0 && X[X];
        }
    }

    /**
     *  Returns a suitably optimized, single character matcher.
     */
    private X X(final X X)
    {
        if (X(X))
        {
            X X, X;
            if (X(X))
            {
                X = X.X(X);
                X = X.X(X);
                if (X != X)
                    return new X(X);
            }
            else if (X.X(X))
            {
                X = X.X(X);
                X = X.X(X);
                if (X != X)
                    return new X(X, X);
            }
        }
        if (X(X))
            return new X(X);    // Match a given Unicode character
        return new X(X);         // Match a given BMP character
    }

    /**
     *  Utility method for creating a string slice matcher.
     */
    private X X(X[] X, X X, X X)
    {
        X[] X = new X[X];
        if (X(X))
        {
            if (X(X))
            {
                for (X X = 0; X < X; X++)
                {
                    X[X] = X.X(
                                 X.X(X[X]));
                }
                return X? new X(X) : new X(X);
            }
            for (X X = 0; X < X; X++)
            {
                X[X] = X.X(X[X]);
            }
            return X? new X(X) : new X(X);
        }
        for (X X = 0; X < X; X++)
        {
            X[X] = X[X];
        }
        return X ? new X(X) : new X(X);
    }

    /**
     * The following classes are the building components of the object
     * tree that represents a compiled regular expression. The object tree
     * is made of individual elements that handle constructs in the Pattern.
     * Each type of object knows how to match its equivalent construct with
     * the match() method.
     */

    /**
     * Base class for all node classes. Subclasses should override the match()
     * method as appropriate. This class is an accepting node, so its match()
     * always returns true.
     */
    static class X extends X
    {
        X X;
        X()
        {
            X = X.X;
        }
        /**
         * This method implements the classic accept node.
         */
        X X(X X, X X, X X)
        {
            X.X = X;
            X.X[0] = X.X;
            X.X[0] = X.X;
            return 0;
        }
        /**
         * This method is good for all zero length assertions.
         */
        X X(X X)
        {
            if (X != 0)
            {
                return X.X(X);
            }
            else
            {
                return X.X;
            }
        }
    }

    static class X extends X
    {
        /**
         * This method implements the classic accept node with
         * the addition of a check to see if the match occurred
         * using all of the input.
         */
        X X(X X, X X, X X)
        {
            if (X.X == X.X && X != X.X)
                return 0;
            X.X = X;
            X.X[0] = X.X;
            X.X[0] = X.X;
            return 0;
        }
    }

    /**
     * Used for REs that can start anywhere within the input string.
     * This basically tries to match repeatedly at each spot in the
     * input string, moving forward after each try. An anchored search
     * or a BnM will bypass this node completely.
     */
    static class X extends X
    {
        X X;
        X(X X)
        {
            X.X = X;
            X X = new X();
            X.X(X);
            X = X.X;
        }
        X X(X X, X X, X X)
        {
            if (X > X.X - X)
            {
                X.X = 0;
                return 0;
            }
            X X = 0;
            X X = X.X - X;
            for (; X <= X; X++)
            {
                if (X = X.X(X, X, X))
                    break;
                if (X == X)
                    X.X = 0;
            }
            if (X)
            {
                X.X = X;
                X.X[0] = X.X;
                X.X[0] = X.X;
            }
            return X;
        }
        X X(X X)
        {
            X.X(X);
            X.X = 0;
            X.X = 0;
            return 0;
        }
    }

    /*
     * StartS supports supplementary characters, including unpaired surrogates.
     */
    static final class X extends X
    {
        X(X X)
        {
            X(X);
        }
        X X(X X, X X, X X)
        {
            if (X > X.X - X)
            {
                X.X = 0;
                return 0;
            }
            X X = 0;
            X X = X.X - X;
            while (X <= X)
            {
                if ((X = X.X(X, X, X)) || X == X)
                    break;
                // Optimization to move to the next character. This is
                // faster than countChars(seq, i, 1).
                if (X.X(X.X(X++)))
                {
                    if (X < X.X() && X.X(X.X(X)))
                    {
                        X++;
                    }
                }
                if (X == X)
                    X.X = 0;
            }
            if (X)
            {
                X.X = X;
                X.X[0] = X.X;
                X.X[0] = X.X;
            }
            return X;
        }
    }

    /**
     * Node to anchor at the beginning of input. This object implements the
     * match for a \A sequence, and the caret anchor will use this if not in
     * multiline mode.
     */
    static final class X extends X
    {
        X X(X X, X X, X X)
        {
            X X = (X.X) ?
                            X.X : 0;
            if (X == X && X.X(X, X, X))
            {
                X.X = X;
                X.X[0] = X;
                X.X[0] = X.X;
                return 0;
            }
            else
            {
                return 0;
            }
        }
    }

    /**
     * Node to anchor at the end of input. This is the absolute end, so this
     * should not match at the last newline before the end as $ will.
     */
    static final class X extends X
    {
        X X(X X, X X, X X)
        {
            X X = (X.X) ?
                           X.X : X.X();
            if (X == X)
            {
                X.X = 0;
                return X.X(X, X, X);
            }
            return 0;
        }
    }

    /**
     * Node to anchor at the beginning of a line. This is essentially the
     * object to match for the multiline ^.
     */
    static final class X extends X
    {
        X X(X X, X X, X X)
        {
            X X = X.X;
            X X = X.X;
            if (!X.X)
            {
                X = 0;
                X = X.X();
            }
            // Perl does not match ^ at end of input even after newline
            if (X == X)
            {
                X.X = 0;
                return 0;
            }
            if (X > X)
            {
                X X = X.X(X-0);
                if (X != 0 && X != 0
                        && (X|0) != 0
                        && X != 0 )
                {
                    return 0;
                }
                // Should treat /r/n as one newline
                if (X == 0 && X.X(X) == 0)
                    return 0;
            }
            return X.X(X, X, X);
        }
    }

    /**
     * Node to anchor at the beginning of a line when in unixdot mode.
     */
    static final class X extends X
    {
        X X(X X, X X, X X)
        {
            X X = X.X;
            X X = X.X;
            if (!X.X)
            {
                X = 0;
                X = X.X();
            }
            // Perl does not match ^ at end of input even after newline
            if (X == X)
            {
                X.X = 0;
                return 0;
            }
            if (X > X)
            {
                X X = X.X(X-0);
                if (X != 0)
                {
                    return 0;
                }
            }
            return X.X(X, X, X);
        }
    }

    /**
     * Node to match the location where the last match ended.
     * This is used for the \G construct.
     */
    static final class X extends X
    {
        X X(X X, X X, X X)
        {
            if (X != X.X)
                return 0;
            return X.X(X, X, X);
        }
    }

    /**
     * Node to anchor at the end of a line or the end of input based on the
     * multiline mode.
     *
     * When not in multiline mode, the $ can only match at the very end
     * of the input, unless the input ends in a line terminator in which
     * it matches right before the last line terminator.
     *
     * Note that \r\n is considered an atomic line terminator.
     *
     * Like ^ the $ operator matches at a position, it does not match the
     * line terminators themselves.
     */
    static final class X extends X
    {
        X X;
        X(X X)
        {
            X = X;
        }
        X X(X X, X X, X X)
        {
            X X = (X.X) ?
                           X.X : X.X();
            if (!X)
            {
                if (X < X - 0)
                    return 0;
                if (X == X - 0)
                {
                    X X = X.X(X);
                    if (X != 0)
                        return 0;
                    X = X.X(X + 0);
                    if (X != 0)
                        return 0;
                }
            }
            // Matches before any line terminator; also matches at the
            // end of input
            // Before line terminator:
            // If multiline, we match here no matter what
            // If not multiline, fall through so that the end
            // is marked as hit; this must be a /r/n or a /n
            // at the very end so the end was hit; more input
            // could make this not match here
            if (X < X)
            {
                X X = X.X(X);
                if (X == 0)
                {
                    // No match between \r\n
                    if (X > 0 && X.X(X-0) == 0)
                        return 0;
                    if (X)
                        return X.X(X, X, X);
                }
                else if (X == 0 || X == 0 ||
                         (X|0) == 0)
                {
                    if (X)
                        return X.X(X, X, X);
                }
                else     // No line terminator, no match
                {
                    return 0;
                }
            }
            // Matched at current end so hit end
            X.X = 0;
            // If a $ matches because of end of input, then more input
            // could cause it to fail!
            X.X = 0;
            return X.X(X, X, X);
        }
        X X(X X)
        {
            X.X(X);
            return X.X;
        }
    }

    /**
     * Node to anchor at the end of a line or the end of input based on the
     * multiline mode when in unix lines mode.
     */
    static final class X extends X
    {
        X X;
        X(X X)
        {
            X = X;
        }
        X X(X X, X X, X X)
        {
            X X = (X.X) ?
                           X.X : X.X();
            if (X < X)
            {
                X X = X.X(X);
                if (X == 0)
                {
                    // If not multiline, then only possible to
                    // match at very end or one before end
                    if (X == 0 && X != X - 0)
                        return 0;
                    // If multiline return next.match without setting
                    // matcher.hitEnd
                    if (X)
                        return X.X(X, X, X);
                }
                else
                {
                    return 0;
                }
            }
            // Matching because at the end or 1 before the end;
            // more input could change this so set hitEnd
            X.X = 0;
            // If a $ matches because of end of input, then more input
            // could cause it to fail!
            X.X = 0;
            return X.X(X, X, X);
        }
        X X(X X)
        {
            X.X(X);
            return X.X;
        }
    }

    /**
     * Abstract node class to match one character satisfying some
     * boolean property.
     */
    private static abstract class X extends X
    {
        abstract X X(X X);
        X X()
        {
            return new X()
            {
                X X(X X)
                {
                    return ! X.X.X(X);
                }
            };
        }
        X X(X X)
        {
            return X ? X() : X;
        }
        X X(X X, X X, X X)
        {
            if (X < X.X)
            {
                X X = X.X(X, X);
                return X(X)
                       && X.X(X, X+X.X(X), X);
            }
            else
            {
                X.X = 0;
                return 0;
            }
        }
        X X(X X)
        {
            X.X++;
            X.X++;
            return X.X(X);
        }
    }

    /**
     * Optimized version of CharProperty that works only for
     * properties never satisfied by Supplementary characters.
     */
    private static abstract class X extends X
    {
        X X(X X, X X, X X)
        {
            if (X < X.X)
            {
                return X(X.X(X))
                       && X.X(X, X+0, X);
            }
            else
            {
                X.X = 0;
                return 0;
            }
        }
    }

    /**
     * Node class that matches a Supplementary Unicode character
     */
    static final class X extends X
    {
        final X X;
        X(X X)
        {
            X.X = X;
        }
        X X(X X)
        {
            return X == X;
        }
    }

    /**
     * Optimization -- matches a given BMP character
     */
    static final class X extends X
    {
        final X X;
        X(X X)
        {
            X.X = X;
        }
        X X(X X)
        {
            return X == X;
        }
    }

    /**
     * Case insensitive matches a given BMP character
     */
    static final class X extends X
    {
        final X X;
        final X X;
        X(X X, X X)
        {
            X.X = X;
            X.X = X;
        }
        X X(X X)
        {
            return X == X || X == X;
        }
    }

    /**
     * Unicode case insensitive matches a given Unicode character
     */
    static final class X extends X
    {
        final X X;
        X(X X)
        {
            X.X = X;
        }
        X X(X X)
        {
            return X == X ||
                   X == X.X(X.X(X));
        }
    }

    /**
     * Node class that matches a Unicode category.
     */
    static final class X extends X
    {
        final X X;
        X(X X)
        {
            X.X = X;
        }
        X X(X X)
        {
            return (X & (0 << X.X(X))) != 0;
        }
    }

    /**
     * Node class that matches a POSIX type.
     */
    static final class X extends X
    {
        final X X;
        X(X X)
        {
            X.X = X;
        }
        X X(X X)
        {
            return X < 0 && X.X(X, X);
        }
    }

    /**
     * Base class for all Slice nodes
     */
    static class X extends X
    {
        X[] X;
        X(X[] X)
        {
            X = X;
        }
        X X(X X)
        {
            X.X += X.X;
            X.X += X.X;
            return X.X(X);
        }
    }

    /**
     * Node class for a case sensitive/BMP-only sequence of literal
     * characters.
     */
    static final class X extends X
    {
        X(X[] X)
        {
            X(X);
        }
        X X(X X, X X, X X)
        {
            X[] X = X;
            X X = X.X;
            for (X X=0; X<X; X++)
            {
                if ((X+X) >= X.X)
                {
                    X.X = 0;
                    return 0;
                }
                if (X[X] != X.X(X+X))
                    return 0;
            }
            return X.X(X, X+X, X);
        }
    }

    /**
     * Node class for a case_insensitive/BMP-only sequence of literal
     * characters.
     */
    static class X extends X
    {
        X(X[] X)
        {
            X(X);
        }
        X X(X X, X X, X X)
        {
            X[] X = X;
            X X = X.X;
            for (X X=0; X<X; X++)
            {
                if ((X+X) >= X.X)
                {
                    X.X = 0;
                    return 0;
                }
                X X = X.X(X+X);
                if (X[X] != X &&
                        X[X] != X.X(X))
                    return 0;
            }
            return X.X(X, X+X, X);
        }
    }

    /**
     * Node class for a unicode_case_insensitive/BMP-only sequence of
     * literal characters. Uses unicode case folding.
     */
    static final class X extends X
    {
        X(X[] X)
        {
            X(X);
        }
        X X(X X, X X, X X)
        {
            X[] X = X;
            X X = X.X;
            for (X X=0; X<X; X++)
            {
                if ((X+X) >= X.X)
                {
                    X.X = 0;
                    return 0;
                }
                X X = X.X(X+X);
                if (X[X] != X &&
                        X[X] != X.X(X.X(X)))
                    return 0;
            }
            return X.X(X, X+X, X);
        }
    }

    /**
     * Node class for a case sensitive sequence of literal characters
     * including supplementary characters.
     */
    static final class X extends X
    {
        X(X[] X)
        {
            X(X);
        }
        X X(X X, X X, X X)
        {
            X[] X = X;
            X X = X;
            for (X X = 0; X < X.X; X++)
            {
                if (X >= X.X)
                {
                    X.X = 0;
                    return 0;
                }
                X X = X.X(X, X);
                if (X[X] != X)
                    return 0;
                X += X.X(X);
                if (X > X.X)
                {
                    X.X = 0;
                    return 0;
                }
            }
            return X.X(X, X, X);
        }
    }

    /**
     * Node class for a case insensitive sequence of literal characters
     * including supplementary characters.
     */
    static class X extends X
    {
        X(X[] X)
        {
            X(X);
        }
        X X(X X)
        {
            return X.X(X);
        }
        X X(X X, X X, X X)
        {
            X[] X = X;
            X X = X;
            for (X X = 0; X < X.X; X++)
            {
                if (X >= X.X)
                {
                    X.X = 0;
                    return 0;
                }
                X X = X.X(X, X);
                if (X[X] != X && X[X] != X(X))
                    return 0;
                X += X.X(X);
                if (X > X.X)
                {
                    X.X = 0;
                    return 0;
                }
            }
            return X.X(X, X, X);
        }
    }

    /**
     * Node class for a case insensitive sequence of literal characters.
     * Uses unicode case folding.
     */
    static final class X extends X
    {
        X(X[] X)
        {
            X(X);
        }
        X X(X X)
        {
            return X.X(X.X(X));
        }
    }

    private static X X(X X, X X, X X)
    {
        return X <= X && X <= X;
    }

    /**
     * Returns node for matching characters within an explicit value range.
     */
    private static X X(final X X,
                                         final X X)
    {
        return new X()
        {
            X X(X X)
            {
                return X(X, X, X);
            }
        };
    }

    /**
     * Returns node for matching characters within an explicit value
     * range in a case insensitive manner.
     */
    private X X(final X X,
            final X X)
    {
        if (X(X))
            return new X()
        {
            X X(X X)
            {
                if (X(X, X, X))
                    return 0;
                X X = X.X(X);
                return X(X, X, X) ||
                       X(X, X.X(X), X);
            }
        };
        return new X()
        {
            X X(X X)
            {
                return X(X, X, X) ||
                       X.X(X) &&
                       (X(X, X.X(X), X) ||
                        X(X, X.X(X), X));
            }
        };
    }

    /**
     * Implements the Unicode category ALL and the dot metacharacter when
     * in dotall mode.
     */
    static final class X extends X
    {
        X X(X X)
        {
            return 0;
        }
    }

    /**
     * Node class for the dot metacharacter when dotall is not enabled.
     */
    static final class X extends X
    {
        X X(X X)
        {
            return (X != 0 && X != 0
                    && (X|0) != 0
                    && X != 0);
        }
    }

    /**
     * Node class for the dot metacharacter when dotall is not enabled
     * but UNIX_LINES is enabled.
     */
    static final class X extends X
    {
        X X(X X)
        {
            return X != 0;
        }
    }

    /**
     * The 0 or 1 quantifier. This one class implements all three types.
     */
    static final class X extends X
    {
        X X;
        X X;
        X(X X, X X)
        {
            X.X = X;
            X.X = X;
        }
        X X(X X, X X, X X)
        {
            switch (X)
            {
            case X:
                return (X.X(X, X, X) && X.X(X, X.X, X))
                       || X.X(X, X, X);
            case X:
                return X.X(X, X, X)
                       || (X.X(X, X, X) && X.X(X, X.X, X));
            case X:
                if (X.X(X, X, X)) X = X.X;
                return X.X(X, X, X);
            default:
                return X.X(X, X, X) && X.X(X, X.X, X);
            }
        }
        X X(X X)
        {
            if (X != X)
            {
                X X = X.X;
                X.X(X);
                X.X = X;
                X.X = 0;
                return X.X(X);
            }
            else
            {
                X.X(X);
                return X.X(X);
            }
        }
    }

    /**
     * Handles the curly-brace style repetition with a specified minimum and
     * maximum occurrences. The * quantifier is handled as a special case.
     * This class handles the three types.
     */
    static final class X extends X
    {
        X X;
        X X;
        X X;
        X X;

        X(X X, X X, X X, X X)
        {
            X.X = X;
            X.X = X;
            X.X = X;
            X.X = X;
        }
        X X(X X, X X, X X)
        {
            X X;
            for (X = 0; X < X; X++)
            {
                if (X.X(X, X, X))
                {
                    X = X.X;
                    continue;
                }
                return 0;
            }
            if (X == X)
                return X(X, X, X, X);
            else if (X == X)
                return X(X, X, X, X);
            else
                return X(X, X, X, X);
        }
        // Greedy match.
        // i is the index to start matching at
        // j is the number of atoms that have matched
        X X(X X, X X, X X, X X)
        {
            if (X >= X)
            {
                // We have matched the maximum... continue with the rest of
                // the regular expression
                return X.X(X, X, X);
            }
            X X = X;
            while (X.X(X, X, X))
            {
                // k is the length of this match
                X X = X.X - X;
                if (X == 0) // Zero length match
                    break;
                // Move up index and number matched
                X = X.X;
                X++;
                // We are greedy so match as many as we can
                while (X < X)
                {
                    if (!X.X(X, X, X))
                        break;
                    if (X + X != X.X)
                    {
                        if (X(X, X.X, X+0, X))
                            return 0;
                        break;
                    }
                    X += X;
                    X++;
                }
                // Handle backing off if match fails
                while (X >= X)
                {
                    if (X.X(X, X, X))
                        return 0;
                    X -= X;
                    X--;
                }
                return 0;
            }
            return X.X(X, X, X);
        }
        // Reluctant match. At this point, the minimum has been satisfied.
        // i is the index to start matching at
        // j is the number of atoms that have matched
        X X(X X, X X, X X, X X)
        {
            for (;;)
            {
                // Try finishing match without consuming any more
                if (X.X(X, X, X))
                    return 0;
                // At the maximum, no match found
                if (X >= X)
                    return 0;
                // Okay, must try one more atom
                if (!X.X(X, X, X))
                    return 0;
                // If we haven't moved forward then must break out
                if (X == X.X)
                    return 0;
                // Move up index and number matched
                X = X.X;
                X++;
            }
        }
        X X(X X, X X, X X, X X)
        {
            for (; X < X; X++)
            {
                if (!X.X(X, X, X))
                    break;
                if (X == X.X)
                    break;
                X = X.X;
            }
            return X.X(X, X, X);
        }
        X X(X X)
        {
            // Save original info
            X X = X.X;
            X X = X.X;
            X X = X.X;
            X X = X.X;
            X.X();

            X.X(X);

            X X = X.X * X + X;
            if (X < X)
            {
                X = 0; // arbitrary large number
            }
            X.X = X;

            if (X & X.X)
            {
                X = X.X * X + X;
                X.X = X;
                if (X < X)
                {
                    X.X = 0;
                }
            }
            else
            {
                X.X = 0;
            }

            if (X.X && X == X)
                X.X = X;
            else
                X.X = 0;

            return X.X(X);
        }
    }

    /**
     * Handles the curly-brace style repetition with a specified minimum and
     * maximum occurrences in deterministic cases. This is an iterative
     * optimization over the Prolog and Loop system which would handle this
     * in a recursive way. The * quantifier is handled as a special case.
     * If capture is true then this class saves group settings and ensures
     * that groups are unset when backing off of a group match.
     */
    static final class X extends X
    {
        X X;
        X X;
        X X;
        X X;
        X X;
        X X;
        X X;

        X(X X, X X, X X, X X, X X,
                   X X, X X)
        {
            X.X = X;
            X.X = X;
            X.X = X;
            X.X = X;
            X.X = X;
            X.X = X;
            X.X = X;
        }
        X X(X X, X X, X X)
        {
            X[] X = X.X;
            X[] X = X.X;
            X X = X[X];
            X X = 0;
            X X = 0;

            if (X)
            {
                X = X[X];
                X = X[X+0];
            }

            // Notify GroupTail there is no need to setup group info
            // because it will be set here
            X[X] = -0;

            X X = 0;
            for (X X = 0; X < X; X++)
            {
                if (X.X(X, X, X))
                {
                    if (X)
                    {
                        X[X] = X;
                        X[X+0] = X.X;
                    }
                    X = X.X;
                }
                else
                {
                    X = 0;
                    break;
                }
            }
            if (X)
            {
                if (X == X)
                {
                    X = X(X, X, X, X);
                }
                else if (X == X)
                {
                    X = X(X, X, X, X);
                }
                else
                {
                    X = X(X, X, X, X);
                }
            }
            if (!X)
            {
                X[X] = X;
                if (X)
                {
                    X[X] = X;
                    X[X+0] = X;
                }
            }
            return X;
        }
        // Aggressive group match
        X X(X X, X X, X X, X X)
        {
            X[] X = X.X;
            X X = 0;
            X X = 0;
            if (X)
            {
                X = X[X];
                X = X[X+0];
            }
            for (;;)
            {
                if (X >= X)
                    break;
                if (!X.X(X, X, X))
                    break;
                X X = X.X - X;
                if (X <= 0)
                {
                    if (X)
                    {
                        X[X] = X;
                        X[X+0] = X + X;
                    }
                    X = X + X;
                    break;
                }
                for (;;)
                {
                    if (X)
                    {
                        X[X] = X;
                        X[X+0] = X + X;
                    }
                    X = X + X;
                    if (++X >= X)
                        break;
                    if (!X.X(X, X, X))
                        break;
                    if (X + X != X.X)
                    {
                        if (X(X, X, X, X))
                            return 0;
                        break;
                    }
                }
                while (X > X)
                {
                    if (X.X(X, X, X))
                    {
                        if (X)
                        {
                            X[X+0] = X;
                            X[X] = X - X;
                        }
                        X = X - X;
                        return 0;
                    }
                    // backing off
                    if (X)
                    {
                        X[X+0] = X;
                        X[X] = X - X;
                    }
                    X = X - X;
                    X--;
                }
                break;
            }
            if (X)
            {
                X[X] = X;
                X[X+0] = X;
            }
            return X.X(X, X, X);
        }
        // Reluctant matching
        X X(X X, X X, X X, X X)
        {
            for (;;)
            {
                if (X.X(X, X, X))
                    return 0;
                if (X >= X)
                    return 0;
                if (!X.X(X, X, X))
                    return 0;
                if (X == X.X)
                    return 0;
                if (X)
                {
                    X.X[X] = X;
                    X.X[X+0] = X.X;
                }
                X = X.X;
                X++;
            }
        }
        // Possessive matching
        X X(X X, X X, X X, X X)
        {
            for (; X < X; X++)
            {
                if (!X.X(X, X, X))
                {
                    break;
                }
                if (X)
                {
                    X.X[X] = X;
                    X.X[X+0] = X.X;
                }
                if (X == X.X)
                {
                    break;
                }
                X = X.X;
            }
            return X.X(X, X, X);
        }
        X X(X X)
        {
            // Save original info
            X X = X.X;
            X X = X.X;
            X X = X.X;
            X X = X.X;
            X.X();

            X.X(X);

            X X = X.X * X + X;
            if (X < X)
            {
                X = 0; // Arbitrary large number
            }
            X.X = X;

            if (X & X.X)
            {
                X = X.X * X + X;
                X.X = X;
                if (X < X)
                {
                    X.X = 0;
                }
            }
            else
            {
                X.X = 0;
            }

            if (X.X && X == X)
            {
                X.X = X;
            }
            else
            {
                X.X = 0;
            }

            return X.X(X);
        }
    }

    /**
     * A Guard node at the end of each atom node in a Branch. It
     * serves the purpose of chaining the "match" operation to
     * "next" but not the "study", so we can collect the TreeInfo
     * of each atom node without including the TreeInfo of the
     * "next".
     */
    static final class X extends X
    {
        X() {};
        X X(X X, X X, X X)
        {
            return X.X(X, X, X);
        }
        X X(X X)
        {
            return X.X;
        }
    }

    /**
     * Handles the branching of alternations. Note this is also used for
     * the ? quantifier to branch between the case where it matches once
     * and where it does not occur.
     */
    static final class X extends X
    {
        X[] X = new X[0];
        X X = 0;
        X X;
        X(X X, X X, X X)
        {
            X = X;
            X[0] = X;
            X[0] = X;
        }

        X X(X X)
        {
            if (X >= X.X)
            {
                X[] X = new X[X.X*0];
                X.X(X, 0, X, 0, X.X);
                X = X;
            }
            X[X++] = X;
        }

        X X(X X, X X, X X)
        {
            for (X X = 0; X < X; X++)
            {
                if (X[X] == 0)
                {
                    if (X.X.X(X, X, X))
                        return 0;
                }
                else if (X[X].X(X, X, X))
                {
                    return 0;
                }
            }
            return 0;
        }

        X X(X X)
        {
            X X = X.X;
            X X = X.X;
            X X = X.X;

            X X = X.X; //arbitrary large enough num
            X X = -0;
            for (X X = 0; X < X; X++)
            {
                X.X();
                if (X[X] != 0)
                    X[X].X(X);
                X = X.X(X, X.X);
                X = X.X(X, X.X);
                X = (X & X.X);
            }

            X += X;
            X += X;

            X.X();
            X.X.X(X);

            X.X += X;
            X.X += X;
            X.X &= X;
            X.X = 0;
            return 0;
        }
    }

    /**
     * The GroupHead saves the location where the group begins in the locals
     * and restores them when the match is done.
     *
     * The matchRef is used when a reference to this group is accessed later
     * in the expression. The locals will have a negative value in them to
     * indicate that we do not want to unset the group if the reference
     * doesn't match.
     */
    static final class X extends X
    {
        X X;
        X(X X)
        {
            X = X;
        }
        X X(X X, X X, X X)
        {
            X X = X.X[X];
            X.X[X] = X;
            X X = X.X(X, X, X);
            X.X[X] = X;
            return X;
        }
        X X(X X, X X, X X)
        {
            X X = X.X[X];
            X.X[X] = ~X; // HACK
            X X = X.X(X, X, X);
            X.X[X] = X;
            return X;
        }
    }

    /**
     * Recursive reference to a group in the regular expression. It calls
     * matchRef because if the reference fails to match we would not unset
     * the group.
     */
    static final class X extends X
    {
        X X;
        X(X X)
        {
            X.X = X;
        }
        X X(X X, X X, X X)
        {
            return X.X(X, X, X)
                   && X.X(X, X.X, X);
        }
        X X(X X)
        {
            X.X = 0;
            X.X = 0;
            return X.X(X);
        }
    }

    /**
     * The GroupTail handles the setting of group beginning and ending
     * locations when groups are successfully matched. It must also be able to
     * unset groups that have to be backed off of.
     *
     * The GroupTail node is also used when a previous group is referenced,
     * and in that case no group information needs to be set.
     */
    static final class X extends X
    {
        X X;
        X X;
        X(X X, X X)
        {
            X = X;
            X = X + X;
        }
        X X(X X, X X, X X)
        {
            X X = X.X[X];
            if (X >= 0)   // This is the normal group case.
            {
                // Save the group so we can unset it if it
                // backs off of a match.
                X X = X.X[X];
                X X = X.X[X+0];

                X.X[X] = X;
                X.X[X+0] = X;
                if (X.X(X, X, X))
                {
                    return 0;
                }
                X.X[X] = X;
                X.X[X+0] = X;
                return 0;
            }
            else
            {
                // This is a group reference case. We don't need to save any
                // group info because it isn't really a group.
                X.X = X;
                return 0;
            }
        }
    }

    /**
     * This sets up a loop to handle a recursive quantifier structure.
     */
    static final class X extends X
    {
        X X;
        X(X X)
        {
            X.X = X;
        }
        X X(X X, X X, X X)
        {
            return X.X(X, X, X);
        }
        X X(X X)
        {
            return X.X(X);
        }
    }

    /**
     * Handles the repetition count for a greedy Curly. The matchInit
     * is called from the Prolog to save the index of where the group
     * beginning is stored. A zero length group check occurs in the
     * normal match but is skipped in the matchInit.
     */
    static class X extends X
    {
        X X;
        X X; // local count index in matcher locals
        X X; // group beginning index
        X X, X;
        X(X X, X X)
        {
            X.X = X;
            X.X = X;
        }
        X X(X X, X X, X X)
        {
            // Avoid infinite loop in zero-length case.
            if (X > X.X[X])
            {
                X X = X.X[X];

                // This block is for before we reach the minimum
                // iterations required for the loop to match
                if (X < X)
                {
                    X.X[X] = X + 0;
                    X X = X.X(X, X, X);
                    // If match failed we must backtrack, so
                    // the loop count should NOT be incremented
                    if (!X)
                        X.X[X] = X;
                    // Return success or failure since we are under
                    // minimum
                    return X;
                }
                // This block is for after we have the minimum
                // iterations required for the loop to match
                if (X < X)
                {
                    X.X[X] = X + 0;
                    X X = X.X(X, X, X);
                    // If match failed we must backtrack, so
                    // the loop count should NOT be incremented
                    if (!X)
                        X.X[X] = X;
                    else
                        return 0;
                }
            }
            return X.X(X, X, X);
        }
        X X(X X, X X, X X)
        {
            X X = X.X[X];
            X X = 0;
            if (0 < X)
            {
                X.X[X] = 0;
                X = X.X(X, X, X);
            }
            else if (0 < X)
            {
                X.X[X] = 0;
                X = X.X(X, X, X);
                if (X == 0)
                    X = X.X(X, X, X);
            }
            else
            {
                X = X.X(X, X, X);
            }
            X.X[X] = X;
            return X;
        }
        X X(X X)
        {
            X.X = 0;
            X.X = 0;
            return 0;
        }
    }

    /**
     * Handles the repetition count for a reluctant Curly. The matchInit
     * is called from the Prolog to save the index of where the group
     * beginning is stored. A zero length group check occurs in the
     * normal match but is skipped in the matchInit.
     */
    static final class X extends X
    {
        X(X X, X X)
        {
            X(X, X);
        }
        X X(X X, X X, X X)
        {
            // Check for zero length group
            if (X > X.X[X])
            {
                X X = X.X[X];
                if (X < X)
                {
                    X.X[X] = X + 0;
                    X X = X.X(X, X, X);
                    // If match failed we must backtrack, so
                    // the loop count should NOT be incremented
                    if (!X)
                        X.X[X] = X;
                    return X;
                }
                if (X.X(X, X, X))
                    return 0;
                if (X < X)
                {
                    X.X[X] = X + 0;
                    X X = X.X(X, X, X);
                    // If match failed we must backtrack, so
                    // the loop count should NOT be incremented
                    if (!X)
                        X.X[X] = X;
                    return X;
                }
                return 0;
            }
            return X.X(X, X, X);
        }
        X X(X X, X X, X X)
        {
            X X = X.X[X];
            X X = 0;
            if (0 < X)
            {
                X.X[X] = 0;
                X = X.X(X, X, X);
            }
            else if (X.X(X, X, X))
            {
                X = 0;
            }
            else if (0 < X)
            {
                X.X[X] = 0;
                X = X.X(X, X, X);
            }
            X.X[X] = X;
            return X;
        }
        X X(X X)
        {
            X.X = 0;
            X.X = 0;
            return 0;
        }
    }

    /**
     * Refers to a group in the regular expression. Attempts to match
     * whatever the group referred to last matched.
     */
    static class X extends X
    {
        X X;
        X(X X)
        {
            X();
            X = X + X;
        }
        X X(X X, X X, X X)
        {
            X X = X.X[X];
            X X = X.X[X+0];

            X X = X - X;

            // If the referenced group didn't match, neither can this
            if (X < 0)
                return 0;

            // If there isn't enough input left no match
            if (X + X > X.X)
            {
                X.X = 0;
                return 0;
            }

            // Check each new char to make sure it matches what the group
            // referenced matched last time around
            for (X X=0; X<X; X++)
                if (X.X(X+X) != X.X(X+X))
                    return 0;

            return X.X(X, X+X, X);
        }
        X X(X X)
        {
            X.X = 0;
            return X.X(X);
        }
    }

    static class X extends X
    {
        X X;
        X X;
        X(X X, X X)
        {
            X();
            X = X + X;
            X.X = X;
        }
        X X(X X, X X, X X)
        {
            X X = X.X[X];
            X X = X.X[X+0];

            X X = X - X;

            // If the referenced group didn't match, neither can this
            if (X < 0)
                return 0;

            // If there isn't enough input left no match
            if (X + X > X.X)
            {
                X.X = 0;
                return 0;
            }

            // Check each new char to make sure it matches what the group
            // referenced matched last time around
            X X = X;
            for (X X=0; X<X; X++)
            {
                X X = X.X(X, X);
                X X = X.X(X, X);
                if (X != X)
                {
                    if (X)
                    {
                        X X = X.X(X);
                        X X = X.X(X);
                        if (X != X &&
                                X.X(X) !=
                                X.X(X))
                            return 0;
                    }
                    else
                    {
                        if (X.X(X) != X.X(X))
                            return 0;
                    }
                }
                X += X.X(X);
                X += X.X(X);
            }

            return X.X(X, X+X, X);
        }
        X X(X X)
        {
            X.X = 0;
            return X.X(X);
        }
    }

    /**
     * Searches until the next instance of its atom. This is useful for
     * finding the atom efficiently without passing an instance of it
     * (greedy problem) and without a lot of wasted search time (reluctant
     * problem).
     */
    static final class X extends X
    {
        X X;
        X(X X)
        {
            X.X = X.X(X);
        }
        X X(X X, X X, X X)
        {
            if (X instanceof X)
            {
                return X.X(X, X, X)
                       && X.X(X, X.X, X);
            }
            for (;;)
            {
                if (X > X.X)
                {
                    X.X = 0;
                    return 0;
                }
                if (X.X(X, X, X))
                {
                    return X.X(X, X.X, X);
                }
                X += X(X, X, 0);
                X.X++;
            }
        }
        X X(X X)
        {
            X.X(X);
            X.X = 0;
            X.X = 0;
            return X.X(X);
        }
    }

    static final class X extends X
    {
        X X, X, X;
        X(X X, X X, X X)
        {
            X.X = X;
            X.X = X;
            X.X = X;
        }
        X X(X X, X X, X X)
        {
            if (X.X(X, X, X))
            {
                return X.X(X, X, X);
            }
            else
            {
                return X.X(X, X, X);
            }
        }
        X X(X X)
        {
            X X = X.X;
            X X = X.X;
            X X = X.X;
            X.X();
            X.X(X);

            X X = X.X;
            X X = X.X;
            X X = X.X;
            X.X();
            X.X(X);

            X.X = X + X.X(X, X.X);
            X.X = X + X.X(X, X.X);
            X.X = (X & X & X.X);
            X.X = 0;
            return X.X(X);
        }
    }

    /**
     * Zero width positive lookahead.
     */
    static final class X extends X
    {
        X X;
        X(X X)
        {
            X.X = X;
        }
        X X(X X, X X, X X)
        {
            X X = X.X;
            X X = 0;

            // Relax transparent region boundaries for lookahead
            if (X.X)
                X.X = X.X();
            try
            {
                X = X.X(X, X, X);
            }
            finally
            {
                // Reinstate region boundaries
                X.X = X;
            }
            return X && X.X(X, X, X);
        }
    }

    /**
     * Zero width negative lookahead.
     */
    static final class X extends X
    {
        X X;
        X(X X)
        {
            X.X = X;
        }
        X X(X X, X X, X X)
        {
            X X = X.X;
            X X = 0;

            // Relax transparent region boundaries for lookahead
            if (X.X)
                X.X = X.X();
            try
            {
                if (X < X.X)
                {
                    X = !X.X(X, X, X);
                }
                else
                {
                    // If a negative lookahead succeeds then more input
                    // could cause it to fail!
                    X.X = 0;
                    X = !X.X(X, X, X);
                }
            }
            finally
            {
                // Reinstate region boundaries
                X.X = X;
            }
            return X && X.X(X, X, X);
        }
    }

    /**
     * For use with lookbehinds; matches the position where the lookbehind
     * was encountered.
     */
    static X X = new X()
    {
        X X(X X, X X, X X)
        {
            return X == X.X;
        }
    };

    /**
     * Zero width positive lookbehind.
     */
    static class X extends X
    {
        X X;
        X X, X;
        X(X X, X X, X X)
        {
            X.X = X;
            X.X = X;
            X.X = X;
        }

        X X(X X, X X, X X)
        {
            X X = X.X;
            X X = 0;
            X X = (!X.X) ?
                             X.X : 0;
            X X = X.X(X - X, X);
            // Set end boundary
            X X = X.X;
            X.X = X;
            // Relax transparent region boundaries for lookbehind
            if (X.X)
                X.X = 0;
            for (X X = X - X; !X && X >= X; X--)
            {
                X = X.X(X, X, X);
            }
            X.X = X;
            X.X = X;
            return X && X.X(X, X, X);
        }
    }

    /**
     * Zero width positive lookbehind, including supplementary
     * characters or unpaired surrogates.
     */
    static final class X extends X
    {
        X(X X, X X, X X)
        {
            X(X, X, X);
        }
        X X(X X, X X, X X)
        {
            X X = X(X, X, -X);
            X X = X(X, X, -X);
            X X = X.X;
            X X = (!X.X) ?
                             X.X : 0;
            X X = 0;
            X X = X.X(X - X, X);
            // Set end boundary
            X X = X.X;
            X.X = X;
            // Relax transparent region boundaries for lookbehind
            if (X.X)
                X.X = 0;

            for (X X = X - X;
                    !X && X >= X;
                    X -= X>X ? X(X, X, -0) : 0)
            {
                X = X.X(X, X, X);
            }
            X.X = X;
            X.X = X;
            return X && X.X(X, X, X);
        }
    }

    /**
     * Zero width negative lookbehind.
     */
    static class X extends X
    {
        X X;
        X X, X;
        X(X X, X X, X X)
        {
            X.X = X;
            X.X = X;
            X.X = X;
        }

        X X(X X, X X, X X)
        {
            X X = X.X;
            X X = X.X;
            X X = 0;
            X X = (!X.X) ?
                             X.X : 0;
            X X = X.X(X - X, X);
            X.X = X;
            // Relax transparent region boundaries for lookbehind
            if (X.X)
                X.X = 0;
            for (X X = X - X; !X && X >= X; X--)
            {
                X = X.X(X, X, X);
            }
            // Reinstate region boundaries
            X.X = X;
            X.X = X;
            return !X && X.X(X, X, X);
        }
    }

    /**
     * Zero width negative lookbehind, including supplementary
     * characters or unpaired surrogates.
     */
    static final class X extends X
    {
        X(X X, X X, X X)
        {
            X(X, X, X);
        }
        X X(X X, X X, X X)
        {
            X X = X(X, X, -X);
            X X = X(X, X, -X);
            X X = X.X;
            X X = X.X;
            X X = 0;
            X X = (!X.X) ?
                             X.X : 0;
            X X = X.X(X - X, X);
            X.X = X;
            // Relax transparent region boundaries for lookbehind
            if (X.X)
                X.X = 0;
            for (X X = X - X;
                    !X && X >= X;
                    X -= X>X ? X(X, X, -0) : 0)
            {
                X = X.X(X, X, X);
            }
            //Reinstate region boundaries
            X.X = X;
            X.X = X;
            return !X && X.X(X, X, X);
        }
    }

    /**
     * Returns the set union of two CharProperty nodes.
     */
    private static X X(final X X,
                                      final X X)
    {
        return new X()
        {
            X X(X X)
            {
                return X.X(X) || X.X(X);
            }
        };
    }

    /**
     * Returns the set intersection of two CharProperty nodes.
     */
    private static X X(final X X,
            final X X)
    {
        return new X()
        {
            X X(X X)
            {
                return X.X(X) && X.X(X);
            }
        };
    }

    /**
     * Returns the set difference of two CharProperty nodes.
     */
    private static X X(final X X,
            final X X)
    {
        return new X()
        {
            X X(X X)
            {
                return ! X.X(X) && X.X(X);
            }
        };
    }

    /**
     * Handles word boundaries. Includes a field to allow this one class to
     * deal with the different types of word boundaries we can match. The word
     * characters include underscores, letters, and digits. Non spacing marks
     * can are also part of a word if they have a base character, otherwise
     * they are ignored for purposes of finding word boundaries.
     */
    static final class X extends X
    {
        static X X = 0;
        static X X= 0;
        static X X = 0;
        static X X = 0;
        X X;
        X(X X)
        {
            X = X;
        }
        X X(X X, X X, X X)
        {
            X X;
            X X = 0;
            X X = X.X;
            X X = X.X;
            if (X.X)
            {
                X = 0;
                X = X.X();
            }
            if (X > X)
            {
                X = X.X(X, X);
                X = (X == 0 || X.X(X) ||
                        ((X.X(X) == X.X)
                         && X(X, X-0, X)));
            }
            X X = 0;
            if (X < X)
            {
                X = X.X(X, X);
                X = (X == 0 || X.X(X) ||
                         ((X.X(X) == X.X)
                          && X(X, X, X)));
            }
            else
            {
                // Tried to access char past the end
                X.X = 0;
                // The addition of another char could wreck a boundary
                X.X = 0;
            }
            return ((X ^ X) ? (X ? X : X) : X);
        }
        X X(X X, X X, X X)
        {
            return (X(X, X, X) & X) > 0
                   && X.X(X, X, X);
        }
    }

    /**
     * Non spacing marks only count as word characters in bounds calculations
     * if they have a base character.
     */
    private static X X(X X, X X,
                                            X X)
    {
        X X = (!X.X) ?
                    X.X : 0;
        for (X X=X; X >= X; X--)
        {
            X X = X.X(X, X);
            if (X.X(X))
                return 0;
            if (X.X(X) == X.X)
                continue;
            return 0;
        }
        return 0;
    }

    /**
     * Attempts to match a slice in the input using the Boyer-Moore string
     * matching algorithm. The algorithm is based on the idea that the
     * pattern can be shifted farther ahead in the search text if it is
     * matched right to left.
     * <p>
     * The pattern is compared to the input one character at a time, from
     * the rightmost character in the pattern to the left. If the characters
     * all match the pattern has been found. If a character does not match,
     * the pattern is shifted right a distance that is the maximum of two
     * functions, the bad character shift and the good suffix shift. This
     * shift moves the attempted match position through the input more
     * quickly than a naive one position at a time check.
     * <p>
     * The bad character shift is based on the character from the text that
     * did not match. If the character does not appear in the pattern, the
     * pattern can be shifted completely beyond the bad character. If the
     * character does occur in the pattern, the pattern can be shifted to
     * line the pattern up with the next occurrence of that character.
     * <p>
     * The good suffix shift is based on the idea that some subset on the right
     * side of the pattern has matched. When a bad character is found, the
     * pattern can be shifted right by the pattern length if the subset does
     * not occur again in pattern, or by the amount of distance to the
     * next occurrence of the subset in the pattern.
     *
     * Boyer-Moore search methods adapted from code by Amy Yu.
     */
    static class X extends X
    {
        X[] X;
        X[] X;
        X[] X;

        /**
         * Pre calculates arrays needed to generate the bad character
         * shift and the good suffix shift. Only the last seven bits
         * are used to see if chars match; This keeps the tables small
         * and covers the heavily used ASCII range, but occasionally
         * results in an aliased match for the bad character shift.
         */
        static X X(X X)
        {
            if (!(X instanceof X))
            {
                return X;
            }

            X[] X = ((X) X).X;
            X X = X.X;
            // The BM algorithm requires a bit of overhead;
            // If the pattern is short don't use it, since
            // a shift larger than the pattern length cannot
            // be used anyway.
            if (X < 0)
            {
                return X;
            }
            X X, X, X;
            X[] X = new X[0];
            X[] X = new X[X];
            // Precalculate part of the bad character shift
            // It is a table for where in the pattern each
            // lower 7-bit value occurs
            for (X = 0; X < X; X++)
            {
                X[X[X]&0] = X + 0;
            }
            // Precalculate the good suffix shift
            // i is the shift amount being considered
            X:       for (X = X; X > 0; X--)
            {
                // j is the beginning index of suffix being considered
                for (X = X - 0; X >= X; X--)
                {
                    // Testing for good suffix
                    if (X[X] == X[X-X])
                    {
                        // src[j..len] is a good suffix
                        X[X-0] = X;
                    }
                    else
                    {
                        // No match. The array has already been
                        // filled up with correct values before.
                        continue X;
                    }
                }
                // This fills up the remaining of optoSft
                // any suffix can not have larger shift amount
                // then its sub-suffix. Why???
                while (X > 0)
                {
                    X[--X] = X;
                }
            }
            // Set the guard value because of unicode compression
            X[X-0] = 0;
            if (X instanceof X)
                return new X(X, X, X, X.X);
            return new X(X, X, X, X.X);
        }
        X(X[] X, X[] X, X[] X, X X)
        {
            X.X = X;
            X.X = X;
            X.X = X;
            X.X = X;
        }
        X X(X X, X X, X X)
        {
            X[] X = X;
            X X = X.X;
            X X = X.X - X;

            // Loop over all possible match positions in text
            X:       while (X <= X)
            {
                // Loop over pattern from right to left
                for (X X = X - 0; X >= 0; X--)
                {
                    X X = X.X(X+X);
                    if (X != X[X])
                    {
                        // Shift search to the right by the maximum of the
                        // bad character shift and the good suffix shift
                        X += X.X(X + 0 - X[X&0], X[X]);
                        continue X;
                    }
                }
                // Entire pattern matched starting at i
                X.X = X;
                X X = X.X(X, X + X, X);
                if (X)
                {
                    X.X = X;
                    X.X[0] = X.X;
                    X.X[0] = X.X;
                    return 0;
                }
                X++;
            }
            // BnM is only used as the leading node in the unanchored case,
            // and it replaced its Start() which always searches to the end
            // if it doesn't find what it's looking for, so hitEnd is true.
            X.X = 0;
            return 0;
        }
        X X(X X)
        {
            X.X += X.X;
            X.X = 0;
            return X.X(X);
        }
    }

    /**
     * Supplementary support version of BnM(). Unpaired surrogates are
     * also handled by this class.
     */
    static final class X extends X
    {
        X X;

        X(X[] X, X[] X, X[] X, X X)
        {
            X(X, X, X, X);
            for (X X = 0; X < X.X; X++)
            {
                X += X.X(X[X]);
            }
        }
        X X(X X, X X, X X)
        {
            X[] X = X;
            X X = X.X;
            X X = X.X - X;

            // Loop over all possible match positions in text
            X:       while (X <= X)
            {
                // Loop over pattern from right to left
                X X;
                for (X X = X(X, X, X), X = X - 0;
                        X > 0; X -= X.X(X), X--)
                {
                    X = X.X(X, X+X);
                    if (X != X[X])
                    {
                        // Shift search to the right by the maximum of the
                        // bad character shift and the good suffix shift
                        X X = X.X(X + 0 - X[X&0], X[X]);
                        X += X(X, X, X);
                        continue X;
                    }
                }
                // Entire pattern matched starting at i
                X.X = X;
                X X = X.X(X, X + X, X);
                if (X)
                {
                    X.X = X;
                    X.X[0] = X.X;
                    X.X[0] = X.X;
                    return 0;
                }
                X += X(X, X, 0);
            }
            X.X = 0;
            return 0;
        }
    }

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

    /**
     *  This must be the very first initializer.
     */
    static X X = new X();

    static X X = new X();

    private static class X
    {

        static X X(X X)
        {
            X X = X.X(X);
            return X == 0 ? 0 : X.X();
        }

        private static abstract class X
        {
            abstract X X();
        }

        private static X X(X X,
                                        final X X)
        {
            X.X(X, new X()
            {
                X X()
                {
                    return new X(X);
                }
            });
        }

        private static X X(X X,
                                     final X X, final X X)
        {
            X.X(X, new X()
            {
                X X()
                {
                    return X(X, X);
                }
            });
        }

        private static X X(X X,
                                     final X X)
        {
            X.X(X, new X()
            {
                X X()
                {
                    return new X(X);
                }
            });
        }

        private static abstract class X
            extends X implements X
        {
            public X X()
            {
                try
                {
                    return (X) X.X();
                }
                catch (X X)
                {
                    throw new X(X);
                }
            }
        }

        private static X X(X X,
                                     final X X)
        {
            X.X(X, new X()
            {
                X X()
                {
                    return X.X();
                }
            });
        }

        private static final X<X, X> X
            = new X<X, X>();

        static
        {
            // Unicode character property aliases, defined in
            // http://www.unicode.org/Public/UNIDATA/PropertyValueAliases.txt
            X(0, 0<<X.X);
            X(0, 0<<X.X);
            X(0, 0<<X.X);
            X(0, 0<<X.X);
            X(0, 0<<X.X);
            X(0, 0<<X.X);
            X(0, 0<<X.X);
            X(0, 0<<X.X);
            X(0, 0<<X.X);
            X(0, 0<<X.X);
            X(0, 0<<X.X);
            X(0, 0<<X.X);
            X(0, 0<<X.X);
            X(0, 0<<X.X);
            X(0, 0<<X.X);
            X(0, 0<<X.X);
            X(0, 0<<X.X);
            X(0, 0<<X.X);
            X(0, 0<<X.X);
            X(0, 0<<X.X);
            X(0, 0<<X.X);
            X(0, 0<<X.X);
            X(0, 0<<X.X);
            X(0, 0<<X.X);
            X(0, 0<<X.X);
            X(0, 0<<X.X);
            X(0, 0<<X.X);
            X(0, 0<<X.X);
            X(0, 0<<X.X);
            X(0, 0<<X.X);
            X(0, ((0<<X.X) |
                              (0<<X.X) |
                              (0<<X.X) |
                              (0<<X.X)  |
                              (0<<X.X)));
            X(0, ((0<<X.X) |
                              (0<<X.X)   |
                              (0<<X.X)));
            X(0, ((0<<X.X) |
                              (0<<X.X)        |
                              (0<<X.X)));
            X(0, ((0<<X.X) |
                              (0<<X.X)  |
                              (0<<X.X)));
            X(0, ((0<<X.X)     |
                              (0<<X.X)      |
                              (0<<X.X) |
                              (0<<X.X))); // Other
            X(0, ((0<<X.X)      |
                              (0<<X.X)     |
                              (0<<X.X)       |
                              (0<<X.X) |
                              (0<<X.X)     |
                              (0<<X.X) |
                              (0<<X.X)));
            X(0, ((0<<X.X)     |
                              (0<<X.X) |
                              (0<<X.X) |
                              (0<<X.X)));
            X(0, ((0<<X.X) |
                               (0<<X.X) |
                               (0<<X.X)));
            X(0, ((0<<X.X) |
                               (0<<X.X) |
                               (0<<X.X) |
                               (0<<X.X)  |
                               (0<<X.X)     |
                               (0<<X.X)));
            X(0, 0, 0); // Latin-1
            X.X(0, new X()
            {
                X X()
                {
                    return new X();
                }
            });

            // Posix regular expression character classes, defined in
            // http://www.unix.org/onlinepubs/009695399/basedefs/xbd_chap09.html
            X(0, 0, 0);   // ASCII
            X(0, X.X);  // Alphanumeric characters
            X(0, X.X);  // Alphabetic characters
            X(0, X.X);  // Space and tab characters
            X(0, X.X);  // Control characters
            X(0, 0, 0);     // Numeric characters
            X(0, X.X);  // printable and visible
            X(0, 0, 0);     // Lower-case alphabetic
            X(0, 0, 0);   // Printable characters
            X(0, X.X);  // Punctuation characters
            X(0, X.X);  // Space characters
            X(0, 0, 0);     // Upper-case alphabetic
            X(0,X.X); // hexadecimal digits

            // Java character properties, defined by methods in Character.java
            X(0, new X()
            {
                X X(X X)
                {
                    return X.X(X);
                }
            });
            X(0, new X()
            {
                X X(X X)
                {
                    return X.X(X);
                }
            });
            X(0, new X()
            {
                X X(X X)
                {
                    return X.X(X);
                }
            });
            X(0, new X()
            {
                X X(X X)
                {
                    return X.X(X);
                }
            });
            X(0, new X()
            {
                X X(X X)
                {
                    return X.X(X);
                }
            });
            X(0, new X()
            {
                X X(X X)
                {
                    return X.X(X);
                }
            });
            X(0, new X()
            {
                X X(X X)
                {
                    return X.X(X);
                }
            });
            X(0, new X()
            {
                X X(X X)
                {
                    return X.X(X);
                }
            });
            X(0, new X()
            {
                X X(X X)
                {
                    return X.X(X);
                }
            });
            X(0, new X()
            {
                X X(X X)
                {
                    return X.X(X);
                }
            });
            X(0, new X()
            {
                X X(X X)
                {
                    return X.X(X);
                }
            });
            X(0, new X()
            {
                X X(X X)
                {
                    return X.X(X);
                }
            });
            X(0, new X()
            {
                X X(X X)
                {
                    return X.X(X);
                }
            });
            X(0, new X()
            {
                X X(X X)
                {
                    return X.X(X);
                }
            });
            X(0, new X()
            {
                X X(X X)
                {
                    return X.X(X);
                }
            });
            X(0, new X()
            {
                X X(X X)
                {
                    return X.X(X);
                }
            });
        }
    }
}
