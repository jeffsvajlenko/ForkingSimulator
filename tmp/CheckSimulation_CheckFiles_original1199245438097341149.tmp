/*
 * %W% %E%
 *
 * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
 * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 */

package X.X.X.X.X;

import X.X.X.X;
import X.X.X.X.X;
import X.X.*;
import X.X.*;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X.X;
import X.X.X.X;
import X.X.X.X;

/**
 * This class represents a default implementation for
 * <code>javax.security.auth.login.Configuration</code>.
 *
 * <p> This object stores the runtime login configuration representation,
 * and is the amalgamation of multiple static login
 * configurations that resides in files.
 * The algorithm for locating the login configuration file(s) and reading their
 * information into this <code>Configuration</code> object is:
 *
 * <ol>
 * <li>
 *   Loop through the <code>java.security.Security</code> properties,
 *   <i>login.config.url.1</i>, <i>login.config.url.2</i>, ...,
 *   <i>login.config.url.X</i>.  These properties are set
 *   in the Java security properties file, which is located in the file named
 *   &lt;JAVA_HOME&gt;/lib/security/java.security.
 *   &lt;JAVA_HOME&gt; refers to the value of the java.home system property,
 *   and specifies the directory where the JRE is installed.
 *   Each property value specifies a <code>URL</code> pointing to a
 *   login configuration file to be loaded.  Read in and load
 *   each configuration.
 *
 * <li>
 *   The <code>java.lang.System</code> property
 *   <i>java.security.auth.login.config</i>
 *   may also be set to a <code>URL</code> pointing to another
 *   login configuration file
 *   (which is the case when a user uses the -D switch at runtime).
 *   If this property is defined, and its use is allowed by the
 *   security property file (the Security property,
 *   <i>policy.allowSystemProperty</i> is set to <i>true</i>),
 *   also load that login configuration.
 *
 * <li>
 *   If the <i>java.security.auth.login.config</i> property is defined using
 *   "==" (rather than "="), then ignore all other specified
 *   login configurations and only load this configuration.
 *
 * <li>
 *   If no system or security properties were set, try to read from the file,
 *   ${user.home}/.java.login.config, where ${user.home} is the value
 *   represented by the "user.home" System property.
 * </ol>
 *
 * <p> The configuration syntax supported by this implementation
 * is exactly that syntax specified in the
 * <code>javax.security.auth.login.Configuration</code> class.
 *
 * @version %I%, %G%
 * @see javax.security.auth.login.LoginContext
 */
public class X extends X.X.X.X.X
{

    private X X;
    private X X;
    private X X;
    private X X;
    private X X = 0;
    private X X;

    private static X X = X.X(0);
    private static X X = X.X(0);

    /**
     * Create a new <code>Configuration</code> object.
     */
    public X()
    {
        try
        {
            X(X);
        }
        catch (X X)
        {
            throw (X)
            new X(X.X()).X(X);
        }
    }

    /**
     * Create a new <code>Configuration</code> object from the specified URI.
     *
     * @param uri Create a new Configuration object from this URI.
     */
    public X(X X)
    {
        // only load config from the specified URI
        try
        {
            X = X.X();
            X(X);
        }
        catch (X X)
        {
            throw (X)
            new X(X.X()).X(X);
        }
        catch (X X)
        {
            throw (X)
            new X(X.X()).X(X);
        }
    }

    /**
     * Read and initialize the entire login Configuration.
     *
     * <p>
     *
     * @exception IOException if the Configuration can not be initialized. <p>
     * @exception SecurityException if the caller does not have permission
     *				to initialize the Configuration.
     */
    private X X(X X) throws X
    {

        X X = 0;
        X X = 0;
        X X = X.X;

        if (0.X(X.X(0)))
        {
            X = 0;
        }

        // new configuration
        X X = new X();

        if (X != 0)
        {

            /**
             * If the caller specified a URI via Configuration.getInstance,
             * we only read from that URI
             */
            if (X != 0)
            {
                X.X(0 + X);
            }
            X(X, X);
            X = X;
            return;
        }

        /**
         * Caller did not specify URI via Configuration.getInstance.
         * Read from URLs listed in the java.security properties file.
         */

        X X = X.X.X.X
                          (0);

        if (0.X(X))
        {
            X X = X.X
                                  (0);
            if (X != 0)
            {
                X X = 0;
                if (X.X(0))
                {
                    X = 0;
                    X = X.X(0);
                }
                try
                {
                    X = X.X(X);
                }
                catch (X.X X)
                {
                    X X = new X
                    (X.X
                     (0,
                      0));
                    X[] X = {X};
                    throw new X(X.X(X));
                }

                X X = 0;
                try
                {
                    X = new X(X);
                }
                catch (X.X.X X)
                {
                    X X = new X(X);
                    if (X.X())
                    {
                        X = new X(0 +
                                            X.X());
                    }
                    else
                    {
                        X X = new X
                        (X.X
                         (0,
                          0));
                        X[] X = {X};
                        throw new X(X.X(X));
                    }
                }

                if (X != 0)
                {
                    X.X(0+X);
                }
                X(X, X);
                X = 0;
                if (X)
                {
                    if (X != 0)
                    {
                        X.X(0);
                    }
                    X = X;
                    return;
                }
            }
        }

        X X = 0;
        X X;
        while ((X = X.X.X.X
                             (0+X)) != 0)
        {
            try
            {
                X = X.X
                             (X).X(X.X, 0);
                if (X != 0)
                {
                    X.X(0 + X);
                }
                X(new X(X), X);
                X = 0;
            }
            catch (X.X X)
            {
                X X = new X
                (X.X
                 (0,
                  0));
                X[] X = {X};
                throw new X(X.X(X));
            }
            X++;
        }

        if (X == 0 && X == 0 && X == 0)
        {

            // get the config from the user's home directory
            if (X != 0)
            {
                X.X(0 +
                                    0);
            }
            X = X.X(0);
            try
            {
                X(new X(0 + X +
                             X.X + 0),
                     X);
            }
            catch (X X)
            {
                throw new X(X.X
                                      (0,
                                       0));
            }
        }

        X = X;
    }

    private X X(X X, X X) throws X
    {
        X X
            = new X(X(X), 0);
        X(X, X);
        X.X();
    }

    /**
     * Retrieve an entry from the Configuration using an application name
     * as an index.
     *
     * <p>
     *
     * @param applicationName the name used to index the Configuration.
     * @return an array of AppConfigurationEntries which correspond to
     *		the stacked configuration of LoginModules for this
     *		application, or null if this application has no configured
     *		LoginModules.
     */
    public X[] X
    (X X)
    {

        X X = 0;
        synchronized (X)
        {
            X = (X)X.X(X);
        }

        if (X == 0 || X.X() == 0)
            return 0;

        X[] X =
            new X[X.X()];
        X X = X.X();
        for (X X = 0; X.X(); X++)
        {
            X X = (X)X.X();
            X[X] = new X(X.X(),
                                                   X.X(),
                                                   X.X());
        }
        return X;
    }

    /**
     * Refresh and reload the Configuration by re-reading all of the
     * login configurations.
     *
     * <p>
     *
     * @exception SecurityException if the caller does not have permission
     *				to refresh the Configuration.
     */
    public synchronized X X()
    {

        X.X.X X = X.X();
        if (X != 0)
            X.X(new X(0));

        X.X.X.X
        (new X.X.X()
        {
            public X X()
            {
                try
                {
                    X(X);
                }
                catch (X.X.X X)
                {
                    throw (X) new X
                    (X.X()).X(X);
                }
                return 0;
            }
        });
    }

    private X X(X X, X X)
    throws X
    {

        X X = 0;

        if (!(X instanceof X))
            X = new X(X);

        X = new X(X);
        X.X(0);
        X.X(0, 0);
        X.X(0, 0);
        X.X(0, 0);
        X.X(0);
        X.X(0);
        X.X(0);
        X.X(0);

        X = X();
        while (X != X.X)
        {
            X(X);
        }
    }

    private X X(X X) throws X
    {

        X X;
        X X;
        X X;
        X.X X;
        X X = new X();

        // application name
        X = X.X;
        X = X();

        if (X != 0)
        {
            X.X(0 + X);
        }

        X(0);

        // get the modules
        while (X(0) == 0)
        {
            X X = new X();

            // get the module class name
            X = X(0);

            // controlFlag (required, optional, etc)
            X = X(0);
            if (X.X(0))
                X =
                    X.X.X;
            else if (X.X(0))
                X =
                    X.X.X;
            else if (X.X(0))
                X =
                    X.X.X;
            else if (X.X(0))
                X =
                    X.X.X;
            else
            {
                X X = new X(X.X
                                                       (0,
                                                        0));
                X[] X = {X};
                throw new X(X.X(X));
            }

            // get the args
            X X = new X();
            X X;
            X X;
            while (X(0) == 0)
            {
                X = X(0);
                X(0);
                try
                {
                    X = X(X(0));
                }
                catch (X.X X)
                {
                    throw new X(X.X());
                }
                X.X(X, X);
            }

            X = X();

            // create the new element
            if (X != 0)
            {
                X.X(0 + X + 0 + X);
                X.X.X X = X.X().X();
                while (X.X())
                {
                    X = (X)X.X();
                    X.X(0 +
                                        X +
                                        0 +
                                        (X)X.X(X));
                }
            }
            X X = new X
            (X,
             X,
             X);
            X.X(X);
        }

        X(0);
        X(0);

        // add this configuration entry
        if (X.X(X))
        {
            X X = new X(X.X
                                                   (0 +
                                                    0,
                                                    0));
            X[] X = {X};
            throw new X(X.X(X));
        }
        X.X(X, X);
    }

    private X X(X X) throws X
    {

        X X = 0;

        switch(X)
        {
        case X.X:

            X X = new X(X.X
                                                    (0 +
                                                            0,
                                                            0));
            X[] X = {X};
            throw new X(X.X(X));

        case 0:
        case X.X:

            if (X.X(0) ||
                    X.X(0) ||
                    X.X(0) ||
                    X.X(0))
            {
                X = X.X;
                X = X();
            }
            else
            {
                X X = new X(X.X
                                                       (0 +
                                                        0,
                                                        0));
                X[] X = {new X(X), X, X.X};
                throw new X(X.X(X));
            }
            break;

        case 0:

            if (X.X(0))
            {
                X = X();
            }
            else
            {
                X X = new X(X.X
                                                       (0,
                                                        0));
                X[] X = {new X(X), X, X.X};
                throw new X(X.X(X));
            }
            break;

        case 0:

            if (X.X(0))
            {
                X = X();
            }
            else
            {
                X X = new X(X.X
                                                       (0,
                                                        0));
                X[] X = {new X(X), X, X.X};
                throw new X(X.X(X));
            }
            break;

        case 0:

            if (X.X(0))
            {
                X = X();
            }
            else
            {
                X X = new X(X.X
                                                       (0,
                                                        0));
                X[] X = {new X(X), X, X.X};
                throw new X(X.X(X));
            }
            break;

        case 0:

            if (X.X(0))
            {
                X = X();
            }
            else
            {
                X X = new X(X.X
                                                       (0,
                                                        0));
                X[] X = {new X(X), X, X.X};
                throw new X(X.X(X));
            }
            break;

        default:
            X X = new X(X.X
                                                   (0 +
                                                    0,
                                                    0));
            X[] X = {new X(X), X, X.X};
            throw new X(X.X(X));
        }
        return X;
    }

    private X X(X X)
    {
        X X = 0;

        switch (X)
        {
        case 0:
            if (X.X(0))
                X = 0;
            break;
        case 0:
            if (X.X(0))
                X = 0;
            break;
        case 0:
            if (X.X(0))
                X = 0;
            break;
        case 0:
            if (X.X(0))
                X = 0;
            break;
        default:
        }
        return X;
    }

    private X X() throws X
    {
        X X;
        while ((X = X.X()) == X.X)
        {
            X++;
        }
        return X;
    }

    /*
     * Fast path reading from file urls in order to avoid calling
     * FileURLConnection.connect() which can be quite slow the first time
     * it is called. We really should clean up FileURLConnection so that
     * this is not a problem but in the meantime this fix helps reduce
     * start up time noticeably for the new launcher. -- DAC
     */
    private X X(X X) throws X
    {
        if (0.X(X.X()))
        {
            X X = X.X().X(0, X.X);
            return new X(X);
        }
        else
        {
            return X.X();
        }
    }

    private X X(X X)
    throws X.X, X
    {

        if (0.X(X))
        {
            return X;
        }

        if (X)
        {

            X X = X.X(X);

            if (X == 0 || X.X() == 0)
            {
                X X = new X(X.X
                                                       (0 +
                                                        0,
                                                        0));
                X[] X = {new X(X), X};
                throw new X(X.X(X));
            }
            return X;
        }
        else
        {
            return X;
        }
    }
}
