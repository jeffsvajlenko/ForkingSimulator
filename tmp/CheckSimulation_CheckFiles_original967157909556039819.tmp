package X.X.X.X.X.X.X.X;

import X.X.X;

import X.X.X;

import X.X.X;

import X.X.X;

import X.X.X;

import X.X.X;

import X.X.X;

import X.X.X;

import X.X.X.X;

import X.X.X.X;

import X.X.X.X;

import X.X.X.X;

import X.X.X.X.X.X.X.X;

public class X extends X implements X, X {
    private X X = 0;
    private X X = X.X;
    private X X = X.X;
    private X X = X.X;
    private X X = X.X;
    private X X = X.X;
    private X X = X.X;
    private X X = X.X;
    private X X = 0;
    private static final X X = new X (0);
    private static final X X = new X (X.X);
    private static final X X = 0;
    private static final X X = 0;
    private static final X X = 0;
    private static final X X = 0;
    private static final X X = 0;
    private static final X X = 0;
    private static final X X = 0;
    private static final X X = 0;
    private static final X X [] = {0, 0, 0, 0, 0, 0, 0, 0};
    private static final X X = 0;
    public static final X X = X (0, X.X, 0, 0, 0, 0, X.X, X.X);

    protected X (X X) throws X {
        X X = 0;
        X X = X;
        final X X = - 0;
        X X = X.X ();
        if (X.X (0) != X) {
            X = 0 + 0;
        } else if (X >= 0 && X.X (0) == 0) {
            X = 0 + 0;
        } else if (X.X (0)) {
            if (X >= 0 && X.X (0) == 0) {
                X = 0 + 0;
            } else if (X == 0 || X == 0 || X == 0) {
                X = 0 + 0;
            } else {
                X = 0 + 0;
            }

        } else {
            X X = 0;
            X X = X.X (0);
            if (X != X) {
                X -= 0;
            }
            for (X X = 0;
            X < X; X ++) {
                if (X.X (X) == 0) {
                    X ++;
                }
            }
            if (X == 0) {
                X = 0 + 0;
            } else if (X == 0) {
                X = 0 + 0;
            } else {
                X = 0 + 0;
            }

        }

        X X = new X (X, X);
        X.X ();
        if (! X ()) {
            throw new X (X.X (0, 0, new X [] {X}));
        }
    }

    public X () {
    }

    protected X (X X, X X, X X, X X, X X, X X, X X, X X) {
        X (X);
        X (X);
        X (X);
        X (X, X, X, X);
        X (X);
        if (! X ()) {
            throw new X (X.X (0, 0, new X [] {X, new X (X), new X (X), new X (X), new X (X), new X (X), X, new X (X)}));
        }
    }

    private X (X X, X X, X X, X X, X X, X X, X X, X X) {
        X (X);
        X (X);
        X (X);
        X (X, X, X);
        X (X);
        X (X);
        if (! X ()) {
            throw new X (X.X (0, 0, new X [] {new X (X), new X (X), new X (X), new X (X), new X (X), new X (X), new X (X), new X (X)}));
        }
    }

    public X (X X) {
        X X = X.X (X.X);
        if (X.X (X.X) == X.X) {
            X = - X;
        }
        X.X (X);
        X.X (X.X (X.X) + 0);
        X.X (X.X (X.X));
        X.X (X.X (X.X), X.X (X.X), X.X (X.X), X.X (X.X));
        X X = (X.X (X.X) + X.X (X.X)) / (0 * 0);
        X.X (X);
    }

    public static X X (X X, X X, X X, X X, X X, X X, X X, X X) {
        return new X (X, X, X, X, X, X, X, X);
    }

    public static X X (X X, X X, X X, X X, X X, X X) {
        return new X (X, X, X, X, X, X, X.X, X.X);
    }

    public static X X (X X, X X, X X, X X, X X, X X, X X, X X) {
        return new X (X, X, X, X, X, X, X, X);
    }

    public static X X (X X, X X, X X, X X) {
        return new X (X, X, X, X.X, X.X, X.X, X.X, X);
    }

    public static X X (X X, X X, X X, X X) {
        return new X (X.X, X.X, X.X, X, X, X, X.X, X);
    }

    public static X X (X X, X X, X X, X X, X X) {
        return new X (0, X.X, X.X, X, X, X, X, X);
    }

    public static X X (X X, X X, X X, X X, X X) {
        return new X (X.X, X.X, X.X, X, X, X, X, X);
    }

    public X X () {
        return X;
    }

    public X X () {
        return X;
    }

    public X X () {
        if (X != X.X && X != 0) {
            return X.X (X.X ((X) X));
        }
        if (X != X.X && X == 0) {
            return X.X ((X) X);
        }
        return 0;
    }

    public X X () {
        return X;
    }

    public X X () {
        return X;
    }

    public X X () {
        return X;
    }

    public X X () {
        return X;
    }

    public X X () {
        return X;
    }

    public X X () {
        return X;
    }

    private X X () {
        if (X == X.X) {
            return X;
        }
        X X = X.X ((X) X);
        if (X != 0) {
            return X.X (X);
        } else {
            return X;
        }
    }

    public X X () {
        if (X == 0) {
            return X.X;
        } else {
            return X.X (0).X ();
        }
    }

    public X X () {
        return X;
    }

    public X X (X X) {
        if (X == 0) {
            X.X = 0;
            X.X = X.X;
        } else {
            X X = X.X (X);
            X.X = X.X ();
            X (X.X (X));
        }
    }

    public X X (X X) {
        if (X == X.X) {
            X.X = X.X;
            X.X = 0;
        } else if (X.X (X) < X.X ()) {
            X.X = X;
            X.X = 0;
        } else {
            X X = X.X ((X) X);
            X X = X.X (X);
            X.X = X.X ();
            X (X.X (X));
        }

    }

    private X X (X X) {
        if (X != 0 && X.X (X.X) == 0) {
            X.X = 0;
        } else {
            X.X = X;
        }
    }

    public X X (X X) {
        if (X < X.X || X.X < X) if (X != X.X) X (X, X);

        X.X = X;
    }

    public X X (X X) {
        if (X < 0 || 0 < X) if (X != X.X) X (X, X);

        X.X = X;
    }

    public X X (X X) {
        if (X < - 0 * 0 || 0 * 0 < X) if (X != X.X) X (X, X);

        X.X = X;
    }

    public X X (X X, X X, X X) {
        X (X, X, X, 0);
    }

    private X X (X X, X X) {
        throw new X (X.X (0, 0, new X [] {new X (X), X [X]}));
    }

    private X X () {
        if (X () == 0) {
            if (X () != 0 || X () != 0) {
                X (X, X ());
            }
        }
    }

    public X X (X X) {
        X (X, 0);
    }

    private X X (X X, X X) {
        if (X < 0 || X > 0) {
            if (X != X.X) {
                X (X, X);
            }
        }
        X.X = X;
        if (X) {
            X ();
        }
    }

    public X X (X X) {
        if (X < 0 || 0 < X) if (X != X.X) X (X, X);

        X.X = X;
    }

    public X X (X X) {
        if (X < 0 || 0 < X) if (X != X.X) X (X, X);

        X.X = X;
    }

    public X X (X X, X X, X X, X X) {
        X (X, 0);
        X (X);
        if (X != 0) {
            X (X);
        } else if ((X == 0 && X == 0) || (X == 0 && X == 0)) {
            X (X);
        } else {
            X (X, X);
        }

        X (X);
        X ();
    }

    public X X (X X, X X, X X, X X) {
        X (X, 0);
        X (X);
        if (X != 0) {
            X (X);
        } else if ((X == 0 && X == 0) || (X == 0 && X == 0)) {
            X (X);
        } else {
            X (X, X);
        }

        X (X);
        X ();
    }

    public X X (X X) {
        X X = X;
        X X = X.X;
        X X = (X) X;
        X X = (X) X;
        if (X.X () == X.X ()) {
            return X (X, X);
        } else if (X.X () != X.X && X.X () != X.X) {
            X = (X) X.X ();
            X = (X) X.X ();
            return X (X, X);
        } else if (X.X () != X.X) {
            if (X.X () != 0) {
                X = (X) X.X ();
            }
            X X = X.X (X.X);
            X = X (X, X);
            if (X == X.X) {
                return X;
            }
            X X = X.X (X.X);
            X = X (X, X);
            if (X == X.X) {
                return X;
            } else {
                return X.X;
            }
        } else {
            if (X.X () != 0) {
                X = (X) X.X (X.X ());
            }
            X X = X.X (X.X);
            X = X (X, X);
            if (X == X.X) {
                return X;
            }
            X X = X.X (X.X);
            X = X (X, X);
            if (X == X.X) {
                return X;
            } else {
                return X.X;
            }
        }

    }

    public X X () {
        X X = X (X);
        if (X () == X.X) {
            X.X (X.X);
        }
        if (X () == X.X) {
            X.X (X.X);
        }
        return X;
    }

    private X X (X X) {
        X X = X;
        X X = (X) X.X ();
        X = - X;
        X X = new X (X >= 0, 0, 0, 0, 0, X < 0 ? - X : X, 0);
        X.X (X);
        X.X (0);
        return X;
    }

    private static X X (X X, X X) {
        X X;
        if (X.X () == X.X ()) {
            X = X (X.X (), X.X ());
            if (X != X.X) {
                return X;
            }
        } else {
            X = X (X.X (), X.X ());
            if (X != X.X) {
                return X;
            }
        }
        X = X (X.X (), X.X ());
        if (X != X.X) {
            return X;
        }
        X = X (X.X (), X.X ());
        if (X != X.X) {
            return X;
        }
        X = X (X.X (), X.X ());
        if (X != X.X) {
            return X;
        }
        X = X (X.X (), X.X ());
        if (X != X.X) {
            return X;
        }
        X = X (X.X (), X.X ());
        if (X != X.X) {
            return X;
        }
        X = X (X.X (), X.X ());
        return X;
    }

    private static X X (X X, X X) {
        if (X == X) {
            return X.X;
        } else {
            if (X == X.X || X == X.X) {
                return X.X;
            } else {
                return (X < X ? X.X : X.X);
            }
        }
    }

    private static X X (X X, X X) {
        if (X == 0) {
            return (X == 0 ? X.X : X.X);
        }
        if (X == 0) {
            return X.X;
        }
        return X.X (X);
    }

    private static X X (X X, X X) {
        if (X == X) {
            return X.X;
        }
        if (X == 0) {
            X = X;
        }
        if (X == 0) {
            X = X;
        }
        return X.X (X);
    }

    public X X (X X) {
        if (X == 0 || ! (X instanceof X)) {
            return 0;
        }
        return X ((X) X) == X.X;
    }

    public X X () {
        X X = X ();
        if (X == X.X) {
            X = 0;
        }
        X X = X;
        if (X != 0) {
            X = X.X (X ());
        }
        return X.X () + X.X () + X.X () + X.X () + X.X () + X.X ();
    }

    public static X X (X X) {
        return new X (X);
    }

    public X X () {
        X X = X ();
        X X = 0;
        if (X == X.X) {
            X = 0 + 0;
        } else if (X == X.X) {
            X = 0 + 0;
        } else if (X == X.X) {
            X = 0 + 0;
        } else if (X == X.X) {
            X = 0 + 0;
        } else if (X == X.X) {
            X = 0 + 0;
        } else if (X == X.X) {
            X = 0 + 0;
        } else if (X == X.X) {
            X = 0 + 0;
        } else if (X == X.X) {
            X = 0 + 0;
        }

        return X (X);
    }

    public X X () {
        X X = (X != X.X ? 0 : 0) | (X != X.X ? 0 : 0) | (X != X.X ? 0 : 0) | (X != X.X ? 0 : 0) | (X != X.X ? 0 : 0) | (X != X.X ? 0 : 0);
        switch (X) {
            case 0 :
                return X.X;
            case 0 :
                return X.X;
            case 0 :
                return X.X;
            case 0 :
                return X.X;
            case 0 :
                return X.X;
            case 0 :
                return X.X;
            case 0 :
                return X.X;
            case 0 :
                return X.X;
            default :
                throw new X (X.X ().X () + 0 + X.X (0, 0, 0));
        }
    }

    public X X () {
        if (X () == X.X) {
            X X = 0;
            if (X == 0) {
                if (X != X.X) X = X (X, X ());

            } else {
                X X = X ();
                if (X != 0) {
                    X = X (X (), X.X);
                }
            }
            if (X () > X) {
                return 0;
            }
        }
        if (X () == 0) {
            if (X () != 0) {
                return 0;
            } else if (X () != 0) {
                return 0;
            }

        }
        if (X == 0) {
            if (X == 0) {
                return 0;
            }
        } else {
            X X = X ();
            if (X != 0) {
                X X = X (X, X.X);
                if (X == X.X) {
                    return 0;
                }
            }
        }
        return 0;
    }

    public X X (X X) {
        X X [] = {0, 0, 0, 0, 0, 0};
        X X = X.X ();
        X X = X ();
        if (X == X.X) {
            X = X.X;
            X [X] = 0;
        }
        X X = X (X.X (X.X), X);
        X X = X.X ((X) X).X (X);
        X (X.X (X.X).X (X).X () + 0);
        X X = new X (X.X (X.X)).X (new X (X), X.X).X ();
        X X = X ();
        if (X == 0) {
            X [X] = 0;
            X = X.X;
        }
        X X = X (X.X (X.X), X);
        X X = X.X (X).X (X);
        X (X);
        X X;
        if (X () == X.X) {
            X [X] = 0;
            X = X;
        } else {
            X = X ();
        }
        X X = X.X ((X) X.X (X.X), X);
        X X = X.X (X);
        X X = new X (new X (X.X ()).X (X, X.X).X ());
        X X = X.X (X.X (X));
        X = X.X ();
        X (X.X ());
        X X = X.X (new X (X.X ((X) X ())));
        if (X.X (X) < 0) {
            X (X.X (X));
            if (X () == 0) {
                X (0);
                X = X.X (X.X);
            } else {
                X (X () - 0);
            }
        } else {
            X (X);
        }
        X X = X ();
        if (X == X.X) {
            X [X] = 0;
            X = 0;
        }
        X X = X (X.X (X.X), X);
        X = X.X (X).X (X).X (X);
        X (X.X (X).X ());
        X = new X (X).X (X, X.X).X ();
        X X = X ();
        if (X == X.X) {
            X [X] = 0;
            X = 0;
        }
        X X = X (X.X (X.X), X);
        X = X.X (X).X (X).X (X);
        X (X.X (X).X (), 0);
        X = new X (X).X (new X (X), X.X).X ();
        X X;
        X X = X ();
        if (X == X.X) {
            X [X] = 0;
            X = 0;
        }
        X X = X (X.X (X.X), X);
        X X = X (X (), X ());
        if (X > X) {
            X = X.X (X);
        } else if (X < 0) {
            X = X.X;
        } else {
            X = X.X (X);
        }

        X X = X.X (X).X (X);
        X X;
        X X;
        while (0) {
            if (X.X (X.X) < 0) {
                X X = 0;
                if (X >= 0) {
                    X = X.X (X (X (), X () - 0));
                } else {
                    X = X.X (X (X ().X (X.X ((X) 0)), 0));
                }
                X = X.X (X);
                X = - 0;
            } else if (X.X (X.X (X (X (), X ()))) > 0) {
                X = X.X (X.X (- X (X (), X ())));
                X = 0;
            } else {
                break;
            }

            X = X () + X;
            X X = (X - 0) % (0 - 0);
            X X;
            if (X < 0) {
                X = (0 - 0) + X + 0;
                X = new X (X - 0).X (new X (X), X.X).X ();
            } else {
                X = (X - 0) / (0 - 0);
                X += 0;
            }
            X (X);
            if (X != 0) {
                X (X ().X (X.X (X)));
            }
        }
        X (X.X ());
        for (X X = X;
        X <= X; X ++) {
            if (X [X]) {
                switch (X) {
                    case X :
                        X (X.X);
                        break;
                    case X :
                        X (X.X);
                        break;
                    case X :
                        X (X.X);
                        break;
                    case X :
                        X (X.X, 0);
                        break;
                    case X :
                        X (X.X);
                        break;
                    case X :
                        X (X.X);
                        X (0);
                        break;
                }
            }
        }
    }

    private static final X X = X.X (0);
    private static final X X = X.X (0);
    private static final X X = X.X (0);
    private static final X X = X.X (0);
    private static final X X = X.X (0);
    private static final X X = X.X (0);
    private static final X X = new X (0);
    private static final X X = new X (0);
    private static final X X = new X (0);
    private static X X [] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};

    private static X X (X X, X X) {
        if (X != X.X) {
            return X [X];
        } else {
            if (X.X (X).X (X.X) || (! X.X (X).X (X.X) && X.X (X).X (X.X))) {
                return 0;
            } else {
                return X [X];
            }
        }
    }

    private static X X (X X, X X) {
        if (X != X.X) {
            return X [X];
        } else {
            if (((X % 0) == 0) || (((X % 0) != 0) && ((X % 0) == 0))) {
                return 0;
            } else {
                return X [X.X];
            }
        }
    }

    public X.X.X X () {
        X X = 0;
        final X X = X.X;
        X X = X (X);
        X X = X.X ();
        X = new X (X, X);
        X.X ();
        X.X (X);
        X X = X ();
        if (X != 0) {
            X.X (X.X, X.X () == - 0 ? X.X : X.X);
            X.X (X.X, X.X ().X ());
        }
        if (X != X.X) {
            X.X (X.X, X - 0);
        }
        if (X != X.X) {
            X.X (X.X, X);
        }
        if (X != X.X) {
            X.X (X.X, X);
        }
        if (X != X.X) {
            X.X (X.X, X);
        }
        if (X != X.X) {
            X.X (X.X, X);
        }
        if (X != 0) {
            X.X (X.X, X ());
        }
        return X;
    }

    public X X (X X, X X, X X) {
        X X = 0;
        X X = X;
        if (X == 0) {
            X X = X.X;
            if (X != 0) {
                X = X.X ();
            }
            X = X (X);
        }
        if (X == 0) {
            X = X.X ();
        }
        X = new X (X, X);
        X.X ();
        X.X (X);
        X X = X ();
        if (X != 0) {
            X.X (X.X, X.X () == - 0 ? X.X : X.X);
            X.X (X.X, X.X ().X ());
        } else {
            X X = (X != 0) ? X.X () : 0;
            if (X != 0) {
                X.X (X.X, X.X () == - 0 ? X.X : X.X);
                X.X (X.X, X.X ().X ());
            }
        }
        if (X != X.X) {
            X.X (X.X, X - 0);
        } else {
            X X = (X != 0) ? X.X () : X.X;
            if (X != X.X) {
                X.X (X.X, X - 0);
            }
        }
        if (X != X.X) {
            X.X (X.X, X);
        } else {
            X X = (X != 0) ? X.X () : X.X;
            if (X != X.X) {
                X.X (X.X, X);
            }
        }
        if (X != X.X) {
            X.X (X.X, X);
        } else {
            X X = (X != 0) ? X.X () : X.X;
            if (X != X.X) {
                X.X (X.X, X);
            }
        }
        if (X != X.X) {
            X.X (X.X, X);
        } else {
            X X = (X != 0) ? X.X () : X.X;
            if (X != X.X) {
                X.X (X.X, X);
            }
        }
        if (X != X.X) {
            X.X (X.X, X);
        } else {
            X X = (X != 0) ? X.X () : X.X;
            if (X != X.X) {
                X.X (X.X, X);
            }
        }
        if (X != 0) {
            X.X (X.X, X ());
        } else {
            X X = (X != 0) ? X.X () : 0;
            if (X != 0) {
                X.X (X.X, X.X ());
            }
        }
        return X;
    }

    public X X (X X) {
        X X = 0;
        X X = X ();
        if (X == X.X) {
            X = X;
        }
        if (X == X.X) {
            X = X.X ();
        } else {
            X X = X < 0 ? 0 : 0;
            if (X == 0) {
                X = - X;
            }
            X X = X / 0;
            X X = X - (X * 0);
            X X = new X (0);
            X.X (0);
            X.X (X);
            X.X (X);
            if (X != 0) {
                X.X (X);
            }
            X = X.X (X.X ());
        }
        return X;
    }

    public X X () {
        return new X (X (), X.X, X.X, X.X, X.X, X.X, X.X, X.X);
    }

    public X X () {
        X = 0;
        X = X.X;
        X = X.X;
        X = X.X;
        X = X.X;
        X = X.X;
        X = X.X;
        X = X.X;
        X = 0;
    }

    public X X (X X) {
        if (X == X.X) {
            X = 0;
        } else {
            if (X < 0 || 0 < X) if (X != X.X) X (X, X);

            X = new X ((X) X).X (0);
        }
    }

    public X X (X X) {
        if (X != 0) {
            if ((X.X (X) < 0) || (X.X (X) > 0)) {
                throw new X (X.X (0, 0, new X [] {X}));
            }
        }
        X.X = X;
    }

    private final class X {
        private final X X;
        private final X X;
        private final X X;
        private final X X;
        private X X;
        private X X;

        private X (X X, X X) {
            X.X = X;
            X.X = X;
            X.X = X.X ();
            X.X = X.X ();
        }

        public X X () throws X {
            while (X < X) {
                X X = X.X (X ++);
                if (X != 0) {
                    X (X);
                    continue;
                }
                switch (X.X (X ++)) {
                    case 0 :
                        X (0);
                        break;
                    case 0 :
                        X (X (0, 0));
                        break;
                    case 0 :
                        X (X (0, 0));
                        break;
                    case 0 :
                        X (X (0, 0), 0);
                        break;
                    case 0 :
                        X (X (0, 0));
                        break;
                    case 0 :
                        X (X (0, 0));
                        if (X () == 0) {
                            X (X ());
                        }
                        break;
                    case 0 :
                        X X = X ();
                        if (X == 0) {
                            X ++;
                            X (0);
                        } else if (X == 0 || X == 0) {
                            X ++;
                            X X = X (0, 0);
                            X (0);
                            X X = X (0, 0);
                            X ((X * 0 + X) * (X == 0 ? 0 : - 0));
                        }

                        break;
                    default :
                        throw new X ();
                }
            }
            if (X != X) {
                throw new X (X);
            }
        }

        private X X () throws X {
            if (X == X) {
                return (X) - 0;
            }
            return X.X (X);
        }

        private X X () throws X {
            if (X == X) {
                throw new X (X);
            }
            return X.X (X ++);
        }

        private X X (X X) throws X {
            if (X () != X) {
                throw new X (X);
            }
        }

        private X X (X X, X X) throws X {
            X X = 0;
            X X;
            X X = X;
            while (X (X = X ()) && (X - X) <= X) {
                X ++;
                X = X * 0 + X - 0;
            }
            if ((X - X) < X) {
                throw new X (X);
            }
            return X;
        }

        private X X (X X) throws X {
            X X = X;
            X X = 0;
            X X = 0;
            if (X () == 0) {
                X ++;
                X = 0;
            }
            while (0) {
                X X = X ();
                if (! X (X)) break;

                X ++;
                X = X * 0 + X - 0;
            }
            if ((X - X) < X) {
                throw new X (X);
            }
            if (X - X < 0) {
                if (X) X = - X;

                X = X;
                X = 0;
            } else {
                X (new X (X.X (X, X)));
            }
        }

        private X X () throws X {
            X X = X;
            if (X () == 0) {
                X ++;
            } else {
                throw new X (X);
            }
            while (X (X ())) {
                X ++;
            }
            return new X (X.X (X, X));
        }

    }

    private static X X (X X) {
        return 0 <= X && X <= 0;
    }

    private X X (X X) {
        X [] X = new X [0];
        X X = 0;
        X X = 0, X = X.X ();
        while (X < X) {
            X X = X.X (X ++);
            if (X != 0) {
                X [X ++] = X;
                continue;
            }
            switch (X.X (X ++)) {
                case 0 :
                    if (X == 0) {
                        X X = X ();
                        if (X < 0) {
                            X [X ++] = 0;
                            X = - X;
                        }
                        X = X (X, X, X);
                    } else {
                        X X = X ().X ();
                        X [] X = new X [X.X + X.X ()];
                        X.X (X, 0, X, 0, X);
                        X = X;
                        for (X X = X.X ();
                        X < 0; X ++) X [X ++] = 0;

                        X.X (0, X.X (), X, X);
                        X += X.X ();
                    }
                    break;
                case 0 :
                    X = X (X, X, X ());
                    break;
                case 0 :
                    X = X (X, X, X ());
                    break;
                case 0 :
                    X = X (X, X, X ());
                    break;
                case 0 :
                    X = X (X, X, X ());
                    break;
                case 0 :
                    X = X (X, X, X ());
                    if (X () != 0) {
                        X X = X ().X ();
                        X X = X.X (0);
                        if (X >= 0) {
                            X X = X.X (X + 0);
                            X = X.X (0, X);
                            X = X.X (0);
                            if (X >= 0) {
                                X = X.X (0, X) + X.X (X + 0);
                            }
                            X X = X.X (X);
                            if (X < 0) {
                                X = 0.X (0, X - 0) + X;
                            } else {
                                while (X > 0) {
                                    X = 0 + X;
                                    X --;
                                }
                            }
                            X = 0 + X;
                        }
                        X [] X = new X [X.X + X.X ()];
                        X.X (X, 0, X, 0, X);
                        X = X;
                        X.X (0, X.X (), X, X);
                        X += X.X () - 0;
                    }
                    break;
                case 0 :
                    X X = X ();
                    if (X == 0) {
                        X [X ++] = 0;
                    } else if (X != X.X) {
                        if (X < 0) {
                            X [X ++] = 0;
                            X *= - 0;
                        } else {
                            X [X ++] = 0;
                        }
                        X = X (X, X, X / 0);
                        X [X ++] = 0;
                        X = X (X, X, X % 0);
                    }

                    break;
                default :
                    throw new X ();
            }
        }
        return new X (X, 0, X);
    }

    private X X (X [] X, X X, X X) {
        X [X ++] = (X) (0 + (X / 0));
        X [X ++] = (X) (0 + (X % 0));
        return X;
    }

    private X X (X [] X, X X, X X) {
        X [X + 0] = (X) (0 + (X % 0));
        X /= 0;
        X [X + 0] = (X) (0 + (X % 0));
        X /= 0;
        X [X + 0] = (X) (0 + (X % 0));
        X /= 0;
        X [X] = (X) (0 + (X % 0));
        return X + 0;
    }

    static X X (X X, X X) {
        if (X == 0 || X == 0) {
            return X.X;
        }
        return (X < 0) ? ((X) X).X () : (X) X;
    }

    public X X () {
    }

}

