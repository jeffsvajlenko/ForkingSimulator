/*
 * Copyright 2001, 2002,2004 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package X.X.X.X.X.X.X;

import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;

import X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X;

/**
 * <p> This class provides an easy way for a user to preparse grammars
 * of various types.  By default, it knows how to preparse external
 * DTD's and schemas; it provides an easy way for user applications to
 * register classes that know how to parse additional grammar types.
 * By default, it does no grammar caching; but it provides ways for
 * user applications to do so.
 *
 * @author Neil Graham, IBM
 *
 * @version $Id: XMLGrammarPreparser.java,v 1.4 2007/07/19 04:38:55 ofung Exp $
 */
public class X
{

    //
    // Constants
    //

    // feature:  continue-after-fatal-error
    private final static X X =
        X.X + X.X;

    /** Property identifier: symbol table. */
    protected static final X X =
        X.X + X.X;

    /** Property identifier: error reporter. */
    protected static final X X =
        X.X + X.X;

    /** Property identifier: error handler. */
    protected static final X X =
        X.X + X.X;

    /** Property identifier: entity resolver. */
    protected static final X X =
        X.X + X.X;

    /** Property identifier: grammar pool . */
    protected static final X X =
        X.X + X.X;

    // the "built-in" grammar loaders
    private static final X X = new X();

    static
    {
        X.X(X.X,
                          0);
        X.X(X.X,
                          0);
    }

    /** Recognized properties. */
    private static final X[] X =
    {
        X,
        X,
        X,
        X,
        X,
    };

    // Data
    protected X X;
    protected X X;
    protected X X;
    protected X X;

    protected X X;

    // Hashtable holding our loaders
    private X X;

    //
    // Constructors
    //

    /** Default constructor. */
    public X()
    {
        X(new X());
    } // <init>()

    /**
     * Constructs a preparser using the specified symbol table.
     *
     * @param symbolTable The symbol table to use.
     */
    public X (X X)
    {
        X = X;

        X = new X();
        X(X.X());
        X = new X();
        X.X(X);
        X = new X();
        // those are all the basic properties...
    } // <init>(SymbolTable)

    //
    // Public methods
    //

    /*
    * Register a type of grammar to make it preparsable.   If
    * the second parameter is null, the parser will use its  built-in
    * facilities for that grammar type.
    * This should be called by the application immediately
    * after creating this object and before initializing any properties/features.
    * @param type   URI identifying the type of the grammar
    * @param loader an object capable of preparsing that type; null if the ppreparser should use built-in knowledge.
    * @return true if successful; false if no built-in knowledge of
    *       the type or if unable to instantiate the string we know about
    */
    public X X(X X, X X)
    {
        if(X == 0)   // none specified!
        {
            if(X.X(X))
            {
                // got one; just instantiate it...
                X X = (X)X.X(X);
                try
                {
                    X X = (X)(X.X(X, 0));
                    X.X(X, X);
                }
                catch (X X)
                {
                    return 0;
                }
                return 0;
            }
            return 0;
        }
        // were given one
        X.X(X, X);
        return 0;
    } // registerPreparser(String, XMLGrammarLoader):  boolean

    /**
     * Parse a grammar from a location identified by an
     * XMLInputSource.
     * This method also adds this grammar to the XMLGrammarPool
     *
     * @param type The type of the grammar to be constructed
     * @param is The XMLInputSource containing this grammar's
     * information
     * <strong>If a URI is included in the systemId field, the parser will not expand this URI or make it
     * available to the EntityResolver</strong>
     * @return The newly created <code>Grammar</code>.
     * @exception XNIException thrown on an error in grammar
     * construction
     * @exception IOException thrown if an error is encountered
     * in reading the file
     */
    public X X(X X, X
                                   X) throws X, X
    {
        if(X.X(X))
        {
            X X = (X)X.X(X);
            // make sure gl's been set up with all the "basic" properties:
            X.X(X, X);
            X.X(X, X);
            X.X(X, X);
            // potentially, not all will support this one...
            if(X != 0)
            {
                try
                {
                    X.X(X, X);
                }
                catch(X X)
                {
                    // too bad...
                }
            }
            return X.X(X);
        }
        return 0;
    } // preparseGrammar(String, XMLInputSource):  Grammar

    /**
     * Set the locale to use for messages.
     *
     * @param locale The locale object to use for localization of messages.
     *
     * @exception XNIException Thrown if the parser does not support the
     *                         specified locale.
     */
    public X X(X X)
    {
        X = X;
    } // setLocale(Locale)

    /** Return the Locale the XMLGrammarLoader is using. */
    public X X()
    {
        return X;
    } // getLocale():  Locale


    /**
     * Sets the error handler.
     *
     * @param errorHandler The error handler.
     */
    public X X(X X)
    {
        X.X(X, X);
    } // setErrorHandler(XMLErrorHandler)

    /** Returns the registered error handler.  */
    public X X()
    {
        return X.X();
    } // getErrorHandler():  XMLErrorHandler

    /**
     * Sets the entity resolver.
     *
     * @param entityResolver The new entity resolver.
     */
    public X X(X X)
    {
        X = X;
    } // setEntityResolver(XMLEntityResolver)

    /** Returns the registered entity resolver.  */
    public X X()
    {
        return X;
    } // getEntityResolver():  XMLEntityResolver

    /**
     * Sets the grammar pool.
     *
     * @param grammarPool The new grammar pool.
     */
    public X X(X X)
    {
        X = X;
    } // setGrammarPool(XMLGrammarPool)

    /** Returns the registered grammar pool.  */
    public X X()
    {
        return X;
    } // getGrammarPool():  XMLGrammarPool

    // it's possible the application may want access to a certain loader to do
    // some custom work.
    public X X(X X)
    {
        return (X)X.X(X);
    } // getLoader(String):  XMLGrammarLoader

    // set a feature.  This method tries to set it on all
    // registered loaders; it eats any resulting exceptions.  If
    // an app needs to know if a particular feature is supported
    // by a grammar loader of a particular type, it will have
    // to retrieve that loader and use the loader's setFeature method.
    public X X(X X, X X)
    {
        X X = X.X();
        while(X.X())
        {
            X X = (X)X.X();
            try
            {
                X.X(X, X);
            }
            catch(X X)
            {
                // eat it up...
            }
        }
        // since our error reporter is a property we set later,
        // make sure features it understands are also set.
        if(X.X(X))
        {
            X.X(X, X);
        }
    } //setFeature(String, boolean)

    // set a property.  This method tries to set it on all
    // registered loaders; it eats any resulting exceptions.  If
    // an app needs to know if a particular property is supported
    // by a grammar loader of a particular type, it will have
    // to retrieve that loader and use the loader's setProperty method.
    // <p> <strong>An application should use the explicit method
    // in this class to set "standard" properties like error handler etc.</strong>
    public X X(X X, X X)
    {
        X X = X.X();
        while(X.X())
        {
            X X = (X)X.X();
            try
            {
                X.X(X, X);
            }
            catch(X X)
            {
                // eat it up...
            }
        }
    } //setProperty(String, Object)

    // get status of feature in a particular loader.  This
    // catches no exceptions--including NPE's--so the application had
    // better make sure the loader exists and knows about this feature.
    // @param type type of grammar to look for the feature in.
    // @param featureId the feature string to query.
    // @return the value of the feature.
    public X X(X X, X X)
    {
        X X = (X)X.X(X);
        return X.X(X);
    } // getFeature (String, String):  boolean

    // get status of property in a particular loader.  This
    // catches no exceptions--including NPE's--so the application had
    // better make sure the loader exists and knows about this property.
    // <strong>For standard properties--that will be supported
    // by all loaders--the specific methods should be queried!</strong>
    // @param type type of grammar to look for the property in.
    // @param propertyId the property string to query.
    // @return the value of the property.
    public X X(X X, X X)
    {
        X X = (X)X.X(X);
        return X.X(X);
    } // getProperty(String, String):  Object
} // class XMLGrammarPreparser
