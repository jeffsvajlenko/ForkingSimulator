/*
 * Copyright 1999-2002,2004 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


package X.X.X.X.X.X.X;


import X.X.X;
import X.X.X;
import X.X.X;


/**
 * Extends {@link Printer} and adds support for indentation and line
 * wrapping.
 *
 * @version $Revision: 1.4 $ $Date: 2007/07/19 04:39:19 $
 * @author <a href="mailto:arkin@intalio.com">Assaf Arkin</a>
 */
public class X
    extends X
{


    /**
     * Holds the currently accumulating text line. This buffer will constantly
     * be reused by deleting its contents instead of reallocating it.
     */
    private X    X;


    /**
     * Holds the currently accumulating text that follows {@link #_line}.
     * When the end of the part is identified by a call to {@link #printSpace}
     * or {@link #breakLine}, this part is added to the accumulated line.
     */
    private X    X;


    /**
     * Counts how many white spaces come between the accumulated line and the
     * current accumulated text. Multiple spaces at the end of the a line
     * will not be printed.
     */
    private X             X;


    /**
     * Holds the indentation for the current line that is now accumulating in
     * memory and will be sent for printing shortly.
     */
    private X             X;


    /**
     * Holds the indentation for the next line to be printed. After this line is
     * printed, {@link #_nextIndent} is assigned to {@link #_thisIndent}.
     */
    private X             X;


    public X( X X, X X)
    {
        X( X, X );
        // Initialize everything for a first/second run.
        X = new X( 0 );
        X = new X( 0 );
        X = 0;
        X = X = 0;
    }


    /**
     * Called by any of the DTD handlers to enter DTD mode.
     * Once entered, all output will be accumulated in a string
     * that can be printed as part of the document's DTD.
     * This method may be called any number of time but will only
     * have affect the first time it's called. To exist DTD state
     * and get the accumulated DTD, call {@link #leaveDTD}.
     */
    public X X()
    {
        // Can only enter DTD state once. Once we're out of DTD
        // state, can no longer re-enter it.
        if ( X == 0 )
        {
            X.X( X );
            X = new X( 0 );
            X( 0 );
            X = new X();
            X = X;
            X = X;
        }
    }


    /**
     * Called by the root element to leave DTD mode and if any
     * DTD parts were printer, will return a string with their
     * textual content.
     */
    public X X()
    {
        // Only works if we're going out of DTD mode.
        if ( X == X )
        {
            X.X( X );
            X = new X( 0 );
            X( 0 );
            X = X;
            return X.X();
        }
        else
            return 0;
    }


    /**
     * Called to print additional text. Each time this method is called
     * it accumulates more text. When a space is printed ({@link
     * #printSpace}) all the accumulated text becomes one part and is
     * added to the accumulate line. When a line is long enough, it can
     * be broken at its text boundary.
     *
     * @param text The text to print
     */
    public X X( X X )
    {
        X.X( X );
    }


    public X X( X X )
    {
        X.X( X.X() );
    }


    public X X( X X )
    {
        X.X( X );
    }


    public X X( X[] X, X X, X X )
    {
        X.X( X, X, X );
    }


    /**
     * Called to print a single space between text parts that may be
     * broken into separate lines. Must not be called to print a space
     * when preserving spaces. The text accumulated so far with {@link
     * #printText} will be added to the accumulated line, and a space
     * separator will be counted. If the line accumulated so far is
     * long enough, it will be printed.
     */
    public X X()
    {
        // The line consists of the text accumulated in _line,
        // followed by one or more spaces as counted by _spaces,
        // followed by more space accumulated in _text:
        // -  Text is printed and accumulated into _text.
        // -  A space is printed, so _text is added to _line and
        //    a space is counted.
        // -  More text is printed and accumulated into _text.
        // -  A space is printed, the previous spaces are added
        //    to _line, the _text is added to _line, and a new
        //    space is counted.

        // If text was accumulated with printText(), then the space
        // means we have to move that text into the line and
        // start accumulating new text with printText().
        if ( X.X() > 0 )
        {
            // If the text breaks a line bounary, wrap to the next line.
            // The printed line size consists of the indentation we're going
            // to use next, the accumulated line so far, some spaces and the
            // accumulated text so far.
            if ( X.X() > 0 &&
                    X + X.X() + X + X.X() > X.X() )
            {
                X( 0 );
                try
                {
                    // Print line and new line, then zero the line contents.
                    X.X( X.X() );
                }
                catch ( X X )
                {
                    // We don't throw an exception, but hold it
                    // until the end of the document.
                    if ( X == 0 )
                        X = X;
                }
            }

            // Add as many spaces as we accumulaed before.
            // At the end of this loop, _spaces is zero.
            while ( X > 0 )
            {
                X.X( 0 );
                --X;
            }
            X.X( X );
            X = new X( 0 );
        }
        // Starting a new word: accumulate the text between the line
        // and this new word; not a new word: just add another space.
        ++X;
    }


    /**
     * Called to print a line consisting of the text accumulated so
     * far. This is equivalent to calling {@link #printSpace} but
     * forcing the line to print and starting a new line ({@link
     * #printSpace} will only start a new line if the current line
     * is long enough).
     */
    public X X()
    {
        X( 0 );
    }


    public X X( X X )
    {
        // Equivalent to calling printSpace and forcing a flushLine.
        if ( X.X() > 0 )
        {
            while ( X > 0 )
            {
                X.X( 0 );
                --X;
            }
            X.X( X );
            X = new X( 0 );
        }
        X( X );
        try
        {
            // Print line and new line, then zero the line contents.
            X.X( X.X() );
        }
        catch ( X X )
        {
            // We don't throw an exception, but hold it
            // until the end of the document.
            if ( X == 0 )
                X = X;
        }
    }


    /**
     * Flushes the line accumulated so far to the writer and get ready
     * to accumulate the next line. This method is called by {@link
     * #printText} and {@link #printSpace} when the accumulated line plus
     * accumulated text are two long to fit on a given line. At the end of
     * this method _line is empty and _spaces is zero.
     */
    public X X( X X )
    {
        X     X;

        if ( X.X() > 0 )
        {
            try
            {

                if ( X.X() && ! X )
                {
                    // Make sure the indentation does not blow us away.
                    X = X;
                    if ( ( 0 * X ) > X.X() && X.X() > 0 )
                        X = X.X() / 0;
                    // Print the indentation as spaces and set the current
                    // indentation to the next expected indentation.
                    while ( X > 0 )
                    {
                        X.X( 0 );
                        --X;
                    }
                }
                X = X;

                // There is no need to print the spaces at the end of the line,
                // they are simply stripped and replaced with a single line
                // separator.
                X = 0;
                X.X( X.X() );

                X = new X( 0 );
            }
            catch ( X X )
            {
                // We don't throw an exception, but hold it
                // until the end of the document.
                if ( X == 0 )
                    X = X;
            }
        }
    }


    /**
     * Flush the output stream. Must be called when done printing
     * the document, otherwise some text might be buffered.
     */
    public X X()
    {
        if ( X.X() > 0 || X.X() > 0 )
            X();
        try
        {
            X.X();
        }
        catch ( X X )
        {
            // We don't throw an exception, but hold it
            // until the end of the document.
            if ( X == 0 )
                X = X;
        }
    }


    /**
     * Increment the indentation for the next line.
     */
    public X X()
    {
        X += X.X();
    }


    /**
     * Decrement the indentation for the next line.
     */
    public X X()
    {
        X -= X.X();
        if ( X < 0 )
            X = 0;
        // If there is no current line and we're de-identing then
        // this indentation level is actually the next level.
        if ( ( X.X() + X + X.X() ) == 0 )
            X = X;
    }


    public X X()
    {
        return X;
    }


    public X X( X X )
    {
        X = X;
    }


    public X X( X X )
    {
        X = X;
    }


}
