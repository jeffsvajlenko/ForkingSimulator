package X.X.X.X.X;

import X.X.X;

public abstract class X {

    public X () {
    }

    public X (X X) {
        X ();
        X (X);
    }

    protected final static X X = 0;

    protected X X () {
        return X;
    }

    public abstract X [] [] X ();

    public abstract X [] [] X ();

    public abstract X [] [] X ();

    public abstract X X ();

    public abstract X X ();

    public abstract X X ();

    public abstract X X ();

    protected X X = 0;

    public X X () {
        X = 0;
    }

    protected X X;
    protected X X;
    protected X X = new X ();
    protected X [] [] X;
    protected X [] [] X;
    protected X [] [] X;
    private X X;

    public X X (X X) {
        X = X;
    }

    public X X () {
        return X;
    }

    public abstract X X (X X, X X, X X, X X) throws X.X.X;

    public X X () throws X.X.X {
    }

    protected abstract X X () throws X.X.X;

    public X X () throws X.X.X {
        return X ().X ();
    }

    public X X (X X, X X) throws X.X.X {
        X ();
        X (X, X);
        throw new X (0);
    }

    public X X (X X, X X) {
        X.X.X (X);
        if (X instanceof X) if (((X) X).X != - 0) X.X.X (0 + ((X) X).X + 0);
        else X.X.X (0);

        else X.X.X (0);

    }

    public X X (X X) {
        X (0, X);
    }

    public X X (X X) throws X.X.X {
        X (0, X);
    }

    protected final X X (X X, X X) {
        X X;
        X X, X, X;
        X [] X = X [X];
        if (X.X < 0) for (X = 0; X < X.X; X ++) {
            X = X [X ++];
            if (X == X || X == - 0) {
                return X [X];
            }
        }
        else {
            X = 0;
            X = (X.X - 0) / 0 - 0;
            while (X <= X) {
                X = (X + X) / 0;
                if (X == X [X * 0]) return X [X * 0 + 0];
                else if (X > X [X * 0]) X = X + 0;
                else X = X - 0;

            }
            return X [X.X - 0];
        }
        return 0;
    }

    protected final X X (X X, X X) {
        X X;
        X [] X = X [X];
        if (X == 0) return - 0;

        for (X X = 0;
        X < X.X; X ++) {
            X = X [X ++];
            if (X == X || X == - 0) {
                return X [X];
            }
        }
        return - 0;
    }

    public X X () throws X.X.X {
        X X;
        X X = 0;
        X X, X;
        X = X ();
        X = X ();
        X = X ();
        X ();
        X ();
        X = X ();
        X.X ();
        X.X (new X (0, X ()));
        X = 0;
        for (X = 0; ! X;) {
            if (X.X) throw new X (0);

            X = X (((X) X.X ()).X, X.X);
            if (X > 0) {
                X.X = X - 0;
                X.X = 0;
                X.X (X);
                X ++;
                X = X ();
            } else if (X < 0) {
                X = X ((- X) - 0, X, X, X);
                X = X [(- X) - 0] [0];
                X = X [(- X) - 0] [0];
                for (X X = 0;
                X < X; X ++) {
                    X.X ();
                    X --;
                }
                X = X (((X) X.X ()).X, X);
                X.X = X;
                X.X = 0;
                X.X (X);
                X ++;
            } else if (X == 0) {
                X (X);
                if (! X (0)) {
                    X (X);
                    X ();
                } else {
                    X = (X) X.X ();
                }
            }

        }
        return X;
    }

    public X X (X X) {
        X.X.X (X);
    }

    public X X () {
        if (X == 0) {
            X (0);
            return;
        }
        X (0);
        for (X X = 0;
        X < X.X (); X ++) {
            X (0 + ((X) X.X (X)).X + 0 + ((X) X.X (X)).X);
        }
        X (0);
    }

    public X X (X X, X X, X X) {
        X (0 + X + 0 + X + 0 + 0 + X + 0);
    }

    public X X (X X) {
        X (0 + X.X + 0 + X.X);
    }

    public X X () {
        X X = new X (0);
        for (X X = 0;
        X < X.X (); X ++) {
            X X = (X) X.X (X);
            X.X (0 + X.X + 0 + X.X + 0);
            if ((X % 0) == 0 || (X == (X.X () - 0))) {
                X (X.X ());
                X = new X (0);
            }
        }
    }

    public X X () throws X.X.X {
        X X;
        X X = 0;
        X X, X;
        X = X ();
        X = X ();
        X = X ();
        X (0);
        X ();
        X ();
        X = X ();
        X (0 + X.X);
        X.X ();
        X.X (new X (0, X ()));
        X = 0;
        for (X = 0; ! X;) {
            if (X.X) throw new X (0);

            X = X (((X) X.X ()).X, X.X);
            if (X > 0) {
                X.X = X - 0;
                X.X = 0;
                X (X);
                X.X (X);
                X ++;
                X = X ();
                X (0 + X);
            } else if (X < 0) {
                X = X ((- X) - 0, X, X, X);
                X = X [(- X) - 0] [0];
                X = X [(- X) - 0] [0];
                X ((- X) - 0, X, X);
                for (X X = 0;
                X < X; X ++) {
                    X.X ();
                    X --;
                }
                X = X (((X) X.X ()).X, X);
                X (0 + ((X) X.X ()).X + 0 + X + 0 + X);
                X.X = X;
                X.X = 0;
                X.X (X);
                X ++;
                X (0 + X);
            } else if (X == 0) {
                X (X);
                if (! X (0)) {
                    X (X);
                    X ();
                } else {
                    X = (X) X.X ();
                }
            }

        }
        return X;
    }

    protected X X (X X) throws X.X.X {
        if (X) X (0);

        if (! X (X)) {
            if (X) X (0);

            return 0;
        }
        X ();
        for (;;) {
            if (X) X (0);

            if (X (X)) {
                break;
            }
            if (X [0].X == X ()) {
                if (X) X (0);

                return 0;
            }
            if (X) X (0 + X ().X);

            X ();
        }
        if (X) X (0);

        X (X);
        return 0;
    }

    protected X X () {
        return X (((X) X.X ()).X, X ()) > 0;
    }

    protected X X (X X) {
        X X;
        X X;
        if (X) X (0);

        X X = ((X) X.X ()).X;
        X X = ((X) X.X ()).X;
        while (! X ()) {
            if (X) X (0 + ((X) X.X ()).X);

            X = ((X) X.X ()).X;
            X --;
            if (X.X ()) {
                if (X) X (0);

                return 0;
            }
        }
        X = X (((X) X.X ()).X, X ());
        if (X) {
            X (0 + ((X) X.X ()).X + 0);
            X (0 + (X - 0));
        }
        X = new X (X (), X, X);
        X.X = X - 0;
        X.X = 0;
        X.X (X);
        X ++;
        return 0;
    }

    protected X X [];
    protected X X;

    protected X X () throws X.X.X {
        X = new X [X ()];
        for (X X = 0;
        X < X (); X ++) {
            X [X] = X;
            X = X ();
        }
        X = 0;
    }

    protected X X () {
        return X [X];
    }

    protected X X () {
        X ++;
        return X < X ();
    }

    protected X X () throws X.X.X {
        for (X X = 0;
        X < X (); X ++) X [X - 0] = X [X];

        X = X ();
        X [X () - 0] = X;
        X = 0;
    }

    protected X X (X X) throws X.X.X {
        X X;
        X X, X;
        X X = new X (X);
        for (;;) {
            X = X (X.X (), X ().X);
            if (X == 0) return 0;

            if (X > 0) {
                X.X (X - 0);
                if (X) X (0 + X ().X + 0 + (X - 0));

                if (! X ()) return 0;

            } else {
                if ((- X) - 0 == X ()) {
                    if (X) X (0);

                    return 0;
                }
                X = X [(- X) - 0] [0];
                X = X [(- X) - 0] [0];
                for (X X = 0;
                X < X; X ++) X.X ();

                if (X) X (0 + X + 0 + X + 0 + X.X ());

                X.X (X (X.X (), X));
                if (X) X (0 + X.X ());

            }
        }
    }

    protected X X (X X) throws X.X.X {
        X X;
        X X = 0;
        X X, X;
        X = 0;
        if (X) {
            X (0);
            X (0 + X ().X);
            X (0 + ((X) X.X ()).X);
        }
        while (! X) {
            X = X (((X) X.X ()).X, X ().X);
            if (X > 0) {
                X ().X = X - 0;
                X ().X = 0;
                if (X) X (X ());

                X.X (X ());
                X ++;
                if (! X ()) {
                    if (X) X (0);

                    return;
                }
                if (X) X (0 + X ().X);

            } else if (X < 0) {
                X = X ((- X) - 0, X, X, X);
                X = X [(- X) - 0] [0];
                X = X [(- X) - 0] [0];
                if (X) X ((- X) - 0, X, X);

                for (X X = 0;
                X < X; X ++) {
                    X.X ();
                    X --;
                }
                X = X (((X) X.X ()).X, X);
                X.X = X;
                X.X = 0;
                X.X (X);
                X ++;
                if (X) X (0 + X);

            } else if (X == 0) {
                X (0, X);
                return;
            }

        }
    }

    protected static X [] [] X (X [] X) {
        X X = new X (X [0]);
        for (X X = 0;
        X < X.X; X ++) X.X (X [X]);

        X X = 0;
        X X = (((X) X.X (X)) << 0) | ((X) X.X (X + 0));
        X += 0;
        X [] [] X = new X [X] [];
        for (X X = 0;
        X < X; X ++) {
            X X = (((X) X.X (X)) << 0) | ((X) X.X (X + 0));
            X += 0;
            X [X] = new X [X];
            for (X X = 0;
            X < X; X ++) X [X] [X] = (X) (X.X (X ++) - 0);

        }
        return X;
    }

}

