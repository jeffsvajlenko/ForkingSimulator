package X.X.X.X.X.X.X;

/* ====================================================================
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2001 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names "Apache" and "Apache Software Foundation" and
 *    "Apache BCEL" must not be used to endorse or promote products
 *    derived from this software without prior written permission. For
 *    written permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache",
 *    "Apache BCEL", nor may "Apache" appear in their name, without
 *    prior written permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

import X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.*;
import X.X.X;

/**
 * Abstract super class for all possible java types, namely basic types
 * such as int, object types like String and array types, e.g. int[]
 *
 * @version $Id: Type.java,v 1.1.2.1 2005/07/31 23:45:18 jeffsuttor Exp $
 * @author  <A HREF="mailto:markus.dahm@berlin.de">M. Dahm</A>
 */
public abstract class X implements X.X.X
{
    protected X   X;
    protected X X; // signature for the type

    /** Predefined constants
     */
    public static final X     X         = new X(X.X);
    public static final X     X      = new X(X.X);
    public static final X     X          = new X(X.X);
    public static final X     X        = new X(X.X);
    public static final X     X         = new X(X.X);
    public static final X     X         = new X(X.X);
    public static final X     X       = new X(X.X);
    public static final X     X        = new X(X.X);
    public static final X     X         = new X(X.X);
    public static final X    X       = new X(0);
    public static final X    X       = new X(0);
    public static final X    X = new X(0);
    public static final X    X    = new X(0);
    public static final X[]        X      = new X[0];
    public static final X X         = new X() {};
    public static final X          X      = new X(X.X,
    0) {};

    protected X(X X, X X)
    {
        X      = X;
        X = X;
    }

    /**
     * @return signature for given type.
     */
    public X X()
    {
        return X;
    }

    /**
     * @return type as defined in Constants
     */
    public X X()
    {
        return X;
    }

    /**
     * @return stack size of this type (2 for long and double, 0 for void, 1 otherwise)
     */
    public X X()
    {
        switch(X)
        {
        case X.X:
        case X.X:
            return 0;
        case X.X:
            return 0;
        default:
            return 0;
        }
    }

    /**
     * @return Type string, e.g. `int[]'
     */
    public X X()
    {
        return ((X.X(X.X) || (X >= X.X)))? X :
               X.X(X, 0);
    }

    /**
     * Convert type to Java method signature, e.g. int[] f(java.lang.String x)
     * becomes (Ljava/lang/String;)[I
     *
     * @param return_type what the method returns
     * @param arg_types what are the argument types
     * @return method signature for given type(s).
     */
    public static X X(X X, X[] X)
    {
        X X = new X(0);
        X X = (X == 0)? 0 : X.X;

        for(X X=0; X < X; X++)
            X.X(X[X].X());

        X.X(0);
        X.X(X.X());

        return X.X();
    }

    private static X X=0; // Remember position in string, see getArgumentTypes

    /**
     * Convert signature to a Type object.
     * @param signature signature string such as Ljava/lang/String;
     * @return type object
     */
    public static final X X(X X)
    throws X
    {
        X X = X.X(X);

        if(X <= X.X)
        {
            X = 0;
            return X.X(X);
        }
        else if(X == X.X)
        {
            X X=0;
            do   // Count dimensions
            {
                X++;
            }
            while(X.X(X) == 0);

            // Recurse, but just once, if the signature is ok
            X X = X(X.X(X));

            X += X; // update counter

            return new X(X, X);
        }
        else     // type == T_REFERENCE
        {
            X X = X.X(0); // Look for closing `;'

            if(X < 0)
                throw new X(0 + X);

            X = X + 0; // "Lblabla;" `L' and `;' are removed

            return new X(X.X(0, X).X(0, 0));
        }
    }

    /**
     * Convert return value of a method (signature) to a Type object.
     *
     * @param signature signature string such as (Ljava/lang/String;)V
     * @return return type
     */
    public static X X(X X)
    {
        try
        {
            // Read return type after `)'
            X X = X.X(0) + 0;
            return X(X.X(X));
        }
        catch(X X)     // Should never occur
        {
            throw new X(0 + X);
        }
    }

    /**
     * Convert arguments of a method (signature) to an array of Type objects.
     * @param signature signature string such as (Ljava/lang/String;)V
     * @return array of argument types
     */
    public static X[] X(X X)
    {
        X X = new X();
        X       X;
        X[]     X;

        try   // Read all declarations between for `(' and `)'
        {
            if(X.X(0) != 0)
                throw new X(0 + X);

            X = 0; // current string position

            while(X.X(X) != 0)
            {
                X.X(X(X.X(X)));
                X += X; // update position
            }
        }
        catch(X X)     // Should never occur
        {
            throw new X(0 + X);
        }

        X = new X[X.X()];
        X.X(X);
        return X;
    }

    /** Convert runtime java.lang.Class to BCEL Type object.
     * @param cl Java class
     * @return corresponding Type object
     */
    public static X X(X.X.X X)
    {
        if(X == 0)
        {
            throw new X(0);
        }

        /* That's an amzingly easy case, because getName() returns
         * the signature. That's what we would have liked anyway.
         */
        if(X.X())
        {
            return X(X.X());
        }
        else if(X.X())
        {
            if(X == X.X)
            {
                return X;
            }
            else if(X == X.X)
            {
                return X;
            }
            else if(X == X.X)
            {
                return X;
            }
            else if(X == X.X)
            {
                return X;
            }
            else if(X == X.X)
            {
                return X;
            }
            else if(X == X.X)
            {
                return X;
            }
            else if(X == X.X)
            {
                return X;
            }
            else if(X == X.X)
            {
                return X;
            }
            else if(X == X.X)
            {
                return X;
            }
            else if(X == X.X)
            {
                return X;
            }
            else
            {
                throw new X(0 + X);
            }
        }
        else     // "Real" class
        {
            return new X(X.X());
        }
    }

    public static X X(X.X.X.X X)
    {
        X X = new X(0);
        X[] X = X.X(); // avoid clone

        for(X X = 0; X < X.X; X++)
        {
            X.X(X(X[X]).X());
        }

        X.X(0);
        X.X(X(X.X()).X());
        return X.X();
    }
}
