/*
 * Copyright (c) 2007, 2011, Oracle and/or its affiliates. All rights reserved.
 * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 */

package X.X.X.X;

import X.X.X.X.X.X;
import X.X.X.X.X.X;
import X.X.X.X.X.X;
import X.X.X.X.X.X;
import X.X.X.X.X.X;
import X.X.X.X.X.X;
import X.X.X.X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X.X;
import X.X.X.X;
import X.X.X.X;
import X.X.X.X;
import X.X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X.X;
import X.X.X.X;
import X.X.X.X;
import X.X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X.X;
import X.X.X.X;
import X.X.X.X;
import X.X.X.X;
import X.X.X.X;
import X.X.X.X;
import X.X.X;
import X.X.X;
import X.X.X.X;
import X.X.X;
import X.X.X.X;
import X.X.X.X;
import X.X.X.X;
import X.X.X.X;
import X.X.X.X;
import X.X.X.X;

/**
 * <p>A connection to a remote RMI connector.  Usually, such
 * connections are made using {@link
 * javax.management.remote.JMXConnectorFactory JMXConnectorFactory}.
 * However, specialized applications can use this class directly, for
 * example with an {@link RMIServer} stub obtained without going
 * through JNDI.</p>
 *
 * @since 1.5
 * @since.unbundled 1.0
 */
public class X implements X, X, X
{

    private static final X X =
        new X(0, 0);

    private static final X X = 0;

    private X(X X, X X,
                         X X)
    {
        if (X == 0 && X == 0) throw new
            X(0);

        X();

        X.X = X;
        X.X = X;
        if (X == 0)
        {
            X.X = X.X;
        }
        else
        {
            X.X(X);
            X.X = X.X(X);
        }
    }

    /**
     * <p>Constructs an <code>RMIConnector</code> that will connect
     * the RMI connector server with the given address.</p>
     *
     * <p>The address can refer directly to the connector server,
     * using one of the following syntaxes:</p>
     *
     * <pre>
     * service:jmx:rmi://<em>[host[:port]]</em>/stub/<em>encoded-stub</em>
     * service:jmx:iiop://<em>[host[:port]]</em>/ior/<em>encoded-IOR</em>
     * </pre>
     *
     * <p>(Here, the square brackets <code>[]</code> are not part of the
     * address but indicate that the host and port are optional.)</p>
     *
     * <p>The address can instead indicate where to find an RMI stub
     * through JNDI, using one of the following syntaxes:</p>
     *
     * <pre>
     * service:jmx:rmi://<em>[host[:port]]</em>/jndi/<em>jndi-name</em>
     * service:jmx:iiop://<em>[host[:port]]</em>/jndi/<em>jndi-name</em>
     * </pre>
     *
     * <p>An implementation may also recognize additional address
     * syntaxes, for example:</p>
     *
     * <pre>
     * service:jmx:iiop://<em>[host[:port]]</em>/stub/<em>encoded-stub</em>
     * </pre>
     *
     * @param url the address of the RMI connector server.
     *
     * @param environment additional attributes specifying how to make
     * the connection.  For JNDI-based addresses, these attributes can
     * usefully include JNDI attributes recognized by {@link
     * InitialContext#InitialContext(Hashtable) InitialContext}.  This
     * parameter can be null, which is equivalent to an empty Map.
     *
     * @exception IllegalArgumentException if <code>url</code>
     * is null.
     */
    public X(X X, X<X,?> X)
    {
        X(0, X, X);
    }

    /**
     * <p>Constructs an <code>RMIConnector</code> using the given RMI stub.
     *
     * @param rmiServer an RMI stub representing the RMI connector server.
     * @param environment additional attributes specifying how to make
     * the connection.  This parameter can be null, which is
     * equivalent to an empty Map.
     *
     * @exception IllegalArgumentException if <code>rmiServer</code>
     * is null.
     */
    public X(X X, X<X,?> X)
    {
        X(X, 0, X);
    }

    /**
     * <p>Returns a string representation of this object.  In general,
     * the <code>toString</code> method returns a string that
     * "textually represents" this object. The result should be a
     * concise but informative representation that is easy for a
     * person to read.</p>
     *
     * @return a String representation of this object.
     **/
    public X X()
    {
        final X X = new X(X.X().X());
        X.X(0);
        if (X != 0)
        {
            X.X(0).X(X.X());
        }
        if (X != 0)
        {
            if (X!=0) X.X(0);
            X.X(0).X(X.X());
        }
        return X.X();
    }

    /**
     * <p>The address of this connector.</p>
     *
     * @return the address of this connector, or null if it
     * does not have one.
     *
     * @since 1.6
     */
    public X X()
    {
        return X;
    }

    //--------------------------------------------------------------------
    // implements JMXConnector interface
    //--------------------------------------------------------------------
    public X X() throws X
    {
        X(0);
    }

    public synchronized X X(X<X,?> X)
    throws X
    {
        final X X = X.X();
        X        X   = (X?0+X.X()+0:0);

        if (X)
        {
            X.X(0,X + 0);
            throw new X(0);
        }
        if (X)
        {
            X.X(0,X + 0);
            return;
        }

        try
        {
            if (X) X.X(0,X + 0);

            final X X =
                new X((X.X==0)?X.X:X.X);

            if (X != 0)
            {
                X.X(X);
                X.X(X);
            }

            // Get RMIServer stub from directory or URL encoding if needed.
            if (X) X.X(0,X + 0);
            X X = (X!=0)?X:
                             X(X, X);

            // Check for secure RMIServer stub if the corresponding
            // client-side environment property is set to "true".
            //
            X X = X.X(
                                    X,
                                    0);
            if (X) X(X, X);

            // Connect IIOP Stub if needed.
            if (X) X.X(0,X + 0);
            X = X(X,X);
            X = (X?0+X.X()+0:0);

            // Calling newClient on the RMIServer stub.
            if (X)
                X.X(0,X + 0);
            X X = X.X(X);

            try
            {
                X = X(X, X, X);
            }
            catch (X.X.X X)
            {
                if (X != 0)
                {
                    final X X = X.X();
                    final X X = X.X();

                    if (0.X(X) &&
                            X.X(0))
                    {
                        X X = new X(
                            0 + X);
                        X.X(X);
                        throw X;
                    }
                }
                throw X;
            }

            // Always use one of:
            //   ClassLoader provided in Map at connect time,
            //   or contextClassLoader at connect time.
            if (X)
                X.X(0,X + 0);
            X = X.X(X);

            X.X(X.X,
                       X);

            X = new X(X, X);

            X = X;
            final X X = X.X(X);
            X = new X(X);

            X = 0;

            // The connectionId variable is used in doStart(), when
            // reconnecting, to identify the "old" connection.
            //
            X = X();

            X X =
                new X(X.X,
                                              X,
                                              X,
                                              X++,
                                              0,
                                              0);
            X(X);

            if (X) X.X(0,X + 0);
        }
        catch (X X)
        {
            if (X)
                X.X(0,X + 0 + X);
            throw X;
        }
        catch (X X)
        {
            if (X)
                X.X(0,X + 0 + X);
            throw X;
        }
        catch (X X)
        {
            final X X = 0 + X;
            if (X) X.X(0,X + 0 + X);
            throw X.X(new X(X),X);
        }
    }

    public synchronized X X() throws X
    {
        if (X || !X)
        {
            if (X.X())
                X.X(0,0+X.X()+
                             0);

            throw new X(0);
        }

        // we do a remote call to have an IOException if the connection is broken.
        // see the bug 4939578
        return X.X();
    }

    public synchronized X X()
    throws X
    {
        return X(0);
    }

    public synchronized X
    X(X X)
    throws X
    {

        if (X)
        {
            if (X.X())
                X.X(0,0 + X.X() +
                             0);
            throw new X(0);
        }
        else if (!X)
        {
            if (X.X())
                X.X(0,0 + X.X() +
                             0);
            throw new X(0);
        }

        X X =
            (X) X.X(X);
        if (X != 0)
            return X;

        X = new X(X);
        X.X(X, X);
        return X;
    }

    public X
    X(X X,
                                      X X,
                                      X X)
    {
        if (X == 0)
            throw new X(0);
        X.X(X, X,
                X);
    }

    public X
    X(X X)
    throws X
    {
        if (X == 0)
            throw new X(0);
        X.X(X);
    }

    public X
    X(X X,
                                         X X,
                                         X X)
    throws X
    {
        if (X == 0)
            throw new X(0);
        X.X(X, X,
                X);
    }

    private X X(X X)
    {
        X.X(X);
    }

    public synchronized X X() throws X
    {
        X(0);
    }

    // allows to do close after setting the flag "terminated" to true.
    // It is necessary to avoid a deadlock, see 6296324
    private synchronized X X(X X) throws X
    {
        final X X = X.X();
        final X X   = X.X();
        final X  X   = (X?0+X.X()+0:0);

        if (!X)
        {
            // Return if already cleanly closed.
            //
            if (X)
            {
                if (X == 0)
                {
                    if (X) X.X(0,X + 0);
                    return;
                }
            }
            else
            {
                X = 0;
            }
        }

        if (X != 0 && X)
        {
            // Already closed, but not cleanly. Attempt again.
            //
            if (X)
            {
                X.X(0,X + 0 + X);
                X.X(0,X + 0);
            }
        }

        X X = 0;
        if (X)
        {
            X = X;
        }

        X = 0;

        if (X) X.X(0,X + 0);

        if (X != 0)
        {
            X.X();
        }

        if (X != 0)
        {
            try
            {
                X.X();
                if (X) X.X(0,X +
                                              0);
            }
            catch (X X)
            {
                X = X;
                if (X) X.X(0,X +
                                              0 + X);
                if (X) X.X(0,X);
            }
        }

        if (X != 0)
        {
            try
            {
                X.X();
                if (X) X.X(0,X + 0);
            }
            catch (X X)
            {
                // OK, the server maybe closed itself.
            }
            catch (X X)
            {
                X = X;
                if (X) X.X(0,X +
                                              0 + X);
                if (X) X.X(0,X);
            }
        }

        // Clean up MBeanServerConnection table
        //
        X.X();

        /* Send notification of closure.  We don't do this if the user
         * never called connect() on the connector, because there's no
         * connection id in that case.  */

        if (X != 0)
        {
            X X =
                new X(X.X,
                                              X,
                                              X,
                                              X++,
                                              0,
                                              0);
            X(X);
        }

        // throw exception if needed
        //
        if (X != 0)
        {
            if (X) X.X(0,X + 0 +
                                          X);
            if (X instanceof X)
                throw (X) X;
            if (X instanceof X)
                throw (X) X;
            final X X =
                new X(0 + X);
            throw X.X(X,X);
        }
    }

    // added for re-connection
    private X X(X X,
                                           X X,
                                           X X,
                                           X X)
    throws X, X
    {

        final X X = X.X();
        if (X)
            X.X(0,
                         0);

        final X[] X = new X[] {X};
        final X[] X = new X[] {X};
        final X[] X = new X[]
        {
            X
        };

        final X[] X =
            X(X,X,X,
                                     X);

        if (X) X.X(0,0
                                    + X[0]);
        return X[0];
    }

    // added for re-connection
    private X[] X(X[]       X,
            X[] X,
            X[]          X,
            X            X)
    throws X, X
    {

        final X X = X.X();
        if (X)
            X.X(0,
                         0);

        final X X = X();
        X[] X = 0;

        try
        {
            X = X.X(X,
                          X,
                          X);
        }
        catch (X X)
        {
            // maybe reconnect
            if (X)
            {
                X.X(X);

                X = X.X(X,
                              X,
                              X);
            }
            else
            {
                throw X;
            }
        }
        catch (X X)
        {
            // send a failed notif if necessary
            X.X(X);
        }
        finally
        {
            X(X);
        }

        if (X) X.X(0,0
                                    + X.X + 0);
        return X;
    }

    //--------------------------------------------------------------------
    // Implementation of MBeanServerConnection
    //--------------------------------------------------------------------
    private class X
        implements X
    {

        private X X;

        public X()
        {
            X(0);
        }

        public X(X X)
        {
            X.X = X;
        }

        public X X(X X,
                                          X X)
        throws X,
            X,
            X,
            X,
            X,
            X
        {
            if (X.X())
                X.X(0,
                             0 + X + 0 +
                             X);

            final X X = X();
            try
            {
                return X.X(X,
                                              X,
                                              X);
            }
            catch (X X)
            {
                X.X(X);

                return X.X(X,
                                              X,
                                              X);
            }
            finally
            {
                X(X);
            }
        }

        public X X(X X,
                                          X X,
                                          X X)
        throws X,
            X,
            X,
            X,
            X,
            X,
            X
        {

            if (X.X())
                X.X(0,
                             0 + X + 0
                             + X + 0
                             + X + 0);

            final X X = X();
            try
            {
                return X.X(X,
                                              X,
                                              X,
                                              X);

            }
            catch (X X)
            {
                X.X(X);

                return X.X(X,
                                              X,
                                              X,
                                              X);

            }
            finally
            {
                X(X);
            }
        }

        public X X(X X,
                                          X X,
                                          X X[],
                                          X X[])
        throws X,
            X,
            X,
            X,
            X,
            X
        {
            if (X.X())
                X.X(0,
                             0 + X + 0
                             + X + 0
                             + X(X) + 0
                             + X(X));

            final X X = new X(X);
            final X X = X();
            try
            {
                return X.X(X,
                                              X,
                                              X,
                                              X,
                                              X);
            }
            catch (X X)
            {
                X.X(X);

                return X.X(X,
                                              X,
                                              X,
                                              X,
                                              X);
            }
            finally
            {
                X(X);
            }
        }

        public X X(X X,
                                          X X,
                                          X X,
                                          X X[],
                                          X X[])
        throws X,
            X,
            X,
            X,
            X,
            X,
            X
        {
            if (X.X()) X.X(
                    0,
                    0 + X + 0 + X + 0
                    + X + 0 + X(X)
                    + 0 + X(X));

            final X X = new X(X);
            final X X = X();
            try
            {
                return X.X(X,
                                              X,
                                              X,
                                              X,
                                              X,
                                              X);
            }
            catch (X X)
            {
                X.X(X);

                return X.X(X,
                                              X,
                                              X,
                                              X,
                                              X,
                                              X);
            }
            finally
            {
                X(X);
            }
        }

        public X X(X X)
        throws X,
            X,
            X
        {
            if (X.X())
                X.X(0, 0 + X);

            final X X = X();
            try
            {
                X.X(X, X);
            }
            catch (X X)
            {
                X.X(X);

                X.X(X, X);
            }
            finally
            {
                X(X);
            }
        }

        public X X(X X)
        throws X,
            X
        {
            if (X.X())
                X.X(0, 0 + X);

            final X X = X();
            try
            {
                return X.X(X, X);
            }
            catch (X X)
            {
                X.X(X);

                return X.X(X, X);
            }
            finally
            {
                X(X);
            }
        }

        public X X(X X,
                               X X)
        throws X
        {
            if (X.X()) X.X(0,
                                                   0 + X + 0 + X);

            final X X = new X(X);
            final X X = X();
            try
            {
                return X.X(X, X, X);
            }
            catch (X X)
            {
                X.X(X);

                return X.X(X, X, X);
            }
            finally
            {
                X(X);
            }
        }

        public X X(X X,
                              X X)
        throws X
        {
            if (X.X()) X.X(0,
                                                   0 + X + 0 + X);

            final X X = new X(X);
            final X X = X();
            try
            {
                return X.X(X, X, X);
            }
            catch (X X)
            {
                X.X(X);

                return X.X(X, X, X);
            }
            finally
            {
                X(X);
            }
        }

        public X X(X X)
        throws X
        {
            if (X.X())
                X.X(0, 0 + X);

            final X X = X();
            try
            {
                return X.X(X, X);
            }
            catch (X X)
            {
                X.X(X);

                return X.X(X, X);
            }
            finally
            {
                X(X);
            }
        }

        public X X()
        throws X
        {
            if (X.X()) X.X(0, 0);

            final X X = X();
            try
            {
                return X.X(X);
            }
            catch (X X)
            {
                X.X(X);

                return X.X(X);
            }
            finally
            {
                X(X);
            }
        }

        public X X(X X,
                                   X X)
        throws X,
            X,
            X,
            X,
            X
        {
            if (X.X()) X.X(0,
                                                   0 + X + 0
                                                   + X);

            final X X = X();
            try
            {
                return X.X(X,
                                               X,
                                               X);
            }
            catch (X X)
            {
                X.X(X);

                return X.X(X,
                                               X,
                                               X);
            }
            finally
            {
                X(X);
            }
        }

        public X X(X X,
                                           X[] X)
        throws X,
            X,
            X
        {
            if (X.X()) X.X(0,
                                                   0 + X + 0
                                                   + X(X));

            final X X = X();
            try
            {
                return X.X(X,
                                                X,
                                                X);

            }
            catch (X X)
            {
                X.X(X);

                return X.X(X,
                                                X,
                                                X);
            }
            finally
            {
                X(X);
            }
        }


        public X X(X X,
                                 X X)
        throws X,
            X,
            X,
            X,
            X,
            X
        {

            if (X.X()) X.X(0,
                                                   0 + X + 0
                                                   + X);

            final X X =
                new X(X);
            final X X = X();
            try
            {
                X.X(X, X, X);
            }
            catch (X X)
            {
                X.X(X);

                X.X(X, X, X);
            }
            finally
            {
                X(X);
            }
        }

        public X X(X X,
                                           X X)
        throws X,
            X,
            X
        {

            if (X.X()) X.X(0,
                                                   0 + X + 0
                                                   + X);

            final X X =
                new X(X);
            final X X = X();
            try
            {
                return X.X(X,
                                                X,
                                                X);
            }
            catch (X X)
            {
                X.X(X);

                return X.X(X,
                                                X,
                                                X);
            }
            finally
            {
                X(X);
            }
        }


        public X X(X X,
                             X X,
                             X X[],
                             X X[])
        throws X,
            X,
            X,
            X
        {

            if (X.X()) X.X(0,
                                                   0 + X
                                                   + 0 + X
                                                   + 0 + X(X)
                                                   + 0 + X(X));

            final X X = new X(X);
            final X X = X();
            try
            {
                return X.X(X,
                                         X,
                                         X,
                                         X,
                                         X);
            }
            catch (X X)
            {
                X.X(X);

                return X.X(X,
                                         X,
                                         X,
                                         X,
                                         X);
            }
            finally
            {
                X(X);
            }
        }


        public X X()
        throws X
        {
            if (X.X()) X.X(0, 0);

            final X X = X();
            try
            {
                return X.X(X);
            }
            catch (X X)
            {
                X.X(X);

                return X.X(X);
            }
            finally
            {
                X(X);
            }
        }

        public X[] X() throws X
        {
            if (X.X()) X.X(0, 0);

            final X X = X();
            try
            {
                return X.X(X);
            }
            catch (X X)
            {
                X.X(X);

                return X.X(X);
            }
            finally
            {
                X(X);
            }
        }

        public X X(X X)
        throws X,
            X,
            X,
            X
        {

            if (X.X()) X.X(0, 0 + X);
            final X X = X();
            try
            {
                return X.X(X, X);
            }
            catch (X X)
            {
                X.X(X);

                return X.X(X, X);
            }
            finally
            {
                X(X);
            }
        }


        public X X(X X,
                                    X X)
        throws X,
            X
        {
            if (X.X())
                X.X(0, 0 + X +
                             0 + X);

            final X X = X();
            try
            {
                return X.X(X,
                                               X,
                                               X);
            }
            catch (X X)
            {
                X.X(X);

                return X.X(X,
                                               X,
                                               X);
            }
            finally
            {
                X(X);
            }
        }

        public X X(X X,
                                            X X,
                                            X X,
                                            X X)
        throws X,
            X
        {

            if (X.X())
                X.X(0 +
                             0,
                             0 + X + 0 + X
                             + 0 + X + 0 + X);

            final X X = new X(X);
            final X X = new X(X);
            final X X = X();
            try
            {
                X.X(X,
                                                   X,
                                                   X,
                                                   X,
                                                   X);
            }
            catch (X X)
            {
                X.X(X);

                X.X(X,
                                                   X,
                                                   X,
                                                   X,
                                                   X);
            }
            finally
            {
                X(X);
            }
        }

        public X X(X X,
                                               X X)
        throws X,
            X,
            X
        {

            if (X.X()) X.X(0 +
                                                   0,
                                                   0 + X
                                                   + 0 + X);

            final X X = X();
            try
            {
                X.X(X,
                                                      X,
                                                      X);
            }
            catch (X X)
            {
                X.X(X);

                X.X(X,
                                                      X,
                                                      X);
            }
            finally
            {
                X(X);
            }
        }

        public X X(X X,
                                               X X,
                                               X X,
                                               X X)
        throws X,
            X,
            X
        {
            if (X.X())
                X.X(0 +
                             0,
                             0 + X
                             + 0 + X
                             + 0 + X
                             + 0 + X);

            final X X = new X(X);
            final X X = new X(X);
            final X X = X();
            try
            {
                X.X(X,
                                                      X,
                                                      X,
                                                      X,
                                                      X);
            }
            catch (X X)
            {
                X.X(X);

                X.X(X,
                                                      X,
                                                      X,
                                                      X,
                                                      X);
            }
            finally
            {
                X(X);
            }
        }

        // Specific Notification Handle ----------------------------------

        public X X(X X,
                                            X X,
                                            X X,
                                            X X)
        throws X,
            X
        {

            final X X = X.X();
            if (X)
                X.X(0 +
                             0+
                             0,
                             0 + X
                             + 0 + X
                             + 0 + X
                             + 0 + X);

            final X X =
                X(X, new X(X),
                                       X,0);
            X.X(X, X, X,
                                                   X, X,
                                                   X);
        }

        public X X(X X,
                                               X X)
        throws X,
            X,
            X
        {
            final X X = X.X();

            if (X) X.X(0+
                                        0,
                                        0 + X
                                        + 0 + X);

            final X[] X =
                X.X(X, X);

            if (X) X.X(0,
                                        0 + X(X));

            final X X = X();

            try
            {
                X.X(X,
                                                       X,
                                                       X);
            }
            catch (X X)
            {
                X.X(X);

                X.X(X,
                                                       X,
                                                       X);
            }
            finally
            {
                X(X);
            }

        }

        public X X(X X,
                                               X X,
                                               X X,
                                               X X)
        throws X,
            X,
            X
        {
            final X X = X.X();

            if (X)
                X.X(0+
                             0+
                             0,
                             0 + X
                             + 0 + X
                             + 0 + X
                             + 0 + X);

            final X X =
                X.X(X, X,
                        X, X);

            if (X) X.X(0,
                                        0 + X);

            final X X = X();
            try
            {
                X.X(X,
                                                       new X[] {X},
                                                       X);
            }
            catch (X X)
            {
                X.X(X);

                X.X(X,
                                                       new X[] {X},
                                                       X);
            }
            finally
            {
                X(X);
            }

        }
    }

    //--------------------------------------------------------------------
    private class X extends X
    {
        public X(X X, X X)
        {
            X(X, X);
        }

        protected X X(X X,
                X X,
                X X)
        throws X, X
        {
            X X;

            while (0)   // used for a successful re-connection
            {
                try
                {
                    return X.X(X,
                                                         X,
                                                         X);
                }
                catch (X X)
                {
                    X = X;

                    // inform of IOException
                    try
                    {
                        X.X(X);

                        // The connection should be re-established.
                        continue;
                    }
                    catch (X X)
                    {
                        // No more fetch, the Exception will be re-thrown.
                        break;
                    } // never reached
                } // never reached
            }

            // specially treating for an UnmarshalException
            if (X instanceof X)
            {
                X X = (X)X;

                if (X.X instanceof X)
                    throw (X) X.X;

                /* In Sun's RMI implementation, if a method return
                   contains an unserializable object, then we get
                   UnmarshalException wrapping WriteAbortedException
                   wrapping NotSerializableException.  In that case we
                   extract the NotSerializableException so that our
                   caller can realize it should try to skip past the
                   notification that presumably caused it.  It's not
                   certain that every other RMI implementation will
                   generate this exact exception sequence.  If not, we
                   will not detect that the problem is due to an
                   unserializable object, and we will stop trying to
                   receive notifications from the server.  It's not
                   clear we can do much better.  */
                if (X.X instanceof X)
                {
                    X X =
                        (X) X.X;
                    if (X.X instanceof X)
                        throw (X) X.X;
                }
            }
            else if (X instanceof X)
            {
                // IIOP will throw MarshalException wrapping a NotSerializableException
                // when a server fails to serialize a response.
                X X = (X)X;
                if (X.X instanceof X)
                {
                    throw (X)X.X;
                }
            }

            // Not serialization problem, simply re-throw the orginal exception
            throw X;
        }

        protected X X()
        throws X, X
        {
            X X = 0;
            X X =
                new X();
            X.X(
                X.X);
            X = new X(X);

            X[] X;
            final X[] X =
                new X[] {X.X};
            final X[] X =
                new X[] {X};
            final X[] X = new X[] {0};
            try
            {
                X =
                    X.X(X,
                                                        X,
                                                        X);

            }
            catch (X X)
            {
                X.X(X);

                X =
                    X.X(X,
                                                        X,
                                                        X);
            }
            return X[0];
        }

        protected X X(X X)
        throws X, X,
            X
        {
            try
            {
                X.X(
                    X.X,
                    new X[] {X},
                    0);
            }
            catch (X X)
            {
                X.X(X);

                X.X(
                    X.X,
                    new X[] {X},
                    0);
            }

        }

        protected X X(X X, X X)
        {
            final X X = X.X;

            final X X =
                new X(X,
                                              X.X,
                                              X,
                                              X++,
                                              X,
                                              new X(X));
            X(X);
        }
    }

    private class X extends X
    {
        public X(X X)
        {
            X(X);
        }

        public X X (X X) throws X
        {
            if (X instanceof X)
            {
                // need to restart
                X.X(X);

                return;
            }

            // check if the connection is broken
            try
            {
                X.X(0);
            }
            catch (X X)
            {
                X X = 0;

                synchronized(X)
                {
                    if (!X)
                    {
                        X = 0;

                        X = 0;
                    }
                }

                if (X)
                {
                    // we should close the connection,
                    // but send a failed notif at first
                    final X X =
                        new X(
                        X.X,
                        X,
                        X,
                        X++,
                        0+X.X(),
                        X);

                    X(X);

                    try
                    {
                        X(0);
                    }
                    catch (X X)
                    {
                        // OK.
                        // We are closing
                    }
                }
            }

            // forward the exception
            if (X instanceof X)
            {
                /* Need to unwrap the exception.
                   Some user-thrown exception at server side will be wrapped by
                   rmi into a ServerException.
                   For example, a RMIConnnectorServer will wrap a
                   ClassNotFoundException into a UnmarshalException, and rmi
                   will throw a ServerException at client side which wraps this
                   UnmarshalException.
                   No failed notif here.
                */
                X X = ((X)X).X;

                if (X instanceof X)
                {
                    throw (X)X;
                }
                else if (X instanceof X)
                {
                    throw (X)X;
                }
            }

            throw X;
        }

        public X X(X[] X) throws X
        {
            final X X  = X.X;
            X X;

            X[] X = new X[X];

            final X[] X = new X[X];
            final X[] X = new X[X];
            final X[] X = new X[X];
            final X[] X = new X[X];
            final X[] X = new X[X];
            final X[] X = new X[X];

            for (X=0; X<X; X++)
            {
                X[X]  = X[X].X();
                X[X]     = X[X].X();
                X[X] = X[X].X();
                X[X]   = X[X].X();
                X[X]  = new X(X[X]);
                X[X] = X[X].X();
            }

            try
            {
                X[] X = X(X,X,X,0);

                for (X=0; X<X; X++)
                {
                    X[X] = new X(X[X],
                                                     X[X],
                                                     X[X],
                                                     X[X],
                                                     X[X],
                                                     X[X]);
                }

                X.X(X);

                return;
            }
            catch (X X)
            {
                // OK, we will do one by one
            }

            X X = 0;
            for (X=0; X<X; X++)
            {
                try
                {
                    X X = X(X[X],
                                                        new X(X[X]),
                                                        X[X],
                                                        0);

                    X[X++] = new X(X,
                                                       X[X],
                                                       X[X],
                                                       X[X],
                                                       X[X],
                                                       X[X]);
                }
                catch (X X)
                {
                    X.X(0,
                                   0 +
                                   X[X]);
                }
            }

            if (X != X)
            {
                X[] X = X;
                X = new X[X];
                X.X(X, 0, X, 0, X);
            }

            X.X(X);
        }

        protected X X() throws X
        {
            if (X.X())
                X.X(0,
                             0);

            X.X(0);
        }

        protected X X() throws X
        {
            // Get RMIServer stub from directory or URL encoding if needed.
            X X = 0;
            try
            {
                X = (X!=0)?X:
                       X(X, X);
            }
            catch (X X)
            {
                throw new X(0+X);
            }

            // Connect IIOP Stub if needed.
            X = X(X,X);

            // Calling newClient on the RMIServer stub.
            X X = X.X(X);
            X = X.X(X);

            // notif issues
            final X[] X = X.X();

            X(X);

            X = X();

            X X =
                new X(X.X,
                                              X,
                                              X,
                                              X++,
                                              0,
                                              0);
            X(X);

        }

        protected X X()
        {
            try
            {
                X();
            }
            catch (X X)
            {
                X.X(0,
                               0 + X);
                X.X(0,X);
            }
        }
    }

    //--------------------------------------------------------------------
    // Private stuff - Serialization
    //--------------------------------------------------------------------
    /**
     * <p>In order to be usable, an IIOP stub must be connected to an ORB.
     * The stub is automatically connected to the ORB if:
     * <ul>
     *     <li> It was returned by the COS naming</li>
     *     <li> Its server counterpart has been registered in COS naming
     *          through JNDI.</li>
     * </ul>
     * Otherwise, it is not connected. A stub which is deserialized
     * from Jini is not connected. A stub which is obtained from a
     * non registered RMIIIOPServerImpl is not a connected.<br>
     * A stub which is not connected can't be serialized, and thus
     * can't be registered in Jini. A stub which is not connected can't
     * be used to invoke methods on the server.
     * <p>
     * In order to palliate this, this method will connect the
     * given stub if it is not yet connected. If the given
     * <var>RMIServer</var> is not an instance of
     * {@link javax.rmi.CORBA.Stub javax.rmi.CORBA.Stub}, then the
     * method do nothing and simply returns that stub. Otherwise,
     * this method will attempt to connect the stub to an ORB as
     * follows:
     * <ul>
     * <p>This method looks in the provided <var>environment</var> for
     * the "java.naming.corba.orb" property. If it is found, the
     * referenced object (an {@link org.omg.CORBA.ORB ORB}) is used to
     * connect the stub. Otherwise, a new org.omg.CORBA.ORB is created
     * by calling {@link
     * org.omg.CORBA.ORB#init(String[], Properties)
     * org.omg.CORBA.ORB.init((String[])null,(Properties)null)}
     * <p>The new created ORB is kept in a static
     * {@link WeakReference} and can be reused for connecting other
     * stubs. However, no reference is ever kept on the ORB provided
     * in the <var>environment</var> map, if any.
     * </ul>
     * @param rmiServer A RMI Server Stub.
     * @param environment An environment map, possibly containing an ORB.
     * @return the given stub.
     * @exception IllegalArgumentException if the
     *      <tt>java.naming.corba.orb</tt> property is specified and
     *      does not point to an {@link org.omg.CORBA.ORB ORB}.
     * @exception IOException if the connection to the ORB failed.
     **/
    static X X(X X,
                                 X X)
    throws X
    {
        if (X instanceof X.X.X.X)
        {
            X.X.X.X X = (X.X.X.X) X;
            try
            {
                X.X();
            }
            catch (X X)
            {
                X.X(X(X));
            }
        }
        return X;
    }

    /**
     * Get the ORB specified by <var>environment</var>, or create a
     * new one.
     * <p>This method looks in the provided <var>environment</var> for
     * the "java.naming.corba.orb" property. If it is found, the
     * referenced object (an {@link org.omg.CORBA.ORB ORB}) is
     * returned. Otherwise, a new org.omg.CORBA.ORB is created
     * by calling {@link
     * org.omg.CORBA.ORB#init(String[], java.util.Properties)
     * org.omg.CORBA.ORB.init((String[])null,(Properties)null)}
     * <p>The new created ORB is kept in a static
     * {@link WeakReference} and can be reused for connecting other
     * stubs. However, no reference is ever kept on the ORB provided
     * in the <var>environment</var> map, if any.
     * @param environment An environment map, possibly containing an ORB.
     * @return An ORB.
     * @exception IllegalArgumentException if the
     *      <tt>java.naming.corba.orb</tt> property is specified and
     *      does not point to an {@link org.omg.CORBA.ORB ORB}.
     * @exception IOException if the ORB initialization failed.
     **/
    static X X(X X)
    throws X
    {
        if (X != 0)
        {
            final X X = X.X(X.X);
            if (X != 0 && !(X instanceof  X))
                throw new X(X.X +
                                                   0);
            if (X != 0) return (X)X;
        }
        final X X =
            (X.X==0)?0:X.X.X();
        if (X != 0) return X;

        final X X =
            X.X((X[])0, (X)0);
        X.X = new X(X);
        return X;
    }

    /**
     * Read RMIConnector fields from an {@link java.io.ObjectInputStream
     * ObjectInputStream}.
     * Calls <code>s.defaultReadObject()</code> and then initializes
     * all transient variables that need initializing.
     * @param s The ObjectInputStream to read from.
     * @exception InvalidObjectException if none of <var>rmiServer</var> stub
     *    or <var>jmxServiceURL</var> are set.
     * @see #RMIConnector(JMXServiceURL,Map)
     * @see #RMIConnector(RMIServer,Map)
     **/
    private X X(X.X.X X)
    throws X, X
    {
        X.X();

        if (X == 0 && X == 0) throw new
            X(0);

        X();
    }

    /**
     * Writes the RMIConnector fields to an {@link java.io.ObjectOutputStream
     * ObjectOutputStream}.
     * <p>Connects the underlying RMIServer stub to an ORB, if needed,
     * before serializing it. This is done using the environment
     * map that was provided to the constructor, if any, and as documented
     * in {@link javax.management.remote.rmi}.</p>
     * <p>This method then calls <code>s.defaultWriteObject()</code>.
     * Usually, <var>rmiServer</var> is null if this object
     * was constructed with a JMXServiceURL, and <var>jmxServiceURL</var>
     * is null if this object is constructed with a RMIServer stub.
     * <p>Note that the environment Map is not serialized, since the objects
     * it contains are assumed to be contextual and relevant only
     * with respect to the local environment (class loader, ORB, etc...).</p>
     * <p>After an RMIConnector is deserialized, it is assumed that the
     * user will call {@link #connect(Map)}, providing a new Map that
     * can contain values which are contextually relevant to the new
     * local environment.</p>
     * <p>Since connection to the ORB is needed prior to serializing, and
     * since the ORB to connect to is one of those contextual parameters,
     * it is not recommended to re-serialize a just de-serialized object -
     * as the de-serialized object has no map. Thus, when an RMIConnector
     * object is needed for serialization or transmission to a remote
     * application, it is recommended to obtain a new RMIConnector stub
     * by calling {@link RMIConnectorServer#toJMXConnector(Map)}.</p>
     * @param s The ObjectOutputStream to write to.
     * @exception InvalidObjectException if none of <var>rmiServer</var> stub
     *    or <var>jmxServiceURL</var> are set.
     * @see #RMIConnector(JMXServiceURL,Map)
     * @see #RMIConnector(RMIServer,Map)
     **/
    private X X(X.X.X X)
    throws X
    {
        if (X == 0 && X == 0) throw new
            X(0);
        X(X.X,X);
        X.X();
    }

    // Initialization of transient variables.
    private X X()
    {
        X = new X();
        X = 0;
        X = 0;

        X = new X();
    }

    //--------------------------------------------------------------------
    // Private stuff - Check if stub can be trusted.
    //--------------------------------------------------------------------

    private static X X(X X,
                                  X<? extends X> X)
    {

        // Check remote stub is from the expected class.
        //
        if (X.X() != X)
        {
            if (!X.X(X.X()))
            {
                throw new X(
                    0 + X.X() + 0);
            }
            else
            {
                X X = X.X(X);
                if (X.X() != X.class)
                    throw new X(
                        0 +
                        X.class.X() +
                        0);
                else
                    X = (X) X;
            }
        }

        // Check RemoteRef in stub is from the expected class
        // "sun.rmi.server.UnicastRef2".
        //
        X X = ((X)X).X();
        if (X.X() != X.class)
            throw new X(
                0 + X.class.X() +
                0);

        // Check RMIClientSocketFactory in stub is from the expected class
        // "javax.rmi.ssl.SslRMIClientSocketFactory".
        //
        X X = ((X)X).X();
        X X = X.X();
        if (X == 0 || X.X() != X.class)
            throw new X(
                0 + X.class.X() +
                0);
    }

    //--------------------------------------------------------------------
    // Private stuff - RMIServer creation
    //--------------------------------------------------------------------

    private X X(X X,
                                    X X)
    throws X, X
    {
        final X X = X.X(X,0);
        if (X)
        {
            // Make sure java.naming.corba.orb is in the Map.
            X.X(X.X,X(X));
        }

        X X = X.X();
        if (X.X(0))
            return X(X.X(0), X, X);
        else if (X.X(0))
            return X(X.X(0), X, X);
        else if (X.X(0))
            return X(X.X(0), X, X);
        else
        {
            final X X = 0 +
                               0 + X;
            throw new X(X);
        }
    }

    /**
     * Lookup the RMIServer stub in a directory.
     * @param jndiURL A JNDI URL indicating the location of the Stub
     *                (see {@link javax.management.remote.rmi}), e.g.:
     *   <ul><li><tt>rmi://registry-host:port/rmi-stub-name</tt></li>
     *       <li>or <tt>iiop://cosnaming-host:port/iiop-stub-name</tt></li>
     *       <li>or <tt>ldap://ldap-host:port/java-container-dn</tt></li>
     *   </ul>
     * @param env the environment Map passed to the connector.
     * @param isIiop true if the stub is expected to be an IIOP stub.
     * @return The retrieved RMIServer stub.
     * @exception NamingException if the stub couldn't be found.
     **/
    private X X(X X, X X, X X)
    throws X
    {

        X X = new X(X.X(X));

        X X = X.X(X);
        X.X();

        if (X)
            return X(X);
        else
            return X(X);
    }

    private static X X(X X)
    {

        return (X) X;
    }

    private static X X(X X)
    {
        try
        {
            return (X)
                   X.X(X, X.class);
        }
        catch (X X)
        {
            if (X.X())
                X.X(0,0 +
                             X + 0 + X);
            if (X.X()) X.X(0,X);
            return 0;
        }
    }

    private X X(X X, X X, X X)
    {
        // could forbid "rmi:" URL here -- but do we need to?
        final X X = (X)
                        X.X(X.X);
        final X X = X.X(X);
        return (X) X.X(X, X.class);
    }

    private X X(X X, X X, X X)
    throws X
    {
        // could forbid "iiop:" URL here -- but do we need to?
        final X[] X;
        try
        {
            X = X(X);
        }
        catch (X X)
        {
            throw new X(0 +
                                            X.X());
        }
        final X X = new X(X);

        final X X = X.X(X);
        final X X =
            (X == 0) ?
            new X(X) :
            new X(X, X);
        final X X;
        try
        {
            X = X.X();
        }
        catch (X X)
        {
            throw new X(0 + X);
        }
        return (X) X.X(X, X.class);
    }

    private static final class X
        extends X
    {
        X(X X, X X)
        throws X
        {
            X(X);
            X.X = X;
        }

        protected X X(X X)
        throws X, X
        {
            return X.X(X.X(), 0, X);
        }

        private final X X;
    }

    /*
       The following section of code avoids a class loading problem
       with RMI.  The problem is that an RMI stub, when deserializing
       a remote method return value or exception, will first of all
       consult the first non-bootstrap class loader it finds in the
       call stack.  This can lead to behavior that is not portable
       between implementations of the JMX Remote API.  Notably, an
       implementation on J2SE 1.4 will find the RMI stub's loader on
       the stack.  But in J2SE 5, this stub is loaded by the
       bootstrap loader, so RMI will find the loader of the user code
       that called an MBeanServerConnection method.

       To avoid this problem, we take advantage of what the RMI stub
       is doing internally.  Each remote call will end up calling
       ref.invoke(...), where ref is the RemoteRef parameter given to
       the RMI stub's constructor.  It is within this call that the
       deserialization will happen.  So we fabricate our own RemoteRef
       that delegates everything to the "real" one but that is loaded
       by a class loader that knows no other classes.  The class
       loader NoCallStackClassLoader does this: the RemoteRef is an
       instance of the class named by proxyRefClassName, which is
       fabricated by the class loader using byte code that is defined
       by the string below.

       The call stack when the deserialization happens is thus this:
       MBeanServerConnection.getAttribute (or whatever)
       -> RMIConnectionImpl_Stub.getAttribute
          -> ProxyRef.invoke(...getAttribute...)
             -> UnicastRef.invoke(...getAttribute...)
                -> internal RMI stuff

       Here UnicastRef is the RemoteRef created when the stub was
       deserialized (which is of some RMI internal class).  It and the
       "internal RMI stuff" are loaded by the bootstrap loader, so are
       transparent to the stack search.  The first non-bootstrap
       loader found is our ProxyRefLoader, as required.

       In a future version of this code as integrated into J2SE 5,
       this workaround could be replaced by direct access to the
       internals of RMI.  For now, we use the same code base for J2SE
       and for the standalone Reference Implementation.

       The byte code below encodes the following class, compiled using
       J2SE 1.4.2 with the -g:none option.

    package com.sun.jmx.remote.internal;

    import java.lang.reflect.Method;
    import java.rmi.Remote;
    import java.rmi.server.RemoteRef;
    import com.sun.jmx.remote.internal.ProxyRef;

    public class PRef extends ProxyRef {
        public PRef(RemoteRef ref) {
    	super(ref);
        }

        public Object invoke(Remote obj, Method method,
    			 Object[] params, long opnum)
    	    throws Exception {
    	return ref.invoke(obj, method, params, opnum);
        }
    }
     */

    private static final X X =
        X.class.X() + 0;
    private static final X X;
    private static final X X =
        X.class.X() + 0;
    private static final X X;
    private static final X X =
        0;
    private static final X X;
    static
    {
        final X X =
            0+
            0+
            0+
            0+
            0+
            0+
            0+
            0+
            0+
            0+
            0;
        final X[] X =
            X.X(X);
        X X = new X()
        {
            public X X() throws X
            {
                X X = X.class;
                X X = X.X();
                X X =
                    X.X();
                X[] X = {X.class.X()};
                X X =
                    new X(X,
                                               X,
                                               X,
                                               X,
                                               X);
                X X = X.X(X);
                return X.X(new X[] {X.class});
            }
        };

        X X;
        try
        {
            X = X.X(X);
        }
        catch (X X)
        {
            X.X(0,
                         0 +
                         X + 0 + X);
            X.X(0,X);
            X = 0;
        }
        X = X;

        X X;
        X X;
        try
        {
            X = X.X(X);
            X = (X) X.X(X);
        }
        catch (X X)
        {
            X.X(0,
                         0+
                         0 + X + 0 + X);
            X.X(0,X);
            X = 0;
            X = 0;
        }
        X = X;
        X = X;
    }

    private static X X(X X)
    throws X, X,
        X, X,
        X
    {
        X X = X.X();
        X X = (X)
                             X.X(new X[] {X});
        final X[] X = {X.class};
        final X X =
            X.X(X);
        X[] X = {X};
        X X = (X)
                                  X.X(X);
        return X;
    }

    /*
       The following code performs a similar trick for RMI/IIOP to the
       one described above for RMI/JRMP.  Unlike JRMP, though, we
       can't easily insert an object between the RMIConnection stub
       and the RMI/IIOP deserialization code, as explained below.

       A method in an RMI/IIOP stub does the following.  It makes an
       org.omg.CORBA_2_3.portable.OutputStream for each request, and
       writes the parameters to it.  Then it calls
       _invoke(OutputStream) which it inherits from CORBA's
       ObjectImpl.  That returns an
       org.omg.CORBA_2_3.portable.InputStream.  The return value is
       read from this InputStream.  So the stack during
       deserialization looks like this:

       MBeanServerConnection.getAttribute (or whatever)
       -> _RMIConnection_Stub.getAttribute
          -> Util.readAny (a CORBA method)
             -> InputStream.read_any
                -> internal CORBA stuff

       What we would have *liked* to have done would be the same thing
       as for RMI/JRMP.  We create a "ProxyDelegate" that is an
       org.omg.CORBA.portable.Delegate that simply forwards every
       operation to the real original Delegate from the RMIConnection
       stub, except that the InputStream returned by _invoke is
       wrapped by a "ProxyInputStream" that is loaded by our
       NoCallStackClassLoader.

       Unfortunately, this doesn't work, at least with Sun's J2SE
       1.4.2, because the CORBA code is not designed to allow you to
       change Delegates arbitrarily.  You get a ClassCastException
       from code that expects the Delegate to implement an internal
       interface.

       So instead we do the following.  We create a subclass of the
       stub that overrides the _invoke method so as to wrap the
       returned InputStream in a ProxyInputStream.  We create a
       subclass of ProxyInputStream using the NoCallStackClassLoader
       and override its read_any and read_value(Class) methods.
       (These are the only methods called during deserialization of
       MBeanServerConnection return values.)  We extract the Delegate
       from the original stub and insert it into our subclass stub,
       and away we go.  The state of a stub consists solely of its
       Delegate.

       We also need to catch ApplicationException, which will encode
       any exceptions declared in the throws clause of the called
       method.  Its InputStream needs to be wrapped in a
       ProxyInputSteam too.

       We override _releaseReply in the stub subclass so that it
       replaces a ProxyInputStream argument with the original
       InputStream.  This avoids problems if the implementation of
       _releaseReply ends up casting this InputStream to an
       implementation-specific interface (which in Sun's J2SE 5 it
       does).

       It is not strictly necessary for the stub subclass to be loaded
       by a NoCallStackClassLoader, since the call-stack search stops
       at the ProxyInputStream subclass.  However, it is convenient
       for two reasons.  One is that it means that the
       ProxyInputStream subclass can be accessed directly, without
       using reflection.  The other is that it avoids build problems,
       since usually stubs are created after other classes are
       compiled, so we can't access them from this class without,
       again, using reflection.

       The strings below encode the following two Java classes,
       compiled using J2SE 1.4.2 with javac -g:none.

    package com.sun.jmx.remote.internal;

    import org.omg.stub.javax.management.remote.rmi._RMIConnection_Stub;

    import org.omg.CORBA.portable.ApplicationException;
    import org.omg.CORBA.portable.InputStream;
    import org.omg.CORBA.portable.OutputStream;
    import org.omg.CORBA.portable.RemarshalException;

    public class ProxyStub extends _RMIConnection_Stub {
        public InputStream _invoke(OutputStream out)
    	    throws ApplicationException, RemarshalException {
    	    	try {
    	    return new PInputStream(super._invoke(out));
    	    	} catch (ApplicationException e) {
    	    	    InputStream pis = new PInputStream(e.getInputStream());
    	    	    throw new ApplicationException(e.getId(), pis);
    	    	}
        }

        public void _releaseReply(InputStream in) {
    	PInputStream pis = (PInputStream) in;
    	super._releaseReply(pis.getProxiedInputStream());
        }
    }

    package com.sun.jmx.remote.internal;

    public class PInputStream extends ProxyInputStream {
        public PInputStream(org.omg.CORBA.portable.InputStream in) {
    	super(in);
        }

        public org.omg.CORBA.Any read_any() {
    	return in.read_any();
        }

        public java.io.Serializable read_value(Class clz) {
    	return narrow().read_value(clz);
        }
    }


     */
    private static final X X =
        0;
    private static final X X =
        0;
    private static final X X =
        0;
    private static final X X =
        0;
    private static final X X;
    static
    {
        final X X =
            0+
            0+
            0+
            0+
            0+
            0+
            0+
            0+
            0+
            0+
            0+
            0+
            0+
            0+
            0+
            0+
            0+
            0+
            0+
            0+
            0;
        final X X =
            0+
            0+
            0+
            0+
            0+
            0+
            0+
            0+
            0+
            0+
            0+
            0+
            0+
            0+
            0;
        final X[] X =
            X.X(X);
        final X[] X =
            X.X(X);
        final X[] X= {X, X};
        final X[][] X = {X, X};
        final X[] X =
        {
            X,
            X,
            X.class.X(),
        };
        X X = new X()
        {
            public X X() throws X
            {
                X X = X.class;
                X X = X.X();
                X X =
                    X.X();
                X X =
                    new X(X,
                                               X,
                                               X,
                                               X,
                                               X);
                return X.X(X);
            }
        };
        X X;
        try
        {
            X = (X) X.X(X);
        }
        catch (X X)
        {
            X.X(0,
                         0+X);
            X.X(0,X);
            X = 0;
        }
        X = X;
    }

    private static X X(X X)
    throws X, X
    {
        X X = (X) X.X();
        X.X(X.X());
        return (X) X;
    }

    private static X X(X X,
            X X,
            X X)
    throws X
    {
        X X = X.X(X);

        if (X) X(X, X);
        try
        {
            if (X.X() == X)
                return X((X) X);
            X X = X.X().X();
            if (X.X(X) ||
                    X.X(X))
                return X((X) X);
            X.X(0,
                         0 + X.X() + 0 +
                         0 +
                         0);
        }
        catch (X X)
        {
            X.X(0,
                         0 + X.X() + 0 +
                         0 +
                         0 + X);
            X.X(0,X);
            // so just return the original stub, which will work for all
            // but the most exotic class loading situations
        }
        return X;
    }

    private static X[] X(X X)
    {
        X X = X.X();
        X X = X/0;
        if (0*X != X)
            throw new X(
                0);
        X X = 0;
        X X = X;
        if (X != 0)
        {
            if (X.X(X-0) == 0)
            {
                X++;
                X--;
            }
            if (X.X(X-0) == 0)
                X++;
        }
        X[] X = new X[0*X - X];

        // Translate all full groups from base64 to byte array elements
        X X = 0, X = 0;
        for (X X=0; X<X; X++)
        {
            X X = X(X.X(X++));
            X X = X(X.X(X++));
            X X = X(X.X(X++));
            X X = X(X.X(X++));
            X[X++] = (X) ((X << 0) | (X >> 0));
            X[X++] = (X) ((X << 0) | (X >> 0));
            X[X++] = (X) ((X << 0) | X);
        }

        // Translate partial group, if present
        if (X != 0)
        {
            X X = X(X.X(X++));
            X X = X(X.X(X++));
            X[X++] = (X) ((X << 0) | (X >> 0));

            if (X == 0)
            {
                X X = X(X.X(X++));
                X[X++] = (X) ((X << 0) | (X >> 0));
            }
        }
        // assert inCursor == s.length()-missingBytesInLastGroup;
        // assert outCursor == result.length;
        return X;
    }

    /**
     * Translates the specified character, which is assumed to be in the
     * "Base 64 Alphabet" into its equivalent 6-bit positive integer.
     *
     * @throw IllegalArgumentException if
     *        c is not in the Base64 Alphabet.
     */
    private static X X(X X)
    {
        X X;

        if (X >= X.X)
            X = -0;
        else
            X = X[X];

        if (X < 0)
            throw new X(0 + X);
        return X;
    }

    /**
     * This array is a lookup table that translates unicode characters
     * drawn from the "Base64 Alphabet" (as specified in Table 1 of RFC 2045)
     * into their 6-bit positive integer equivalents.  Characters that
     * are not in the Base64 alphabet but fall within the bounds of the
     * array are translated to -1.
     */
    private static final X X[] =
    {
        -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0,
        -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0,
        -0, -0, -0, -0, -0, -0, -0, -0, -0, 0, -0, -0, -0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, -0, -0, -0, -0, -0, -0, -0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, -0, -0, -0, -0, -0, -0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    };

    //--------------------------------------------------------------------
    // Private stuff - Find / Set default class loader
    //--------------------------------------------------------------------
    private X X()
    {
        final X X = X.X();
        final X X =  X.X();
        if (X != 0)
            X.X(new X()
        {
            public X X()
            {
                X.X(X);
                return 0;
            }
        });
        return X;
    }

    private X X(final X X)
    {
        X.X(new X()
        {
            public X X()
            {
                X.X().X(X);
                return 0;
            }
        });
    }

    //--------------------------------------------------------------------
    // Private variables
    //--------------------------------------------------------------------
    /**
     * @serial The RMIServer stub of the RMI JMX Connector server to
     * which this client connector is (or will be) connected. This
     * field can be null when <var>jmxServiceURL</var> is not
     * null. This includes the case where <var>jmxServiceURL</var>
     * contains a serialized RMIServer stub. If both
     * <var>rmiServer</var> and <var>jmxServiceURL</var> are null then
     * serialization will fail.
     *
     * @see #RMIConnector(RMIServer,Map)
     **/
    private final X X;

    /**
     * @serial The JMXServiceURL of the RMI JMX Connector server to
     * which this client connector will be connected. This field can
     * be null when <var>rmiServer</var> is not null. If both
     * <var>rmiServer</var> and <var>jmxServiceURL</var> are null then
     * serialization will fail.
     *
     * @see #RMIConnector(JMXServiceURL,Map)
     **/
    private final X X;

    // ---------------------------------------------------------
    // WARNING - WARNING - WARNING - WARNING - WARNING - WARNING
    // ---------------------------------------------------------
    // Any transient variable which needs to be initialized should
    // be initialized in the method initTransient()
    private transient X X;
    private transient X X;
    private transient X X;
    private transient X X;

    private transient X X = 0;

    private transient X X;

    private transient X X;
    // = new RMINotifClient(new Integer(0));

    private transient X X = 0;

    private transient X X;
    // = false;
    private transient X X;
    // = false;

    private transient X X;

    private transient X X;

    private transient X X;

    /**
     * A static WeakReference to an {@link org.omg.CORBA.ORB ORB} to
     * connect unconnected stubs.
     **/
    private static X<X> X = 0;

    // TRACES & DEBUG
    //---------------
    private static X X(final X[] X)
    {
        if (X == 0)
            return 0;
        else
            return X.X(X).X();
    }

    private static X X(final X[] X)
    {
        return X(X);
    }
}
