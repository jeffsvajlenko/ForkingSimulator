/*
 * Copyright 2001-2004 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package X.X.X.X.X.X.X.X.X;

import X.X.X;

import X.X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X;
import X.X.X.X;
import X.X.X.X;
import X.X.X.X;

/**
 * Class <code>XSDAbstractTraverser</code> serves as the base class for all
 * other <code>XSD???Traverser</code>s. It holds the common data and provide
 * a unified way to initialize these data.
 *
 * @xerces.internal
 *
 * @author Elena Litani, IBM
 * @author Rahul Srivastava, Sun Microsystems Inc.
 * @author Neeraj Bajaj, Sun Microsystems Inc.
 *
 * @version $Id: XSDAbstractTraverser.java,v 1.4 2007/07/19 04:38:48 ofung Exp $
 */
abstract class X
{

    protected static final X X      = 0;

    // Flags for checkOccurrences to indicate any special
    // restrictions on minOccurs and maxOccurs relating to "all".
    //    NOT_ALL_CONTEXT    - not processing an <all>
    //    PROCESSING_ALL_EL  - processing an <element> in an <all>
    //    GROUP_REF_WITH_ALL - processing <group> reference that contained <all>
    //    CHILD_OF_GROUP     - processing a child of a model group definition
    //    PROCESSING_ALL_GP  - processing an <all> group itself

    protected static final X X    = 0;
    protected static final X X  = 0;
    protected static final X X = 0;
    protected static final X X     = 0;
    protected static final X X  = 0;

    //Shared data
    protected X            X = 0;
    protected X           X = 0;
    protected X    X = 0;
    protected X               X = 0;

    // used to validate default/fixed attribute values
    X X = new X();

    X (X X,
                          X X)
    {
        X = X;
        X = X;
    }

    X X(X X, X X)
    {
        X = X;
        X = X;
        X.X(0);
        X.X(X);
    }

    // traverse the annotation declaration
    // REVISIT: how to pass the parentAttrs? as DOM attributes?
    //          as name/value pairs (string)? in parsed form?
    // @return XSAnnotationImpl object
    X X(X X, X[] X,
                                            X X, X X)
    {
        // General Attribute Checking
        X[] X = X.X(X, X, X);
        X.X(X, X);

        X X = 0;
        X X = X.X(X);
        if (X != 0)
        {
            do
            {
                X X = X.X(X);

                // the only valid children of "annotation" are
                // "appinfo" and "documentation"
                if (!((X.X(X.X)) ||
                        (X.X(X.X))))
                {
                    X(0, new X[] {X}, X);
                }
                else     // the annotation, as we currently know it, is a Text child
                {
                    X X = X.X();
                    if(X != 0 && X.X() == X.X)
                    {
                        X = ((X)X).X();
                    }
                }

                // General Attribute Checking
                // There is no difference between global or local appinfo/documentation,
                // so we assume it's always global.
                X = X.X(X, 0, X);
                X.X(X, X);

                X = X.X(X);
            }
            while (X != 0);
        }
        // REVISIT: When an annotation has no <documentation> or
        // <appinfo> children the text child is stored on the first child of its
        // parent. Only if the annotation is the first child will we find the
        // text node there. See SchemaDOM. We need to store the string representation
        // in a consistent place so it can be reliably retrieved, perhaps as
        // user data. -- mrglavas
        else
        {
            X X = X.X();
            if(X != 0 && X.X() == X.X)
            {
                X = ((X)X).X();
            }
        }
        // if contents was null, must have been some kind of error;
        // nothing to contribute to PSVI
        if (X == 0) return 0;

        // find the grammar; fSchemaHandler must be known!
        X X = X.X(X.X);
        // fish out local attributes passed from parent
        X X = (X)X[X.X];
        // optimize for case where there are no local attributes
        if(X != 0 && !X.X())
        {
            X X = new X(0);
            X.X(0);
            // Vector should contain rawname value pairs
            X X = 0;
            while (X < X.X())
            {
                X X = (X)X.X(X++);
                X X = X.X(0);
                X X, X;
                if (X == -0)
                {
                    X = 0;
                    X = X;
                }
                else
                {
                    X = X.X(0,X);
                    X = X.X(X+0);
                }
                X X = X.X.X(X.X());
                if (!X.X(X, X).X(0))
                {
                    X++; // skip the next value, too
                    continue;
                }
                X.X(X)
                .X(0);
                X X = (X)X.X(X++);
                // search for pesky "s and >s within attr value:
                X = X(X);
                X.X(X)
                .X(0);
            }
            // and now splice it into place; immediately after the annotation token, for simplicity's sake
            X X = new X(X.X() + X.X());
            X X = X.X(X.X);
            // annotation must occur somewhere or we're in big trouble...
            if(X == -0) return 0;
            X += X.X.X();
            X.X(X.X(0,X));
            X.X(X.X());
            X.X(X.X(X, X.X()));
            final X X = X.X();
            if (X)
            {
                X.X(new X(X, X));
            }
            return new X(X, X);
        }
        else
        {
            if (X)
            {
                X.X(new X(X, X));
            }
            return new X(X, X);
        }

    }

    X X(X X, X X,
            X[] X, X X, X X)
    {

        X X = X;

        // find the grammar; fSchemaHandler must be known!
        X X = X.X(X.X);
        // fish out local attributes passed from parent
        X X = (X)X[X.X];
        // optimize for case where there are no local attributes
        if (X != 0 && !X.X())
        {
            X X = new X(0);
            X.X(0);
            // Vector should contain rawname value pairs
            X X = 0;
            while (X < X.X())
            {
                X X = (X)X.X(X++);
                X X = X.X(0);
                X X, X;
                if (X == -0)
                {
                    X = 0;
                    X = X;
                }
                else
                {
                    X = X.X(0,X);
                    X = X.X(X+0);
                }
                X X = X.X.X(X.X());
                X.X(X)
                .X(0);
                X X = (X)X.X(X++);
                // search for pesky "s and >s within attr value:
                X = X(X);
                X.X(X)
                .X(0);
            }
            // and now splice it into place; immediately after the annotation token, for simplicity's sake
            X X = new X(X.X() + X.X());
            X X = X.X(X.X);
            // annotation must occur somewhere or we're in big trouble...
            if(X == -0) return 0;
            X += X.X.X();
            X.X(X.X(0,X));
            X.X(X.X());
            X.X(X.X(X, X.X()));
            final X X = X.X();
            if (X)
            {
                X.X(new X(X, X));
            }
            return new X(X, X);
        }
        else
        {
            if (X)
            {
                X.X(new X(X, X));
            }
            return new X(X, X);
        }
    }

    // the QName simple type used to resolve qnames
    private static final X X = (X)X.X.X(X.X);
    // Temp data structures to be re-used in traversing facets
    private X X = new X();
    private final X X = new X();

    class X
    {
        X X;
        X X;
        X X;
        X X;
    }

    X X(X X,
                             X X,
                             X X)
    {

        X X = 0 ;
        X X = 0; // facets that have fixed="true"
        X X;
        X X = X(X);
        X X = 0;
        X X = 0;
        X X = 0;
        X X = X ? new X() : 0;
        X X = 0;
        X.X();
        while (X != 0)
        {
            // General Attribute Checking
            X[] X = 0;
            X = X.X(X);
            if (X.X(X.X))
            {
                X = X.X(X, 0, X, X);
                X X = (X)X[X.X];
                X X = (X)X[X.X];

                // for NOTATION types, need to check whether there is a notation
                // declared with the same name as the enumeration value.
                if (X.X() == X.X &&
                        X.X() == X.X)
                {
                    // need to use the namespace context returned from checkAttributes
                    X.X.X(X);
                    try
                    {
                        X X = (X)X.X(X, X.X, 0);
                        // try to get the notation decl. if failed, getGlobalDecl
                        // reports an error, so we don't need to report one again.
                        X.X(X, X.X, X, X);
                    }
                    catch(X X)
                    {
                        X(X.X(), X.X(), X);
                    }
                    // restore to the normal namespace context
                    X.X.X(X.X);
                }
                if (X == 0)
                {
                    X = new X();
                    X = new X();
                }
                X.X(X);
                X.X(0);
                if (X)
                    X.X(X);
                X X = X.X( X );

                if (X != 0)
                {
                    // traverse annotation if any

                    if (X.X(X).X(X.X))
                    {
                        X.X(X.X()-0,X(X, X, 0, X));
                        X = X.X(X);
                    }
                    else
                    {
                        X X = X.X(X);
                        if (X != 0)
                        {
                            X.X(X.X()-0, X(X, X, X, 0, X));
                        }
                    }
                    if (X !=0 && X.X(X).X(X.X))
                    {
                        X(0, new X[] {0, 0, X.X(X)}, X);
                    }
                }
                else
                {
                    X X = X.X(X);
                    if (X != 0)
                    {
                        X.X(X.X() - 0, X(X, X, X, 0, X));
                    }
                }
            }
            else if (X.X(X.X))
            {
                X = X.X(X, 0, X);
                if (X.X() == 0)
                {
                    X.X((X)X[X.X]);
                }
                else
                {
                    // ---------------------------------------------
                    //datatypes: 5.2.4 pattern: src-multiple-pattern
                    // ---------------------------------------------
                    X.X(0);
                    X.X((X)X[X.X]);
                }
                X X = X.X( X );
                if (X != 0)
                {
                    // traverse annotation if any
                    if (X.X(X).X(X.X))
                    {
                        if (X == 0)
                        {
                            X = new X();
                        }
                        X.X(X(X, X, 0, X));
                        X = X.X(X);
                    }
                    if (X !=0 && X.X(X).X(X.X))
                    {
                        X(0, new X[] {0, 0, X.X(X)}, X);
                    }
                }

            }
            else
            {
                if (X.X(X.X))
                {
                    X = X.X;
                }
                else if (X.X(X.X))
                {
                    X = X.X;
                }
                else if (X.X(X.X))
                {
                    X = X.X;
                }
                else if (X.X(X.X))
                {
                    X = X.X;
                }
                else if (X.X(X.X))
                {
                    X = X.X;
                }
                else if (X.X(X.X))
                {
                    X = X.X;
                }
                else if (X.X(X.X))
                {
                    X = X.X;
                }
                else if (X.X(X.X))
                {
                    X = X.X;
                }
                else if (X.X(X.X))
                {
                    X = X.X;
                }
                else if (X.X(X.X))
                {
                    X = X.X;
                }
                else
                {
                    break;   // a non-facet
                }

                X = X.X(X, 0, X);

                // check for duplicate facets
                if ((X & X) != 0)
                {
                    X(0, new X[] {X}, X);
                }
                else if (X[X.X] != 0)
                {
                    X |= X;
                    // check for fixed facet
                    if (((X)X[X.X]).X())
                    {
                        X |= X;
                    }
                    switch (X)
                    {
                    case X.X:
                        X.X = ((X)X[X.X]).X();
                        break;
                    case X.X:
                        X.X = ((X)X[X.X]).X();
                        break;
                    case X.X:
                        X.X = (X)X[X.X];
                        break;
                    case X.X:
                        X.X = (X)X[X.X];
                        break;
                    case X.X:
                        X.X = (X)X[X.X];
                        break;
                    case X.X:
                        X.X = (X)X[X.X];
                        break;
                    case X.X:
                        X.X = ((X)X[X.X]).X();
                        break;
                    case X.X:
                        X.X = ((X)X[X.X]).X();
                        break;
                    case X.X:
                        X.X = ((X)X[X.X]).X();
                        break;
                    case X.X:
                        X.X = ((X)X[X.X]).X();
                        break;
                    }
                }

                X X = X.X( X );
                if (X != 0)
                {
                    // traverse annotation if any
                    if (X.X(X).X(X.X))
                    {
                        X X = X(X, X, 0, X);
                        switch (X)
                        {
                        case X.X:
                            X.X = X;
                            break;
                        case X.X:
                            X.X = X;
                            break;
                        case X.X:
                            X.X = X;
                            break;
                        case X.X:
                            X.X = X;
                            break;
                        case X.X:
                            X.X = X;
                            break;
                        case X.X:
                            X.X = X;
                            break;
                        case X.X:
                            X.X = X;
                            break;
                        case X.X:
                            X.X = X;
                            break;
                        case X.X:
                            X.X = X;
                            break;
                        case X.X:
                            X.X = X;
                            break;
                        }


                        X = X.X(X);
                    }
                    else
                    {
                        X X = X.X(X);
                        if (X != 0)
                        {
                            X X = X(X, X, X, 0, X);
                            switch (X)
                            {
                            case X.X:
                                X.X = X;
                                break;
                            case X.X:
                                X.X = X;
                                break;
                            case X.X:
                                X.X = X;
                                break;
                            case X.X:
                                X.X = X;
                                break;
                            case X.X:
                                X.X = X;
                                break;
                            case X.X:
                                X.X = X;
                                break;
                            case X.X:
                                X.X = X;
                                break;
                            case X.X:
                                X.X = X;
                                break;
                            case X.X:
                                X.X = X;
                                break;
                            case X.X:
                                X.X = X;
                                break;
                            }
                        }
                    }
                    if (X != 0 && X.X(X).X(X.X))
                    {
                        X(0, new X[] {X, 0, X.X(X)}, X);
                    }
                }
            }
            X.X (X, X);
            X = X.X(X);
        }
        if (X !=0)
        {
            X |= X.X;
            X.X = X;
            X.X = X;
            X.X = X;
        }
        if (X.X() != 0)
        {
            X |= X.X;
            X.X = X.X();
            X.X = X;
        }

        X.X(0);

        X X = new X();
        X.X = X;
        X.X = X;
        X.X = X;
        X.X = X;
        return X;
    }


    // return whether QName/NOTATION is part of the given type
    private X X(X X)
    {
        if (X.X() == X.X)
        {
            X X = X.X();
            return (X == X.X ||
                    X == X.X);
        }
        else if (X.X() == X.X)
        {
            return X((X)X.X());
        }
        else if (X.X() == X.X)
        {
            X X = X.X();
            for (X X = 0; X < X.X(); X++)
            {
                if (X((X)X.X(X)))
                    return 0;
            }
        }
        return 0;
    }

    //
    // Traverse a set of attribute and attribute group elements
    // Needed by complexType and attributeGroup traversal
    // This method will return the first non-attribute/attrgrp found
    //
    X X(X X, X X,
                                     X X, X X,
                                     X X)
    {

        X X=0;
        X X = 0;
        X X = 0;
        X X;

        for (X=X; X!=0; X=X.X(X))
        {
            X = X.X(X);
            if (X.X(X.X))
            {
                X = X.X.X(X,
                              X,
                              X,
                              X);
                if (X == 0) break;
                if (X.X(X.X.X(),
                                            X.X.X())==0)
                {
                    X X = X.X(X);
                    if (X != 0)
                    {
                        X X = (X == 0) ? 0 : 0;
                        X X = (X == 0) ? X.X : X.X();
                        X(X, new X[] {X, X.X.X(), X}, X);
                    }
                }
                else
                {
                    // REVISIT: what if one of the attribute uses is "prohibited"
                    X X = (X == 0) ? 0 : 0;
                    X X = (X == 0) ? X.X : X.X();
                    X(X, new X[] {X, X.X.X()}, X);
                }
            }
            else if (X.X(X.X))
            {
                //REVISIT: do we need to save some state at this point??
                X = X.X.X(
                                  X, X, X);
                if(X == 0 ) break;
                X X = X.X();
                X X = 0, X;
                X X = X.X();
                for (X X=0; X<X; X++)
                {
                    X = (X)X.X(X);
                    if (X == X.X(X.X.X(),
                            X.X.X()))
                    {
                        X X = X.X(X);
                        if (X != 0)
                        {
                            X X = (X == 0) ? 0 : 0;
                            X X = (X == 0) ? X.X : X.X();
                            X(X, new X[] {X, X.X.X(), X}, X);
                        }
                    }
                    else
                    {
                        // REVISIT: what if one of the attribute uses is "prohibited"
                        X X = (X == 0) ? 0 : 0;
                        X X = (X == 0) ? X.X : X.X();
                        X(X, new X[] {X, X.X.X()}, X);
                    }
                }

                if (X.X != 0)
                {
                    if (X.X == 0)
                    {
                        X.X = X.X;
                    }
                    // perform intersection of attribute wildcard
                    else
                    {
                        X.X = X.X.
                                               X(X.X, X.X.X);
                        if (X.X == 0)
                        {
                            X X = (X == 0) ? 0 : 0;
                            X X = (X == 0) ? X.X : X.X();
                            X(X, new X[] {X}, X);
                        }
                    }
                }
            }
            else
                break;
        } // for

        if (X != 0)
        {
            X = X.X(X);
            if (X.X(X.X))
            {
                X X = X.X.
                                            X(X, X, X);
                if (X.X == 0)
                {
                    X.X = X;
                }
                // perform intersection of attribute wildcard
                else
                {
                    X.X = X.
                                           X(X.X, X.X);
                    if (X.X == 0)
                    {
                        X X = (X == 0) ? 0 : 0;
                        X X = (X == 0) ? X.X : X.X();
                        X(X, new X[] {X}, X);
                    }
                }
                X = X.X(X);
            }
        }

        // Success
        return X;

    }

    X X (X X, X[] X, X X)
    {
        X.X(X, X, X);
    }

    /**
     * Element/Attribute traversers call this method to check whether
     * the type is NOTATION without enumeration facet
     */
    X X(X X, X X, X X)
    {
        if (X.X() == X.X &&
                ((X)X).X() == X.X &&
                ((X)X).X() == X.X)
        {
            if ((((X)X).X() & X.X) == 0)
            {
                X(0, new X[] {X.X(), X, X.X(X)}, X);
            }
        }
    }

    // Checks constraints for minOccurs, maxOccurs
    protected X X(X X,
            X X, X X,
            X X,
            X X)
    {

        X X = X.X;
        X X = X.X;
        X X = (X & (0 << X.X)) != 0;
        X X = (X & (0 << X.X)) != 0;

        X X = ((X & X) != 0);
        X X = ((X & X) != 0);
        X X = ((X & X) != 0);
        X X    = ((X & X) != 0);

        // Neither minOccurs nor maxOccurs may be specified
        // for the child of a model group definition.
        if (X)
        {
            if (!X)
            {
                X[] X = new X[] {X, 0};
                X(0, X, X);
                X = 0;
            }
            if (!X)
            {
                X[] X = new X[] {X, 0};
                X(0, X, X);
                X = 0;
            }
        }

        // If minOccurs=maxOccurs=0, no component is specified
        if (X == 0 && X== 0)
        {
            X.X = X.X;
            return 0;
        }

        // For the elements referenced in an <all>, minOccurs attribute
        // must be zero or one, and maxOccurs attribute must be one.
        // For a complex type definition that contains an <all> or a
        // reference a <group> whose model group is an all model group,
        // minOccurs and maxOccurs must be one.
        if (X)
        {
            if (X != 0)
            {
                X(0, new X[] {new X(X),
                                      ((X)X.X).X()
                }, X);
                X = 0;
                if (X > 0)
                    X = 0;
            }
        }
        else if (X || X)
        {
            if (X != 0)
            {
                X(0, 0, X);
                if (X > 0)
                    X = 0;
                X = 0;
            }
        }

        X.X = X;
        X.X = X;

        return X;
    }

    // this is not terribly performant!
    private static X X(X X)
    {
        // normally, nothing will happen
        X X = new X(X.X());
        for(X X=0; X<X.X(); X++)
        {
            X X = X.X(X);
            if(X == 0)
            {
                X.X(0);
            }
            else if (X == 0)
            {
                X.X(0);
            }
            else if (X == 0)
            {
                X.X(0);
            }
            else
            {
                X.X(X);
            }
        }
        return X.X();
    }
}
