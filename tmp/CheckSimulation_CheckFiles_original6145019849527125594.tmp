/*
 * Copyright 1999-2004 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


// Sep 14, 2000:
//  Fixed serializer to report IO exception directly, instead at
//  the end of document processing.
//  Reported by Patrick Higgins <phiggins@transzap.com>
// Aug 21, 2000:
//  Fixed bug in startDocument not calling prepare.
//  Reported by Mikael Staldal <d96-mst-ingen-reklam@d.kth.se>
// Aug 21, 2000:
//  Added ability to omit DOCTYPE declaration.
// Sep 1, 2000:
//   If no output format is provided the serializer now defaults
//   to ISO-8859-1 encoding. Reported by Mikael Staldal
//   <d96-mst@d.kth.se>


package X.X.X.X.X.X.X;

import X.X.X.X.X.X.X.X;

import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;

import X.X.X.X;
import X.X.X.X;
import X.X.X.X;
import X.X.X.X;
import X.X.X.X;
import X.X.X.X;
import X.X.X.X;


/**
 * Implements an HTML/XHTML serializer supporting both DOM and SAX
 * pretty serializing. HTML/XHTML mode is determined in the
 * constructor.  For usage instructions see {@link Serializer}.
 * <p>
 * If an output stream is used, the encoding is taken from the
 * output format (defaults to <tt>UTF-8</tt>). If a writer is
 * used, make sure the writer uses the same encoding (if applies)
 * as specified in the output format.
 * <p>
 * The serializer supports both DOM and SAX. DOM serializing is done
 * by calling {@link #serialize} and SAX serializing is done by firing
 * SAX events and using the serializer as a document handler.
 * <p>
 * If an I/O exception occurs while serializing, the serializer
 * will not throw an exception directly, but only throw it
 * at the end of serializing (either DOM or SAX's {@link
 * org.xml.sax.DocumentHandler#endDocument}.
 * <p>
 * For elements that are not specified as whitespace preserving,
 * the serializer will potentially break long text lines at space
 * boundaries, indent lines, and serialize elements on separate
 * lines. Line terminators will be regarded as spaces, and
 * spaces at beginning of line will be stripped.
 * <p>
 * XHTML is slightly different than HTML:
 * <ul>
 * <li>Element/attribute names are lower case and case matters
 * <li>Attributes must specify value, even if empty string
 * <li>Empty elements must have '/' in empty tag
 * <li>Contents of SCRIPT and STYLE elements serialized as CDATA
 * </ul>
 *
 * @deprecated This class was deprecated in Xerces 2.6.2. It is
 * recommended that new applications use JAXP's Transformation API
 * for XML (TrAX) for serializing HTML. See the Xerces documentation
 * for more information.
 * @version $Revision: 1.4 $ $Date: 2007/07/19 04:39:18 $
 * @author <a href="mailto:arkin@intalio.com">Assaf Arkin</a>
 * @see Serializer
 */
public class X
    extends X
{


    /**
     * True if serializing in XHTML format.
     */
    private X X;


    public static final X X = 0;

    // for users to override XHTMLNamespace if need be.
    private X X = 0;


    /**
     * Constructs a new HTML/XHTML serializer depending on the value of
     * <tt>xhtml</tt>. The serializer cannot be used without calling
     * {@link #setOutputCharStream} or {@link #setOutputByteStream} first.
     *
     * @param xhtml True if XHTML serializing
     */
    protected X( X X, X X )
    {
        X( X );
        X = X;
    }


    /**
     * Constructs a new serializer. The serializer cannot be used without
     * calling {@link #setOutputCharStream} or {@link #setOutputByteStream}
     * first.
     */
    public X()
    {
        X( 0, new X( X.X, 0, 0 ) );
    }


    /**
     * Constructs a new serializer. The serializer cannot be used without
     * calling {@link #setOutputCharStream} or {@link #setOutputByteStream}
     * first.
     */
    public X( X X )
    {
        X( 0, X != 0 ? X : new X( X.X, 0, 0 ) );
    }



    /**
     * Constructs a new serializer that writes to the specified writer
     * using the specified output format. If <tt>format</tt> is null,
     * will use a default output format.
     *
     * @param writer The writer to use
     * @param format The output format to use, null for the default
     */
    public X( X X, X X )
    {
        X( 0, X != 0 ? X : new X( X.X, 0, 0 ) );
        X( X );
    }


    /**
     * Constructs a new serializer that writes to the specified output
     * stream using the specified output format. If <tt>format</tt>
     * is null, will use a default output format.
     *
     * @param output The output stream to use
     * @param format The output format to use, null for the default
     */
    public X( X X, X X )
    {
        X( 0, X != 0 ? X : new X( X.X, 0, 0 ) );
        X( X );
    }


    public X X( X X )
    {
        X.X( X != 0 ? X : new X( X.X, 0, 0 ) );
    }

    // Set  value for alternate XHTML namespace.
    public X X(X X)
    {
        X = X;
    } // setXHTMLNamespace(String)

    //-----------------------------------------//
    // SAX content handler serializing methods //
    //-----------------------------------------//


    public X X( X X, X X,
                              X X, X X )
    throws X
    {
        X          X;
        X      X;
        X X;
        X       X;
        X       X;
        X       X;
        X      X = 0;

        try
        {
            if ( X == 0 )
                throw new X(
                    X.X(
                        X.X,
                        0, 0));

            X = X();
            if ( X() )
            {
                // If this is the root element handle it differently.
                // If the first root element in the document, serialize
                // the document's DOCTYPE. Space preserving defaults
                // to that of the output format.
                if ( ! X )
                    X( (X == 0 || X.X() == 0)
                                   ? X : X );
            }
            else
            {
                // For any other element, if first in parent, then
                // close parent's opening tag and use the parnet's
                // space preserving.
                if ( X.X )
                    X.X( 0 );
                // Indent this element on a new line if the first
                // content of the parent element or immediately
                // following an element.
                if ( X && ! X.X &&
                        ( X.X || X.X ) )
                    X.X();
            }
            X = X.X;

            // Do not change the current element state yet.
            // This only happens in endElement().

            // As per SAX2, the namespace URI is an empty string if the element has no
            // namespace URI, or namespaces is turned off. The check against null protects
            // against broken SAX implementations, so I've left it there. - mrglavas
            X X = (X != 0 && X.X() != 0);

            // SAX2: rawName (QName) could be empty string if
            // namespace-prefixes property is false.
            if ( X == 0 || X.X() == 0)
            {
                X = X;
                if ( X )
                {
                    X X;
                    X = X( X );
                    if ( X != 0 && X.X() != 0 )
                        X = X + 0 + X;
                }
                X = 0;
            }
            if ( !X )
                X = X;
            else
            {
                if ( X.X( X ) ||
                        (X != 0 && X.X(X)) )
                    X = X;
                else
                    X = 0;
            }

            // XHTML: element names are lower case, DOM will be different
            X.X( 0 );
            if ( X )
                X.X( X.X(X.X) );
            else
                X.X( X );
            X.X();

            // For each attribute serialize it's name and value as one part,
            // separated with a space so the element can be broken on
            // multiple lines.
            if ( X != 0 )
            {
                for ( X = 0 ; X < X.X() ; ++X )
                {
                    X.X();
                    X = X.X( X ).X(X.X);
                    X = X.X( X );
                    if ( X || X )
                    {
                        // XHTML: print empty string for null values.
                        if ( X == 0 )
                        {
                            X.X( X );
                            X.X( 0 );
                        }
                        else
                        {
                            X.X( X );
                            X.X( 0 );
                            X( X );
                            X.X( 0 );
                        }
                    }
                    else
                    {
                        // HTML: Empty values print as attribute name, no value.
                        // HTML: URI attributes will print unescaped
                        if ( X == 0 )
                        {
                            X = 0;
                        }
                        if ( !X.X() && X.X() == 0 )
                            X.X( X );
                        else if ( X.X( X, X ) )
                        {
                            X.X( X );
                            X.X( 0 );
                            X.X( X( X ) );
                            X.X( 0 );
                        }
                        else if ( X.X( X, X ) )
                            X.X( X );
                        else
                        {
                            X.X( X );
                            X.X( 0 );
                            X( X );
                            X.X( 0 );
                        }
                    }
                }
            }
            if ( X != 0 && X.X( X ) )
                X = 0;

            if ( X )
            {
                X X;

                X = X.X();
                while ( X.X() )
                {
                    X.X();
                    X = (X) X.X();
                    X = (X) X.X( X );
                    if ( X.X() == 0 )
                    {
                        X.X( 0 );
                        X( X );
                        X.X( 0 );
                    }
                    else
                    {
                        X.X( 0 );
                        X.X( X );
                        X.X( 0 );
                        X( X );
                        X.X( 0 );
                    }
                }
            }

            // Now it's time to enter a new element state
            // with the tag name and space preserving.
            // We still do not change the curent element state.
            X = X( X, X, X, X );

            // Prevents line breaks inside A/TD

            if ( X != 0 && ( X.X( 0 ) ||
                                       X.X( 0 ) ) )
            {
                X.X = 0;
                X.X( 0 );
            }

            // Handle SCRIPT and STYLE specifically by changing the
            // state of the current element to CDATA (XHTML) or
            // unescaped (HTML).
            if ( X != 0 && ( X.X( 0 ) ||
                                       X.X( 0 ) ) )
            {
                if ( X )
                {
                    // XHTML: Print contents as CDATA section
                    X.X = 0;
                }
                else
                {
                    // HTML: Print contents unescaped
                    X.X = 0;
                }
            }
        }
        catch ( X X )
        {
            throw new X( X );
        }
    }


    public X X( X X, X X,
                            X X )
    throws X
    {
        try
        {
            X( X, X, X );
        }
        catch ( X X )
        {
            throw new X( X );
        }
    }


    public X X( X X, X X,
                              X X )
    throws X
    {
        X X;
        X       X;

        // Works much like content() with additions for closing
        // an element. Note the different checks for the closed
        // element's state and the parent element's state.
        X.X();
        X = X();

        if ( X.X == 0 || X.X.X() == 0 )
            X = X.X;
        else
        {
            if ( X.X.X( X ) ||
                    (X != 0 && X.X(X.X)) )
                X = X.X;
            else
                X = 0;
        }

        if ( X)
        {
            if ( X.X )
            {
                X.X( 0 );
            }
            else
            {
                // Must leave CData section first
                if ( X.X )
                    X.X( 0 );
                // XHTML: element names are lower case, DOM will be different
                X.X( 0 );
                X.X( X.X.X(X.X) );
                X.X( 0 );
            }
        }
        else
        {
            if ( X.X )
                X.X( 0 );
            // This element is not empty and that last content was
            // another element, so print a line break before that
            // last element and this element's closing tag.
            // [keith] Provided this is not an anchor.
            // HTML: some elements do not print closing tag (e.g. LI)
            if ( X == 0 || ! X.X( X ) )
            {
                if ( X && ! X.X && X.X )
                    X.X();
                // Must leave CData section first (Illegal in HTML, but still)
                if ( X.X )
                    X.X( 0 );
                X.X( 0 );
                X.X( X.X );
                X.X( 0 );
            }
        }
        // Leave the element state and update that of the parent
        // (if we're not root) to not empty and after element.
        X = X();
        // Temporary hack to prevent line breaks inside A/TD
        if ( X == 0 || ( ! X.X( 0 ) &&
                                   ! X.X( 0 ) ) )

            X.X = 0;
        X.X = 0;
        if ( X() )
            X.X();
    }


    //------------------------------------------//
    // SAX document handler serializing methods //
    //------------------------------------------//


    public X X( X[] X, X X, X X )
    throws X
    {
        X X;

        try
        {
            // HTML: no CDATA section
            X = X();
            X.X = 0;
            X.X( X, X, X );
        }
        catch ( X X )
        {
            throw new X( X );
        }
    }


    public X X( X X, X X )
    throws X
    {
        X          X;
        X      X;
        X X;
        X       X;
        X       X;

        try
        {
            if ( X == 0 )
                throw new X(
                    X.X(
                        X.X,
                        0, 0));


            X = X();
            if ( X() )
            {
                // If this is the root element handle it differently.
                // If the first root element in the document, serialize
                // the document's DOCTYPE. Space preserving defaults
                // to that of the output format.
                if ( ! X )
                    X( X );
            }
            else
            {
                // For any other element, if first in parent, then
                // close parent's opening tag and use the parnet's
                // space preserving.
                if ( X.X )
                    X.X( 0 );
                // Indent this element on a new line if the first
                // content of the parent element or immediately
                // following an element.
                if ( X && ! X.X &&
                        ( X.X || X.X ) )
                    X.X();
            }
            X = X.X;

            // Do not change the current element state yet.
            // This only happens in endElement().

            // XHTML: element names are lower case, DOM will be different
            X.X( 0 );
            if ( X )
                X.X( X.X(X.X) );
            else
                X.X( X );
            X.X();

            // For each attribute serialize it's name and value as one part,
            // separated with a space so the element can be broken on
            // multiple lines.
            if ( X != 0 )
            {
                for ( X = 0 ; X < X.X() ; ++X )
                {
                    X.X();
                    X = X.X( X ).X(X.X);
                    X = X.X( X );
                    if ( X )
                    {
                        // XHTML: print empty string for null values.
                        if ( X == 0 )
                        {
                            X.X( X );
                            X.X( 0 );
                        }
                        else
                        {
                            X.X( X );
                            X.X( 0 );
                            X( X );
                            X.X( 0 );
                        }
                    }
                    else
                    {
                        // HTML: Empty values print as attribute name, no value.
                        // HTML: URI attributes will print unescaped
                        if ( X == 0 )
                        {
                            X = 0;
                        }
                        if ( !X.X() && X.X() == 0 )
                            X.X( X );
                        else if ( X.X( X, X ) )
                        {
                            X.X( X );
                            X.X( 0 );
                            X.X( X( X ) );
                            X.X( 0 );
                        }
                        else if ( X.X( X, X ) )
                            X.X( X );
                        else
                        {
                            X.X( X );
                            X.X( 0 );
                            X( X );
                            X.X( 0 );
                        }
                    }
                }
            }
            if ( X.X( X ) )
                X = 0;

            // Now it's time to enter a new element state
            // with the tag name and space preserving.
            // We still do not change the curent element state.
            X = X( 0, 0, X, X );

            // Prevents line breaks inside A/TD
            if ( X.X( 0 ) || X.X( 0 ) )
            {
                X.X = 0;
                X.X( 0 );
            }

            // Handle SCRIPT and STYLE specifically by changing the
            // state of the current element to CDATA (XHTML) or
            // unescaped (HTML).
            if ( X.X( 0 ) ||
                    X.X( 0 ) )
            {
                if ( X )
                {
                    // XHTML: Print contents as CDATA section
                    X.X = 0;
                }
                else
                {
                    // HTML: Print contents unescaped
                    X.X = 0;
                }
            }
        }
        catch ( X X )
        {
            throw new X( X );
        }
    }


    public X X( X X )
    throws X
    {
        X( 0, 0, X );
    }


    //------------------------------------------//
    // Generic node serializing methods methods //
    //------------------------------------------//


    /**
     * Called to serialize the document's DOCTYPE by the root element.
     * The document type declaration must name the root element,
     * but the root element is only known when that element is serialized,
     * and not at the start of the document.
     * <p>
     * This method will check if it has not been called before ({@link #_started}),
     * will serialize the document type declaration, and will serialize all
     * pre-root comments and PIs that were accumulated in the document
     * (see {@link #serializePreRoot}). Pre-root will be serialized even if
     * this is not the first root element of the document.
     */
    protected X X( X X )
    throws X
    {
        X X;

        // Not supported in HTML/XHTML, but we still have to switch
        // out of DTD mode.
        X.X();
        if ( ! X )
        {
            // If the public and system identifiers were not specified
            // in the output format, use the appropriate ones for HTML
            // or XHTML.
            if ( X == 0 && X == 0 )
            {
                if ( X )
                {
                    X = X.X;
                    X = X.X;
                }
                else
                {
                    X = X.X;
                    X = X.X;
                }
            }

            if ( ! X.X() )
            {
                // XHTML: If public identifier and system identifier
                //  specified, print them, else print just system identifier
                // HTML: If public identifier specified, print it with
                //  system identifier, if specified.
                // XHTML requires that all element names are lower case, so the
                // root on the DOCTYPE must be 'html'. - mrglavas
                if ( X != 0 && ( ! X || X != 0 )  )
                {
                    if (X)
                    {
                        X.X( 0 );
                    }
                    else
                    {
                        X.X( 0 );
                    }
                    X( X );
                    if ( X != 0 )
                    {
                        if ( X )
                        {
                            X.X();
                            X.X( 0 );
                        }
                        else
                            X.X( 0 );
                        X( X );
                    }
                    X.X( 0 );
                    X.X();
                }
                else if ( X != 0 )
                {
                    if (X)
                    {
                        X.X( 0 );
                    }
                    else
                    {
                        X.X( 0 );
                    }
                    X( X );
                    X.X( 0 );
                    X.X();
                }
            }
        }

        X = 0;
        // Always serialize these, even if not te first root element.
        X();
    }


    /**
     * Called to serialize a DOM element. Equivalent to calling {@link
     * #startElement}, {@link #endElement} and serializing everything
     * inbetween, but better optimized.
     */
    protected X X( X X )
    throws X
    {
        X         X;
        X X;
        X          X;
        X         X;
        X X;
        X      X;
        X       X;
        X       X;
        X       X;

        X = X.X();
        X = X();
        if ( X() )
        {
            // If this is the root element handle it differently.
            // If the first root element in the document, serialize
            // the document's DOCTYPE. Space preserving defaults
            // to that of the output format.
            if ( ! X )
                X( X );
        }
        else
        {
            // For any other element, if first in parent, then
            // close parent's opening tag and use the parnet's
            // space preserving.
            if ( X.X )
                X.X( 0 );
            // Indent this element on a new line if the first
            // content of the parent element or immediately
            // following an element.
            if ( X && ! X.X &&
                    ( X.X || X.X ) )
                X.X();
        }
        X = X.X;

        // Do not change the current element state yet.
        // This only happens in endElement().

        // XHTML: element names are lower case, DOM will be different
        X.X( 0 );
        if ( X )
            X.X( X.X(X.X) );
        else
            X.X( X );
        X.X();

        // Lookup the element's attribute, but only print specified
        // attributes. (Unspecified attributes are derived from the DTD.
        // For each attribute print it's name and value as one part,
        // separated with a space so the element can be broken on
        // multiple lines.
        X = X.X();
        if ( X != 0 )
        {
            for ( X = 0 ; X < X.X() ; ++X )
            {
                X = (X) X.X( X );
                X = X.X().X(X.X);
                X = X.X();
                if ( X.X() )
                {
                    X.X();
                    if ( X )
                    {
                        // XHTML: print empty string for null values.
                        if ( X == 0 )
                        {
                            X.X( X );
                            X.X( 0 );
                        }
                        else
                        {
                            X.X( X );
                            X.X( 0 );
                            X( X );
                            X.X( 0 );
                        }
                    }
                    else
                    {
                        // HTML: Empty values print as attribute name, no value.
                        // HTML: URI attributes will print unescaped
                        if ( X == 0 )
                        {
                            X = 0;
                        }
                        if ( !X.X() && X.X() == 0 )
                            X.X( X );
                        else if ( X.X( X, X ) )
                        {
                            X.X( X );
                            X.X( 0 );
                            X.X( X( X ) );
                            X.X( 0 );
                        }
                        else if ( X.X( X, X ) )
                            X.X( X );
                        else
                        {
                            X.X( X );
                            X.X( 0 );
                            X( X );
                            X.X( 0 );
                        }
                    }
                }
            }
        }
        if ( X.X( X ) )
            X = 0;

        // If element has children, or if element is not an empty tag,
        // serialize an opening tag.
        if ( X.X() || ! X.X( X ) )
        {
            // Enter an element state, and serialize the children
            // one by one. Finally, end the element.
            X = X( 0, 0, X, X );

            // Prevents line breaks inside A/TD
            if ( X.X( 0 ) || X.X( 0 ) )
            {
                X.X = 0;
                X.X( 0 );
            }

            // Handle SCRIPT and STYLE specifically by changing the
            // state of the current element to CDATA (XHTML) or
            // unescaped (HTML).
            if ( X.X( 0 ) ||
                    X.X( 0 ) )
            {
                if ( X )
                {
                    // XHTML: Print contents as CDATA section
                    X.X = 0;
                }
                else
                {
                    // HTML: Print contents unescaped
                    X.X = 0;
                }
            }
            X = X.X();
            while ( X != 0 )
            {
                X( X );
                X = X.X();
            }
            X( 0, 0, X );
        }
        else
        {
            X.X();
            // XHTML: Close empty tag with ' />' so it's XML and HTML compatible.
            // HTML: Empty tags are defined as such in DTD no in document.
            if ( X )
                X.X( 0 );
            else
                X.X( 0 );
            // After element but parent element is no longer empty.
            X.X = 0;
            X.X = 0;
            if ( X() )
                X.X();
        }
    }



    protected X X( X X )
    throws X
    {
        X X;

        // HTML: no CDATA section
        X = X();
        X.X( X );
    }


    protected X X( X X )
    {
        return X.X( X );
    }


    protected X X( X X )
    {
        X X;

        // XXX  Apparently Netscape doesn't like if we escape the URI
        //      using %nn, so we leave it as is, just remove any quotes.
        X = X.X( 0 );
        if ( X >= 0 )
            return X.X( 0, X );
        else
            return X;
    }


}




