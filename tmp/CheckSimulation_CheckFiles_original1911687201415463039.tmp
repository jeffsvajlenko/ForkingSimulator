package X.X.X.X.X.X.X;

/* ====================================================================
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2001 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names "Apache" and "Apache Software Foundation" and
 *    "Apache BCEL" must not be used to endorse or promote products
 *    derived from this software without prior written permission. For
 *    written permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache",
 *    "Apache BCEL", nor may "Apache" appear in their name, without
 *    prior written permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

import X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X;
import X.X.*;
import X.X.X;
import X.X.X;
import X.X.X;

/**
 * This class is a container for a list of <a
 * href="Instruction.html">Instruction</a> objects. Instructions can
 * be appended, inserted, moved, deleted, etc.. Instructions are being
 * wrapped into <a
 * href="InstructionHandle.html">InstructionHandles</a> objects that
 * are returned upon append/insert operations. They give the user
 * (read only) access to the list structure, such that it can be traversed and
 * manipulated in a controlled way.
 *
 * A list is finally dumped to a byte code array with <a
 * href="#getByteCode()">getByteCode</a>.
 *
 * @version $Id: InstructionList.java,v 1.1.2.1 2005/07/31 23:45:45 jeffsuttor Exp $
 * @author  <A HREF="mailto:markus.dahm@berlin.de">M. Dahm</A>
 * @see     Instruction
 * @see     InstructionHandle
 * @see BranchHandle
 */
public class X implements X
{
    private X X  = 0, X = 0;
    private X               X = 0; // number of elements in list
    private X[]             X; // byte code offsets corresponding to instructions

    /**
     * Create (empty) instruction list.
     */
    public X() {}

    /**
     * Create instruction list containing one instruction.
     * @param i initial instruction
     */
    public X(X X)
    {
        X(X);
    }

    /**
     * Create instruction list containing one instruction.
     * @param i initial instruction
     */
    public X(X X)
    {
        X(X);
    }

    /**
     * Initialize list with (nonnull) compound instruction. Consumes argument
     * list, i.e., it becomes empty.
     *
     * @param c compound instruction (list)
     */
    public X(X X)
    {
        X(X.X());
    }

    /**
     * Test for empty list.
     */
    public X X()
    {
        return X == 0;    // && end == null
    }

    /**
     * Find the target instruction (handle) that corresponds to the given target
     * position (byte code offset).
     *
     * @param ihs array of instruction handles, i.e. il.getInstructionHandles()
     * @param pos array of positions corresponding to ihs, i.e. il.getInstructionPositions()
     * @param count length of arrays
     * @param target target position to search for
     * @return target position's instruction handle if available
     */
    public static X X(X[] X,
            X[] X, X X,
            X X)
    {
        X X=0, X = X - 0;

        /* Do a binary search since the pos array is orderd.
         */
        do
        {
            X X = (X + X) / 0;
            X X = X[X];

            if(X == X) // target found
                return X[X];
            else if(X < X) // else constrain search area
                X = X - 0;
            else // target > j
                X = X + 0;
        }
        while(X <= X);

        return 0;
    }

    /**
     * Get instruction handle for instruction at byte code position pos.
     * This only works properly, if the list is freshly initialized from a byte array or
     * setPositions() has been called before this method.
     *
     * @param pos byte code position to search for
     * @return target position's instruction handle if available
     */
    public X X(X X)
    {
        X[] X = X();
        return X(X, X, X, X);
    }

    /**
     * Initialize instruction list from byte array.
     *
     * @param code byte array containing the instructions
     */
    public X(X[] X)
    {
        X        X = new X(X);
        X[] X   = new X[X.X];
        X[]               X   = new X[X.X]; // Can't be more than that
        X                 X = 0; // Contains actual length

        /* Pass 1: Create an object for each byte code and append them
         * to the list.
         */
        try
        {
            while(X.X() > 0)
            {
                // Remember byte offset and associate it with the instruction
                X X =  X.X();
                X[X] = X;

                /* Read one instruction from the byte stream, the byte position is set
                 * accordingly.
                 */
                X       X = X.X(X);
                X X;
                if(X instanceof X) // Use proper append() method
                    X = X((X)X);
                else
                    X = X(X);

                X.X(X);
                X[X] = X;

                X++;
            }
        }
        catch(X X)
        {
            throw new X(X.X());
        }

        X = new X[X]; // Trim to proper size
        X.X(X, 0, X, 0, X);

        /* Pass 2: Look for BranchInstruction and update their targets, i.e.,
         * convert offsets to instruction handles.
         */
        for(X X=0; X < X; X++)
        {
            if(X[X] instanceof X)
            {
                X X = (X)X[X].X;
                X X = X.X + X.X(); /* Byte code position:
						   * relative -> absolute. */
                // Search for target position
                X X = X(X, X, X, X);

                if(X == 0) // Search failed
                    throw new X(0 + X);

                X.X(X); // Update target

                // If it is a Select instruction, update all branch targets
                if(X instanceof X)   // Either LOOKUPSWITCH or TABLESWITCH
                {
                    X X       = (X)X;
                    X[]  X = X.X();

                    for(X X=0; X < X.X; X++)
                    {
                        X = X.X + X[X];
                        X     = X(X, X, X, X);

                        if(X == 0) // Search failed
                            throw new X(0 + X);

                        X.X(X, X); // Update target
                    }
                }
            }
        }
    }

    /**
     * Append another list after instruction (handle) ih contained in this list.
     * Consumes argument list, i.e., it becomes empty.
     *
     * @param ih where to append the instruction list
     * @param il Instruction list to append to this one
     * @return instruction handle pointing to the <B>first</B> appended instruction
     */
    public X X(X X, X X)
    {
        if(X == 0)
            throw new X(0);

        if(X.X()) // Nothing to do
            return X;

        X X = X.X, X = X.X;

        X.X = X.X;
        X.X.X = X;

        X.X.X = X;

        if(X != 0) // i == end ?
            X.X = X.X;
        else
            X = X.X; // Update end ...

        X += X.X; // Update length

        X.X();

        return X;
    }

    /**
     * Append another list after instruction i contained in this list.
     * Consumes argument list, i.e., it becomes empty.
     *
     * @param i  where to append the instruction list
     * @param il Instruction list to append to this one
     * @return instruction handle pointing to the <B>first</B> appended instruction
     */
    public X X(X X, X X)
    {
        X X;

        if((X = X(X)) == 0) // Also applies for empty list
            throw new X(0 + X +
                                        0);

        return X(X, X);
    }

    /**
     * Append another list to this one.
     * Consumes argument list, i.e., it becomes empty.
     *
     * @param il list to append to end of this list
     * @return instruction handle of the <B>first</B> appended instruction
     */
    public X X(X X)
    {
        if(X == 0)
            throw new X(0);

        if(X.X()) // Nothing to do
            return 0;

        if(X())
        {
            X  = X.X;
            X    = X.X;
            X = X.X;

            X.X();

            return X;
        }
        else
            return X(X, X);  // was end.instruction
    }

    /**
     * Append an instruction to the end of this list.
     *
     * @param ih instruction to append
     */
    private X X(X X)
    {
        if(X())
        {
            X = X = X;
            X.X = X.X = 0;
        }
        else
        {
            X.X = X;
            X.X  = X;
            X.X  = 0;
            X      = X;
        }

        X++; // Update length
    }

    /**
     * Append an instruction to the end of this list.
     *
     * @param i instruction to append
     * @return instruction handle of the appended instruction
     */
    public X X(X X)
    {
        X X = X.X(X);
        X(X);

        return X;
    }

    /**
     * Append a branch instruction to the end of this list.
     *
     * @param i branch instruction to append
     * @return branch instruction handle of the appended instruction
     */
    public X X(X X)
    {
        X X = X.X(X);
        X(X);

        return X;
    }

    /**
     * Append a single instruction j after another instruction i, which
     * must be in this list of course!
     *
     * @param i Instruction in list
     * @param j Instruction to append after i in list
     * @return instruction handle of the first appended instruction
     */
    public X X(X X, X X)
    {
        return X(X, new X(X));
    }

    /**
     * Append a compound instruction, after instruction i.
     *
     * @param i Instruction in list
     * @param c The composite instruction (containing an InstructionList)
     * @return instruction handle of the first appended instruction
     */
    public X X(X X, X X)
    {
        return X(X, X.X());
    }

    /**
     * Append a compound instruction.
     *
     * @param c The composite instruction (containing an InstructionList)
     * @return instruction handle of the first appended instruction
     */
    public X X(X X)
    {
        return X(X.X());
    }

    /**
     * Append a compound instruction.
     *
     * @param ih where to append the instruction list
     * @param c The composite instruction (containing an InstructionList)
     * @return instruction handle of the first appended instruction
     */
    public X X(X X, X X)
    {
        return X(X, X.X());
    }

    /**
     * Append an instruction after instruction (handle) ih contained in this list.
     *
     * @param ih where to append the instruction list
     * @param i Instruction to append
     * @return instruction handle pointing to the <B>first</B> appended instruction
     */
    public X X(X X, X X)
    {
        return X(X, new X(X));
    }

    /**
     * Append an instruction after instruction (handle) ih contained in this list.
     *
     * @param ih where to append the instruction list
     * @param i Instruction to append
     * @return instruction handle pointing to the <B>first</B> appended instruction
     */
    public X X(X X, X X)
    {
        X    X = X.X(X);
        X X = new X();
        X.X(X);

        X(X, X);

        return X;
    }

    /**
     * Insert another list before Instruction handle ih contained in this list.
     * Consumes argument list, i.e., it becomes empty.
     *
     * @param i  where to append the instruction list
     * @param il Instruction list to insert
     * @return instruction handle of the first inserted instruction
     */
    public X X(X X, X X)
    {
        if(X == 0)
            throw new X(0);

        if(X.X()) // Nothing to do
            return X;

        X X = X.X, X = X.X;

        X.X = X.X;
        X.X.X = X;

        X.X.X = X;

        if(X != 0) // ih == start ?
            X.X = X.X;
        else
            X = X.X; // Update start ...

        X += X.X; // Update length

        X.X();

        return X;
    }

    /**
     * Insert another list.
     *
     * @param il list to insert before start of this list
     * @return instruction handle of the first inserted instruction
     */
    public X X(X X)
    {
        if(X())
        {
            X(X); // Code is identical for this case
            return X;
        }
        else
            return X(X, X);
    }

    /**
     * Insert an instruction at start of this list.
     *
     * @param ih instruction to insert
     */
    private X X(X X)
    {
        if(X())
        {
            X = X = X;
            X.X = X.X = 0;
        }
        else
        {
            X.X = X;
            X.X    = X;
            X.X    = 0;
            X      = X;
        }

        X++;
    }

    /**
     * Insert another list before Instruction i contained in this list.
     * Consumes argument list, i.e., it becomes empty.
     *
     * @param i  where to append the instruction list
     * @param il Instruction list to insert
     * @return instruction handle pointing to the first inserted instruction,
     * i.e., il.getStart()
     */
    public X X(X X, X X)
    {
        X X;

        if((X = X(X)) == 0)
            throw new X(0 + X +
                                        0);

        return X(X, X);
    }

    /**
     * Insert an instruction at start of this list.
     *
     * @param i instruction to insert
     * @return instruction handle of the inserted instruction
     */
    public X X(X X)
    {
        X X = X.X(X);
        X(X);

        return X;
    }

    /**
     * Insert a branch instruction at start of this list.
     *
     * @param i branch instruction to insert
     * @return branch instruction handle of the appended instruction
     */
    public X X(X X)
    {
        X X = X.X(X);
        X(X);
        return X;
    }

    /**
     * Insert a single instruction j before another instruction i, which
     * must be in this list of course!
     *
     * @param i Instruction in list
     * @param j Instruction to insert before i in list
     * @return instruction handle of the first inserted instruction
     */
    public X X(X X, X X)
    {
        return X(X, new X(X));
    }

    /**
     * Insert a compound instruction before instruction i.
     *
     * @param i Instruction in list
     * @param c The composite instruction (containing an InstructionList)
     * @return instruction handle of the first inserted instruction
     */
    public X X(X X, X X)
    {
        return X(X, X.X());
    }

    /**
     * Insert a compound instruction.
     *
     * @param c The composite instruction (containing an InstructionList)
     * @return instruction handle of the first inserted instruction
     */
    public X X(X X)
    {
        return X(X.X());
    }

    /**
     * Insert an instruction before instruction (handle) ih contained in this list.
     *
     * @param ih where to insert to the instruction list
     * @param i Instruction to insert
     * @return instruction handle of the first inserted instruction
     */
    public X X(X X, X X)
    {
        return X(X, new X(X));
    }

    /**
     * Insert a compound instruction.
     *
     * @param ih where to insert the instruction list
     * @param c The composite instruction (containing an InstructionList)
     * @return instruction handle of the first inserted instruction
     */
    public X X(X X, X X)
    {
        return X(X, X.X());
    }

    /**
     * Insert an instruction before instruction (handle) ih contained in this list.
     *
     * @param ih where to insert to the instruction list
     * @param i Instruction to insert
     * @return instruction handle of the first inserted instruction
     */
    public X X(X X, X X)
    {
        X    X = X.X(X);
        X X = new X();
        X.X(X);

        X(X, X);

        return X;
    }

    /**
     * Take all instructions (handles) from "start" to "end" and append them after the
     * new location "target". Of course, "end" must be after "start" and target must
     * not be located withing this range. If you want to move something to the start of
     * the list use null as value for target.<br>
     * Any instruction targeters pointing to handles within the block, keep their targets.
     *
     * @param start  of moved block
     * @param end    of moved block
     * @param target of moved block
     */
    public X X(X X, X X, X X)
    {
        // Step 1: Check constraints

        if((X == 0) || (X == 0))
            throw new X(0 + X + 0 + X);

        if((X == X) || (X == X))
            throw new X(0 + X + 0 + X +
                                        0 + X);

        for(X X = X; X != X.X; X = X.X)
        {
            if(X == 0) // At end of list, end not found yet
                throw new X(0 + X + 0 + X);
            else if(X == X) // target may be null
                throw new X(0 + X + 0 + X +
                                            0 + X);
        }

        // Step 2: Temporarily remove the given instructions from the list

        X X = X.X, X = X.X;

        if(X != 0)
            X.X = X;
        else // start == this.start!
            X.X = X;

        if(X != 0)
            X.X = X;
        else // end == this.end!
            X.X = X;

        X.X = X.X = 0;

        // Step 3: append after target

        if(X == 0)   // append to start of list
        {
            X.X = X.X;
            X.X = X;
        }
        else
        {
            X = X.X;

            X.X = X;
            X.X  = X;
            X.X    = X;

            if(X != 0)
                X.X = X;
        }
    }

    /**
     * Move a single instruction (handle) to a new location.
     *
     * @param ih     moved instruction
     * @param target new location of moved instruction
     */
    public X X(X X, X X)
    {
        X(X, X, X);
    }

    /**
     * Remove from instruction `prev' to instruction `next' both contained
     * in this list. Throws TargetLostException when one of the removed instruction handles
     * is still being targeted.
     *
     * @param prev where to start deleting (predecessor, exclusive)
     * @param next where to end deleting (successor, exclusive)
     */
    private X X(X X, X X)
    throws X
    {
        X X, X; // First and last deleted instruction

        if((X == 0) && (X == 0))   // singleton list
        {
            X = X = X;
            X = X = 0;
        }
        else
        {
            if(X == 0)   // At start of list
            {
                X = X;
                X = X;
            }
            else
            {
                X     = X.X;
                X.X = X;
            }

            if(X == 0)   // At end of list
            {
                X = X;
                X  = X;
            }
            else
            {
                X      = X.X;
                X.X = X;
            }
        }

        X.X = 0; // Completely separated from rest of list
        X.X  = 0;

        X X = new X();

        for(X X=X; X != 0; X = X.X)
            X.X().X(); // e.g. BranchInstructions release their targets

        X X = new X(0);
        for(X X=X; X != 0; X = X)
        {
            X = X.X;
            X--;

            if(X.X())   // Still got targeters?
            {
                X.X(X);
                X.X(X.X(0) + 0);
                X.X = X.X = 0;
            }
            else
                X.X();
        }

        X.X(0);

        if(!X.X())
        {
            X[] X = new X[X.X()];
            X.X(X);
            throw new X(X, X.X());
        }
    }

    /**
     * Remove instruction from this list. The corresponding Instruction
     * handles must not be reused!
     *
     * @param ih instruction (handle) to remove
     */
    public X X(X X) throws X
    {
        X(X.X, X.X);
    }

    /**
     * Remove instruction from this list. The corresponding Instruction
     * handles must not be reused!
     *
     * @param i instruction to remove
     */
    public X X(X X) throws X
    {
        X X;

        if((X = X(X)) == 0)
            throw new X(0 + X +
                                        0);
        X(X);
    }

    /**
     * Remove instructions from instruction `from' to instruction `to' contained
     * in this list. The user must ensure that `from' is an instruction before
     * `to', or risk havoc. The corresponding Instruction handles must not be reused!
     *
     * @param from where to start deleting (inclusive)
     * @param to   where to end deleting (inclusive)
     */
    public X X(X X, X X)
    throws X
    {
        X(X.X, X.X);
    }

    /**
     * Remove instructions from instruction `from' to instruction `to' contained
     * in this list. The user must ensure that `from' is an instruction before
     * `to', or risk havoc. The corresponding Instruction handles must not be reused!
     *
     * @param from where to start deleting (inclusive)
     * @param to   where to end deleting (inclusive)
     */
    public X X(X X, X X) throws X
    {
        X X, X;

        if((X = X(X)) == 0)
            throw new X(0 + X +
                                        0);

        if((X = X(X)) == 0)
            throw new X(0 + X +
                                        0);
        X(X, X);
    }

    /**
     * Search for given Instruction reference, start at beginning of list.
     *
     * @param i instruction to search for
     * @return instruction found on success, null otherwise
     */
    private X X(X X)
    {
        for(X X=X; X != 0; X = X.X)
            if(X.X == X)
                return X;

        return 0;
    }

    /**
     * Search for given Instruction reference, start at end of list
     *
     * @param i instruction to search for
     * @return instruction found on success, null otherwise
     */
    private X X(X X)
    {
        for(X X=X; X != 0; X = X.X)
            if(X.X == X)
                return X;

        return 0;
    }

    public X X(X X)
    {
        if(X == 0)
            return 0;

        for(X X=X; X != 0; X = X.X)
            if(X == X)
                return 0;

        return 0;
    }

    public X X(X X)
    {
        return X(X) != 0;
    }

    public X X()
    {
        X(0);
    }

    /**
     * Give all instructions their position number (offset in byte stream), i.e.,
     * make the list ready to be dumped.
     *
     * @param check Perform sanity checks, e.g. if all targeted instructions really belong
     * to this list
     */
    public X X(X X)
    {
        X X = 0, X = 0;
        X X = 0, X = 0;
        X[] X = new X[X];

        /* Pass 0: Sanity checks
         */
        if(X)
        {
            for(X X=X; X != 0; X = X.X)
            {
                X X = X.X;

                if(X instanceof X)   // target instruction within list?
                {
                    X X = ((X)X).X().X;
                    if(!X(X))
                        throw new X(0 +
                                                    X.X[X.X] + 0 +
                                                    X + 0);

                    if(X instanceof X)
                    {
                        X[] X = ((X)X).X();

                        for(X X=0; X < X.X; X++)
                        {
                            X = X[X].X;
                            if(!X(X))
                                throw new X(0 +
                                                            X.X[X.X] + 0 +
                                                            X + 0);
                        }
                    }

                    if(!(X instanceof X))
                        throw new X(0 +
                                                    X.X[X.X] + 0 +
                                                    X + 0);

                }
            }
        }

        /* Pass 1: Set position numbers and sum up the maximum number of bytes an
         * instruction may be shifted.
         */
        for(X X=X; X != 0; X = X.X)
        {
            X X = X.X;

            X.X(X);
            X[X++] = X;

            /* Get an estimate about how many additional bytes may be added, because
             * BranchInstructions may have variable length depending on the target
             * offset (short vs. int) or alignment issues (TABLESWITCH and
             * LOOKUPSWITCH).
             */
            switch(X.X())
            {
            case X.X:
            case X.X:
                X += 0;
                break;

            case X.X:
            case X.X:
                X += 0;
                break;
            }

            X += X.X();
        }

        /* Pass 2: Expand the variable-length (Branch)Instructions depending on
         * the target offset (short or int) and ensure that branch targets are
         * within this list.
         */
        for(X X=X; X != 0; X = X.X)
            X += X.X(X, X);

        /* Pass 3: Update position numbers (which may have changed due to the
         * preceding expansions), like pass 1.
         */
        X=X=0;
        for(X X=X; X != 0; X = X.X)
        {
            X X = X.X;

            X.X(X);
            X[X++] = X;
            X += X.X();
        }

        X = new X[X]; // Trim to proper size
        X.X(X, 0, X, 0, X);
    }

    /**
     * When everything is finished, use this method to convert the instruction
     * list into an array of bytes.
     *
     * @return the byte code ready to be dumped
     */
    public X[] X()
    {
        // Update position indices of instructions
        X();

        X X   = new X();
        X      X = new X(X);

        try
        {
            for(X X=X; X != 0; X = X.X)
            {
                X X = X.X;
                X.X(X); // Traverse list
            }
        }
        catch(X X)
        {
            X.X.X(X);
            return 0;
        }

        return X.X();
    }

    /**
     * @return an array of instructions without target information for branch instructions.
     */
    public X[] X()
    {
        X  X        = new X(X());
        X     X = new X();

        try
        {
            while(X.X() > 0)
            {
                X.X(X.X(X));
            }
        }
        catch(X X)
        {
            throw new X(X.X());
        }

        X[] X = new X[X.X()];
        X.X(X);
        return X;
    }

    public X X()
    {
        return X(0);
    }

    /**
     * @param verbose toggle output format
     * @return String containing all instructions in this list.
     */
    public X X(X X)
    {
        X X = new X();

        for(X X=X; X != 0; X = X.X)
        {
            X.X(X.X(X) + 0);
        }

        return X.X();
    }

    /**
     * @return Enumeration that lists all instructions (handles)
     */
    public X X()
    {
        return new X()
        {
            private X X = X;

            public X X()
            {
                X X = X;
                X = X.X;
                return X;
            }

            public X X()
            {
                throw new X();
            }

            public X X()
            {
                return X != 0;
            }
        };
    }

    /**
     * @return array containing all instructions (handles)
     */
    public X[] X()
    {
        X[] X = new X[X];
        X   X  = X;

        for(X X=0; X < X; X++)
        {
            X[X] = X;
            X = X.X;
        }

        return X;
    }

    /**
     * Get positions (offsets) of all instructions in the list. This relies on that
     * the list has been freshly created from an byte code array, or that setPositions()
     * has been called. Otherwise this may be inaccurate.
     *
     * @return array containing all instruction's offset in byte code
     */
    public X[] X()
    {
        return X;
    }

    /**
     * @return complete, i.e., deep copy of this list
     */
    public X X()
    {
        X         X = new X();
        X X  = new X();

        /* Pass 1: Make copies of all instructions, append them to the new list
         * and associate old instruction references with the new ones, i.e.,
         * a 1:1 mapping.
         */
        for(X X=X; X != 0; X = X.X)
        {
            X X = X.X;
            X X = X.X(); // Use clone for shallow copy

            if(X instanceof X)
                X.X(X, X.X((X)X));
            else
                X.X(X, X.X(X));
        }

        /* Pass 2: Update branch targets.
         */
        X X=X;
        X X=X.X;

        while(X != 0)
        {
            X X = X.X;
            X X = X.X;

            if(X instanceof X)
            {
                X X      = (X)X;
                X X      = (X)X;
                X X = X.X(); // old target

                // New target is in hash map
                X.X((X)X.X(X));

                if(X instanceof X)   // Either LOOKUPSWITCH or TABLESWITCH
                {
                    X[] X = ((X)X).X();
                    X[] X = ((X)X).X();

                    for(X X=0; X < X.X; X++)   // Update all targets
                    {
                        X[X] = (X)X.X(X[X]);
                    }
                }
            }

            X = X.X;
            X = X.X;
        }

        return X;
    }

    /** Replace all references to the old constant pool with references to the new
     *  constant pool
     */
    public X X(X X, X X)
    {
        for(X X=X; X != 0; X = X.X)
        {
            X X = X.X;

            if(X instanceof X)
            {
                X X = (X)X;
                X      X  = X.X(X.X());
                X.X(X.X(X, X));
            }
        }
    }

    private X X()
    {
        X = X = 0;
        X = 0;
    }

    /**
     * Delete contents of list. Provides besser memory utilization,
     * because the system then may reuse the instruction handles. This
     * method is typically called right after
     * <href="MethodGen.html#getMethod()">MethodGen.getMethod()</a>.
     */
    public X X()
    {
        // Traverse in reverse order, because ih.next is overwritten
        for(X X=X; X != 0; X = X.X)
            /* Causes BranchInstructions to release target and targeters, because it
             * calls dispose() on the contained instruction.
             */
            X.X();

        X();
    }

    /**
     * @return start of list
     */
    public X X()
    {
        return X;
    }

    /**
     * @return end of list
     */
    public X X()
    {
        return X;
    }

    /**
     * @return length of list (Number of instructions, not bytes)
     */
    public X X()
    {
        return X;
    }

    /**
     * @return length of list (Number of instructions, not bytes)
     */
    public X X()
    {
        return X;
    }

    /**
     * Redirect all references from old_target to new_target, i.e., update targets
     * of branch instructions.
     *
     * @param old_target the old target instruction handle
     * @param new_target the new target instruction handle
     */
    public X X(X X,
                                 X X)
    {
        for(X X = X; X != 0; X = X.X)
        {
            X X  = X.X();

            if(X instanceof X)
            {
                X X      = (X)X;
                X X = X.X();

                if(X == X)
                    X.X(X);

                if(X instanceof X)   // Either LOOKUPSWITCH or TABLESWITCH
                {
                    X[] X = ((X)X).X();

                    for(X X=0; X < X.X; X++) // Update targets
                        if(X[X] == X)
                            ((X)X).X(X, X);
                }
            }
        }
    }

    /**
     * Redirect all references of local variables from old_target to new_target.
     *
     * @param lg array of local variables
     * @param old_target the old target instruction handle
     * @param new_target the new target instruction handle
     * @see MethodGen
     */
    public X X(X[] X,
                                       X X,
                                       X X)
    {
        for(X X=0; X < X.X; X++)
        {
            X X = X[X].X();
            X X   = X[X].X();

            if(X == X)
                X[X].X(X);

            if(X == X)
                X[X].X(X);
        }
    }

    /**
     * Redirect all references of exception handlers from old_target to new_target.
     *
     * @param exceptions array of exception handlers
     * @param old_target the old target instruction handle
     * @param new_target the new target instruction handle
     * @see MethodGen
     */
    public X X(X[] X,
                                          X X,
                                          X X)
    {
        for(X X=0; X < X.X; X++)
        {
            if(X[X].X() == X)
                X[X].X(X);

            if(X[X].X() == X)
                X[X].X(X);

            if(X[X].X() == X)
                X[X].X(X);
        }
    }

    private X X;

    /** Add observer for this object.
     */
    public X X(X X)
    {
        if(X == 0)
            X = new X();

        X.X(X);
    }

    /** Remove observer for this object.
     */
    public X X(X X)
    {
        if(X != 0)
            X.X(X);
    }

    /** Call notify() method on all observers. This method is not called
     * automatically whenever the state has changed, but has to be
     * called by the user after he has finished editing the object.
     */
    public X X()
    {
        if(X != 0)
            for(X X = X.X(); X.X(); )
                ((X)X.X()).X(X);
    }
}

