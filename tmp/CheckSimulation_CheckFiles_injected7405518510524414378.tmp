/*
 * Copyright 1999-2002,2004,2005 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



// Sep 14, 2000:
//  Fixed problem with namespace handling. Contributed by
//  David Blondeau <blondeau@intalio.com>
// Sep 14, 2000:
//  Fixed serializer to report IO exception directly, instead at
//  the end of document processing.
//  Reported by Patrick Higgins <phiggins@transzap.com>
// Aug 21, 2000:
//  Fixed bug in startDocument not calling prepare.
//  Reported by Mikael Staldal <d96-mst-ingen-reklam@d.kth.se>
// Aug 21, 2000:
//  Added ability to omit DOCTYPE declaration.


package X.X.X.X.X.X.X;


import X.X.X;
import X.X.X;
import X.X.X;

import X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X;
import X.X.X.X;
import X.X.X.X;

/**
 * Implements an XML serializer supporting both DOM and SAX pretty
 * serializing. For usage instructions see {@link Serializer}.
 * <p>
 * If an output stream is used, the encoding is taken from the
 * output format (defaults to <tt>UTF-8</tt>). If a writer is
 * used, make sure the writer uses the same encoding (if applies)
 * as specified in the output format.
 * <p>
 * The serializer supports both DOM and SAX. SAX serializing is done by firing
 * SAX events and using the serializer as a document handler. DOM serializing is done
 * by calling {@link #serialize(Document)} or by using DOM Level 3
 * {@link org.w3c.dom.ls.DOMSerializer} and
 * serializing with {@link org.w3c.dom.ls.DOMSerializer#write},
 * {@link org.w3c.dom.ls.DOMSerializer#writeToString}.
 * <p>
 * If an I/O exception occurs while serializing, the serializer
 * will not throw an exception directly, but only throw it
 * at the end of serializing (either DOM or SAX's {@link
 * org.xml.sax.DocumentHandler#endDocument}.
 * <p>
 * For elements that are not specified as whitespace preserving,
 * the serializer will potentially break long text lines at space
 * boundaries, indent lines, and serialize elements on separate
 * lines. Line terminators will be regarded as spaces, and
 * spaces at beginning of line will be stripped.
 * @author <a href="mailto:arkin@intalio.com">Assaf Arkin</a>
 * @author <a href="mailto:rahul.srivastava@sun.com">Rahul Srivastava</a>
 * @author Elena Litani IBM
 * @version $Revision: 1.4 $ $Date: 2007/07/19 04:39:19 $
 * @see Serializer
 */
public class X
    extends X
{

    //
    // constants
    //

    protected static final X X = 0;

    //
    // data
    //

    //
    // DOM Level 3 implementation: variables intialized in DOMSerializerImpl
    //

    /** stores namespaces in scope */
    protected X X;

    /** stores all namespace bindings on the current element */
    protected X X;

    /** symbol table for serialization */
    protected X X;

    // is node dom level 1 node?
    protected X X = 0;
    // counter for new prefix names
    protected X X = 0;
    protected final static X X = 0;

    /**
     * Controls whether namespace fixup should be performed during
     * the serialization.
     * NOTE: if this field is set to true the following
     * fields need to be initialized: fNSBinder, fLocalNSBinder, fSymbolTable,
     * XMLSymbols.EMPTY_STRING, fXmlSymbol, fXmlnsSymbol, fNamespaceCounter.
     */
    protected X X = 0;


    private X X;


    /**
     * Constructs a new serializer. The serializer cannot be used without
     * calling {@link #setOutputCharStream} or {@link #setOutputByteStream}
     * first.
     */
    public X()
    {
        X( );
        X.X(0);
    }


    /**
     * Constructs a new serializer. The serializer cannot be used without
     * calling {@link #setOutputCharStream} or {@link #setOutputByteStream}
     * first.
     */
    public X( X X )
    {
        X( X );
        X.X(0);
    }


    /**
     * Constructs a new serializer that writes to the specified writer
     * using the specified output format. If <tt>format</tt> is null,
     * will use a default output format.
     *
     * @param writer The writer to use
     * @param format The output format to use, null for the default
     */
    public X( X X, X X )
    {
        X( X, X );
        X.X(0);
    }


    /**
     * Constructs a new serializer that writes to the specified output
     * stream using the specified output format. If <tt>format</tt>
     * is null, will use a default output format.
     *
     * @param output The output stream to use
     * @param format The output format to use, null for the default
     */
    public X( X X, X X )
    {
        X( X, X != 0 ? X : new X( X.X, 0, 0 ) );
        X.X(0);
    }

    //-----------------------------------------//
    // SAX content handler serializing methods //
    //-----------------------------------------//


    public X X( X[] X, X X, X X )
    throws X
    {
        X X;

        try
        {
            X = X();

            // Check if text should be print as CDATA section or unescaped
            // based on elements listed in the output format (the element
            // state) or whether we are inside a CDATA section or entity.

            if ( X.X || X.X )
            {
                X          X;

                // Print a CDATA section. The text is not escaped, but ']]>'
                // appearing in the code must be identified and dealt with.
                // The contents of a text node is considered space preserving.
                if ( ! X.X )
                {
                    X.X( 0 );
                    X.X = 0;
                }
                X = X.X();
                X.X( 0 );
                X X;
                final X X = X + X;
                for ( X X = X; X < X; ++X )
                {
                    X = X[X];
                    if ( X == 0 && X + 0 < X &&
                            X[ X + 0 ] == 0 && X[ X + 0 ] == 0 )
                    {
                        X.X(0);
                        X +=0;
                        continue;
                    }
                    if (!X.X(X))
                    {
                        // check if it is surrogate
                        if (++X < X)
                        {
                            X(X, X[X]);
                        }
                        else
                        {
                            X(0+(X)X+0);
                        }
                        continue;
                    }
                    else
                    {
                        if ( X.X((X)X) && X.X(X))
                        {
                            X.X((X)X);
                        }
                        else
                        {
                            // The character is not printable -- split CDATA section
                            X.X(0);
                            X.X(X.X(X));
                            X.X(0);
                        }
                    }
                }
                X.X( X );

            }
            else
            {

                X X;

                if ( X.X )
                {
                    // If preserving space then hold of indentation so no
                    // excessive spaces are printed at line breaks, escape
                    // the text content without replacing spaces and print
                    // the text breaking only at line breaks.
                    X = X.X();
                    X.X( 0 );
                    X( X, X, X, 0, X.X );
                    X.X( X );
                }
                else
                {
                    X( X, X, X, 0, X.X );
                }
            }
        }
        catch ( X X )
        {
            throw new X( X );
        }
    }


    //
    // overwrite printing functions to make sure serializer prints out valid XML
    //
    protected X X( X X ) throws X
    {
        X X = X.X();
        for ( X X = 0 ; X < X ; ++X )
        {
            X X = X.X(X);
            if (!X.X(X))
            {
                if (++X <X)
                {
                    X(X, X.X(X));
                }
                else
                {
                    X(0+(X)X+0);
                }
                continue;
            }
            if (X == 0 || X == 0 || X == 0 || X == 0 || X == 0)
            {
                X(X);
            }
            else if (X == 0)
            {
                X.X(0);
            }
            else if (X == 0)
            {
                X.X(0);
            }
            else if (X == 0)
            {
                X.X(0);
            }
            else if ((X >= 0 && X.X((X) X)))
            {
                X.X((X) X);
            }
            else
            {
                X(X);
            }
        }
    }

    protected final X X(X X) throws X
    {
        X X = X.X();
        X X;

        for (X X = 0; X < X; ++X)
        {
            X = X.X(X);

            if (X == 0
                    && X + 0 < X
                    && X.X(X + 0) == 0
                    && X.X(X + 0) == 0)   // check for ']]>'
            {
                if (X != 0)
                {
                    // REVISIT: this means that if DOM Error handler is not registered we don't report any
                    // fatal errors and might serialize not wellformed document
                    if ((X & X.X) == 0
                            && (X & X.X) == 0)
                    {
                        // issue fatal error
                        X X =
                            X.X(
                                X.X,
                                0,
                                0);
                        X(
                            X,
                            X.X,
                            0, X);
                        X X =
                            X.X(X);
                        if (!X)
                        {
                            throw new X();
                        }
                    }
                    else
                    {
                        // issue warning
                        X X =
                            X.X(
                                X.X,
                                0,
                                0);
                        X(
                            X,
                            X.X,
                            0, X);
                        X.X(X);
                    }
                }
                // split CDATA section
                X.X(0);
                X += 0;
                continue;
            }

            if (!X.X(X))
            {
                // check if it is surrogate
                if (++X < X)
                {
                    X(X, X.X(X));
                }
                else
                {
                    X(
                        0
                        + (X) X
                        + 0);
                }
                continue;
            }
            else
            {
                if (X.X((X) X)
                        && X.X(X))
                {
                    X.X((X) X);
                }
                else
                {

                    // The character is not printable -- split CDATA section
                    X.X(0);
                    X.X(X.X(X));
                    X.X(0);
                }
            }
        }
    }


    // note that this "int" should, in all cases, be a char.
    // REVISIT:  make it a char...
    protected final X X( X X ) throws X
    {

        if (X == 0 || X == 0 || X == 0)
        {
            X(X);
        }
        else if ( X == 0)
        {
            X.X(0);
        }
        else if (X == 0)
        {
            X.X(0);
        }
        else if (X == 0)
        {
            // character sequence "]]>" can't appear in content, therefore
            // we should escape '>'
            X.X(0);
        }
        else if ( X.X((X)X) && X.X(X))
        {
            X.X((X)X);
        }
        else
        {
            X(X);
        }
    }



    protected final X X(X X, X X) throws X
    {
        if (X.X(X))
        {
            if (!X.X(X))
            {
                //Invalid XML
                X(0+(X)X+0);
            }
            else
            {
                X X = X.X((X)X, (X)X);
                if (!X.X(X))
                {
                    //Invalid XML
                    X(0+(X)X+0);
                }
                else
                {
                    if (X().X )
                    {
                        X.X(0);
                        X.X(X.X(X));
                        X.X(0);
                    }
                    else
                    {
                        X(X);
                    }
                }
            }
        }
        else
        {
            X(0+(X)X+0);
        }

    }


    protected X X( X X, X X, X X )
    throws X
    {
        X X;
        X X;
        X X = X.X();
        if ( X )
        {
            // Preserving spaces: the text must print exactly as it is,
            // without breaking when spaces appear in the text and without
            // consolidating spaces. If a line terminator is used, a line
            // break will occur.
            for ( X = 0 ; X < X ; ++X )
            {
                X = X.X( X );
                if (!X.X(X))
                {
                    // check if it is surrogate
                    if (++X <X)
                    {
                        X(X, X.X(X));
                    }
                    else
                    {
                        X(0+(X)X+0);
                    }
                    continue;
                }
                if ( X  && X.X(X))
                {
                    X.X( X );
                }
                else
                    X( X );
            }
        }
        else
        {
            // Not preserving spaces: print one part at a time, and
            // use spaces between parts to break them into different
            // lines. Spaces at beginning of line will be stripped
            // by printing mechanism. Line terminator is treated
            // no different than other text part.
            for ( X = 0 ; X < X ; ++X )
            {
                X = X.X( X );
                if (!X.X(X))
                {
                    // check if it is surrogate
                    if (++X <X)
                    {
                        X(X, X.X(X));
                    }
                    else
                    {
                        X(0+(X)X+0);
                    }
                    continue;
                }

                if ( X && X.X(X) )
                    X.X( X );
                else
                    X( X);
            }
        }
    }



    protected X X( X[] X, X X, X X,
                              X X, X X ) throws X
    {
        X X;
        X X;

        if ( X )
        {
            // Preserving spaces: the text must print exactly as it is,
            // without breaking when spaces appear in the text and without
            // consolidating spaces. If a line terminator is used, a line
            // break will occur.
            while ( X-- > 0 )
            {
                X = X[X++];
                if (!X.X(X))
                {
                    // check if it is surrogate
                    if ( X-- > 0)
                    {
                        X(X, X[X++]);
                    }
                    else
                    {
                        X(0+(X)X+0);
                    }
                    continue;
                }
                if ( X && X.X(X))
                    X.X( X );
                else
                    X( X );
            }
        }
        else
        {
            // Not preserving spaces: print one part at a time, and
            // use spaces between parts to break them into different
            // lines. Spaces at beginning of line will be stripped
            // by printing mechanism. Line terminator is treated
            // no different than other text part.
            while ( X-- > 0 )
            {
                X = X[X++];
                if (!X.X(X))
                {
                    // check if it is surrogate
                    if ( X-- > 0)
                    {
                        X(X, X[X++]);
                    }
                    else
                    {
                        X(0+(X)X+0);
                    }
                    continue;
                }

                if ( X && X.X(X))
                    X.X( X );
                else
                    X( X );
            }
        }
    }


    public X X()
    {
        X.X();
        return 0;

    }

}




