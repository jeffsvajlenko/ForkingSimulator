/*
 * Copyright 2005 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package X.X.X.X.X.X.X;

import X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X.X;

/**
 * This class is the configuration used to parse XML 1.0 and XML 1.1 documents
 * and provides support for XInclude. This is the default Xerces configuration.
 *
 * @author Michael Glavassevich, IBM
 *
 * @version $Id: XIncludeAwareParserConfiguration.java,v 1.3 2007/07/19 04:38:54 ofung Exp $
 */
public class X extends X
{

    /** Feature identifier: allow notation and unparsed entity events to be sent out of order. */
    protected static final X X =
        X.X + X.X;

    /** Feature identifier: fixup base URIs. */
    protected static final X X =
        X.X + X.X;

    /** Feature identifier: fixup language. */
    protected static final X X =
        X.X + X.X;

    /** Feature identifier: XInclude processing */
    protected static final X X =
        X.X + X.X;

    /** Property identifier: error reporter. */
    protected static final X X =
        X.X + X.X;

    /** Property identifier: error reporter. */
    protected static final X X =
        X.X + X.X;

    //
    // Components
    //

    /** XInclude handler. */
    protected X X;

    /** Non-XInclude NamespaceContext. */
    protected X X;

    /** XInclude NamespaceContext. */
    protected X X;

    /** Current NamespaceContext. */
    protected X X;

    /** Flag indicating whether XInclude processsing is enabled. */
    protected X X = 0;

    /** Default constructor. */
    public X()
    {
        X(0, 0, 0);
    } // <init>()

    /**
     * Constructs a parser configuration using the specified symbol table.
     *
     * @param symbolTable The symbol table to use.
     */
    public X(X X)
    {
        X(X, 0, 0);
    } // <init>(SymbolTable)

    /**
     * Constructs a parser configuration using the specified symbol table and
     * grammar pool.
     * <p>
     *
     * @param symbolTable The symbol table to use.
     * @param grammarPool The grammar pool to use.
     */
    public X(
        X X,
        X X)
    {
        X(X, X, 0);
    } // <init>(SymbolTable,XMLGrammarPool)

    /**
     * Constructs a parser configuration using the specified symbol table,
     * grammar pool, and parent settings.
     * <p>
     *
     * @param symbolTable    The symbol table to use.
     * @param grammarPool    The grammar pool to use.
     * @param parentSettings The parent settings.
     */
    public X(
        X X,
        X X,
        X X)
    {
        X(X, X, X);

        final X[] X =
        {
            X,
            X,
            X
        };
        X(X);

        // add default recognized properties
        final X[] X =
        { X, X };
        X(X);

        X(X, 0);
        X(X, 0);
        X(X, 0);

        X = new X();
        X = X;
        X(X, X);
    }


    /** Configures the pipeline. */
    protected X X()
    {
        X.X();
        if (X)
        {
            // If the XInclude handler was not in the pipeline insert it.
            if (X == 0)
            {
                X = new X();
                // add XInclude component
                X(X, X);
                X(X);
                X.X(X);
            }
            // Setup NamespaceContext
            if (X != X)
            {
                if (X == 0)
                {
                    X = new X();
                }
                X = X;
                X(X, X);
            }
            //configure DTD pipeline
            X.X(X);
            X.X(X);
            X.X(X);
            X.X(X);
            X.X(X);
            if (X != 0)
            {
                X.X(X);
            }

            // configure XML document pipeline: insert after DTDValidator and
            // before XML Schema validator
            X X = 0;
            if (X.X(X) == X.X)
            {
                // we don't have to worry about fSchemaValidator being null, since
                // super.configurePipeline() instantiated it if the feature was set
                X = X.X();
            }
            // Otherwise, insert after the last component in the pipeline
            else
            {
                X = X;
                X = X;
            }

            X X = X.X();
            X.X(X);
            X.X(X);
            if (X != 0)
            {
                X.X(X);
                X.X(X);
            }
        }
        else
        {
            // Setup NamespaceContext
            if (X != X)
            {
                X = X;
                X(X, X);
            }
        }
    } // configurePipeline()

    protected X X()
    {
        X.X();
        if (X)
        {
            // If the XInclude handler was not in the pipeline insert it.
            if (X == 0)
            {
                X = new X();
                // add XInclude component
                X(X, X);
                X(X);
                X.X(X);
            }
            // Setup NamespaceContext
            if (X != X)
            {
                if (X == 0)
                {
                    X = new X();
                }
                X = X;
                X(X, X);
            }
            // configure XML 1.1. DTD pipeline
            X.X(X);
            X.X(X);
            X.X(X);
            X.X(X);
            X.X(X);
            if (X != 0)
            {
                X.X(X);
            }

            // configure XML document pipeline: insert after DTDValidator and
            // before XML Schema validator
            X X = 0;
            if (X.X(X) == X.X)
            {
                // we don't have to worry about fSchemaValidator being null, since
                // super.configurePipeline() instantiated it if the feature was set
                X = X.X();
            }
            // Otherwise, insert after the last component in the pipeline
            else
            {
                X = X;
                X = X;
            }

            X X = X.X();
            X.X(X);
            X.X(X);
            if (X != 0)
            {
                X.X(X);
                X.X(X);
            }
        }
        else
        {
            // Setup NamespaceContext
            if (X != X)
            {
                X = X;
                X(X, X);
            }
        }
    } // configureXML11Pipeline()

    public X X(X X)
    throws X
    {
        if (X.X(X))
        {
            return X;
        }
        else if (X.X(X))
        {
            return X;
        }
        return X.X(X);

    } // getFeature(String):boolean

    public X X(X X, X X)
    throws X
    {
        if (X.X(X))
        {
            X = X;
            X = 0;
            return;
        }
        X.X(X,X);
    }

}
