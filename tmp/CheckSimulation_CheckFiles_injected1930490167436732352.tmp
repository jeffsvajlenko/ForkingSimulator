/*
 * Copyright 2004 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package X.X.X.X.X.X.X;

import X.X.X;
import X.X.X;
import X.X.X;
import X.X.X;

import X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X.X;
import X.X.X.X.X.X.X.X.X;

/**
 * This class is the DTD-only parser configuration
 * used to parse XML 1.0 and XML 1.1 documents.
 *
 * <p>
 * This class recognizes the following features and properties:
 * <ul>
 * <li>Features
 *  <ul>
 *   <li>http://xml.org/sax/features/validation</li>
 *   <li>http://xml.org/sax/features/namespaces</li>
 *   <li>http://xml.org/sax/features/external-general-entities</li>
 *   <li>http://xml.org/sax/features/external-parameter-entities</li>
 *   <li>http://apache.org/xml/features/continue-after-fatal-error</li>
 *   <li>http://apache.org/xml/features/load-external-dtd</li>
 *  </ul>
 * <li>Properties
 *  <ul>
 *   <li>http://xml.org/sax/properties/xml-string</li>
 *   <li>http://apache.org/xml/properties/internal/symbol-table</li>
 *   <li>http://apache.org/xml/properties/internal/error-handler</li>
 *   <li>http://apache.org/xml/properties/internal/entity-resolver</li>
 *   <li>http://apache.org/xml/properties/internal/error-reporter</li>
 *   <li>http://apache.org/xml/properties/internal/entity-manager</li>
 *   <li>http://apache.org/xml/properties/internal/document-scanner</li>
 *   <li>http://apache.org/xml/properties/internal/dtd-scanner</li>
 *   <li>http://apache.org/xml/properties/internal/grammar-pool</li>
 *   <li>http://apache.org/xml/properties/internal/validator/dtd</li>
 *   <li>http://apache.org/xml/properties/internal/datatype-validator-factory</li>
 *  </ul>
 * </ul>
 * @author Elena Litani, IBM
 * @author Neil Graham, IBM
 * @author Michael Glavassevich, IBM
 * @author John Kim, IBM
 *
 * @version $Id: XML11DTDConfiguration.java,v 1.3 2007/07/19 04:38:55 ofung Exp $
 */
public class X extends X
    implements X, X
{

    //
    // Constants
    //
    protected final static X X =
        0;

    // feature identifiers

    /** Feature identifier: validation. */
    protected static final X X =
        X.X + X.X;

    /** Feature identifier: namespaces. */
    protected static final X X =
        X.X + X.X;

    /** Feature identifier: external general entities. */
    protected static final X X =
        X.X + X.X;

    /** Feature identifier: external parameter entities. */
    protected static final X X =
        X.X + X.X;

    /** Feature identifier: continue after fatal error. */
    protected static final X X =
        X.X + X.X;

    /** Feature identifier: load external DTD. */
    protected static final X X =
        X.X + X.X;

    // property identifiers

    /** Property identifier: xml string. */
    protected static final X X =
        X.X + X.X;

    /** Property identifier: symbol table. */
    protected static final X X =
        X.X + X.X;

    /** Property identifier: error handler. */
    protected static final X X =
        X.X + X.X;

    /** Property identifier: entity resolver. */
    protected static final X X =
        X.X + X.X;

    /** Property identifier: error reporter. */
    protected static final X X =
        X.X + X.X;

    /** Property identifier: entity manager. */
    protected static final X X =
        X.X + X.X;

    /** Property identifier document scanner: */
    protected static final X X =
        X.X + X.X;

    /** Property identifier: DTD scanner. */
    protected static final X X =
        X.X + X.X;

    /** Property identifier: grammar pool. */
    protected static final X X =
        X.X + X.X;

    /** Property identifier: DTD loader. */
    protected static final X X =
        X.X + X.X;

    /** Property identifier: DTD validator. */
    protected static final X X =
        X.X + X.X;

    /** Property identifier: namespace binder. */
    protected static final X X =
        X.X + X.X;

    /** Property identifier: datatype validator factory. */
    protected static final X X =
        X.X + X.X;

    protected static final X X =
        X.X + X.X;

    /** Property identifier: JAXP schema language / DOM schema-type. */
    protected static final X X =
        X.X + X.X;

    /** Property identifier: JAXP schema source/ DOM schema-location. */
    protected static final X X =
        X.X + X.X;

    // debugging

    /** Set to true and recompile to print exception stack trace. */
    protected static final X X = 0;

    //
    // Data
    //
    protected X X;
    protected X X;
    protected X X;
    protected X X;
    protected X X;
    protected X X;

    /** XML 1.0 Components. */
    protected X X;

    /** XML 1.1. Components. */
    protected X X = 0;

    /** Common components: XMLEntityManager, XMLErrorReporter */
    protected X X = 0;

    /** The document handler. */
    protected X X;

    /** The DTD handler. */
    protected X X;

    /** The DTD content model handler. */
    protected X X;

    /** Last component in the document pipeline */
    protected X X;

    /**
     * True if a parse is in progress. This state is needed because
     * some features/properties cannot be set while parsing (e.g.
     * validation and namespaces).
     */
    protected X X = 0;

    /**
     * fConfigUpdated is set to true if there has been any change to the configuration settings,
     * i.e a feature or a property was changed.
     */
    protected X X = 0;

    //
    // XML 1.0 components
    //

    /** The XML 1.0 Datatype validator factory. */
    protected X X;

    /** The XML 1.0 Document scanner that does namespace binding. */
    protected X X;

    /** The XML 1.0 Non-namespace implementation of scanner */
    protected X X;

    /** The XML 1.0 DTD Validator: binds namespaces */
    protected X X;

    /** The XML 1.0 DTD Validator that does not bind namespaces */
    protected X X;

    /** The XML 1.0 DTD scanner. */
    protected X X;

    /** The XML 1.0 DTD Processor . */
    protected X X;

    //
    // XML 1.1 components
    //

    /** The XML 1.1 datatype factory. **/
    protected X X = 0;

    /** The XML 1.1 document scanner that does namespace binding. **/
    protected X X = 0;

    /** The XML 1.1 document scanner that does not do namespace binding. **/
    protected X X = 0;

    /** The XML 1.1 DTD validator that does namespace binding. **/
    protected X X = 0;

    /** The XML 1.1 DTD validator that does not do namespace binding. **/
    protected X X = 0;

    /** The XML 1.1 DTD scanner. **/
    protected X X = 0;

    /** The XML 1.1 DTD processor. **/
    protected X X = 0;

    //
    // Common components
    //

    /** Grammar pool. */
    protected X X;

    /** Error reporter. */
    protected X X;

    /** Entity manager. */
    protected X X;

    /** Current scanner */
    protected X X;

    /** Current Datatype validator factory. */
    protected X X;

    /** Current DTD scanner. */
    protected X X;

    /** Flag indiciating whether XML11 components have been initialized. */
    private X X = 0;

    //
    // Constructors
    //

    /** Default constructor. */
    public X()
    {
        X(0, 0, 0);
    } // <init>()

    /**
     * Constructs a parser configuration using the specified symbol table.
     *
     * @param symbolTable The symbol table to use.
     */
    public X(X X)
    {
        X(X, 0, 0);
    } // <init>(SymbolTable)

    /**
     * Constructs a parser configuration using the specified symbol table and
     * grammar pool.
     * <p>
     * <strong>REVISIT:</strong>
     * Grammar pool will be updated when the new validation engine is
     * implemented.
     *
     * @param symbolTable The symbol table to use.
     * @param grammarPool The grammar pool to use.
     */
    public X(X X, X X)
    {
        X(X, X, 0);
    } // <init>(SymbolTable,XMLGrammarPool)

    /**
     * Constructs a parser configuration using the specified symbol table,
     * grammar pool, and parent settings.
     * <p>
     * <strong>REVISIT:</strong>
     * Grammar pool will be updated when the new validation engine is
     * implemented.
     *
     * @param symbolTable    The symbol table to use.
     * @param grammarPool    The grammar pool to use.
     * @param parentSettings The parent settings.
     */
    public X(
        X X,
        X X,
        X X)
    {

        X(X);

        // create a vector to hold all the components in use
        // XML 1.0 specialized components
        X = new X();
        // XML 1.1 specialized components
        X = new X();
        // Common components for XML 1.1. and XML 1.0
        X = new X();

        // create storage for recognized features and properties
        X = new X();
        X = new X();

        // create table for features and properties
        X = new X();
        X = new X();

        // add default recognized features
        final X[] X =
        {
            X, X, // from XMLDTDScannerImpl
            X,
            X,
            X,
            X,
            X
        };
        X(X);
        // set state for default features
        X.X(X, X.X);
        X.X(X, X.X);
        X.X(X, X.X);
        X.X(X, X.X);
        X.X(X, X.X);
        X.X(X, X.X);
        X.X(X, X.X);

        // add default recognized properties
        final X[] X =
        {
            X,
            X,
            X,
            X,
            X,
            X,
            X,
            X,
            X,
            X,
            X,
            X,
            X,
            X,
            X
        };
        X(X);

        if (X == 0)
        {
            X = new X();
        }
        X = X;
        X.X(X, X);

        X = X;
        if (X != 0)
        {
            X.X(X, X);
        }

        X = new X();
        X.X(X, X);
        X(X);

        X = new X();
        X.X(X.X());
        X.X(X, X);
        X(X);

        X = new X();
        X.X(X, X);
        X((X) X);

        X = new X();
        X.X(X, X);
        X((X) X);

        X = new X();
        X.X(X, X);
        X((X) X);

        X = new X();
        X.X(X, X);
        X(X);

        X = X.X();
        X.X(X, X);

        X = new X();
        X.X(X, X);

        X = new X();

        // add message formatters
        if (X.X(X.X) == 0)
        {
            X X = new X();
            X.X(X.X, X);
            X.X(X.X, X);
        }

        // set locale
        try
        {
            X(X.X());
        }
        catch (X X)
        {
            // do nothing
            // REVISIT: What is the right thing to do? -Ac
        }

        X = 0;

    } // <init>(SymbolTable,XMLGrammarPool)

    //
    // Public methods
    //
    /**
     * Sets the input source for the document to parse.
     *
     * @param inputSource The document's input source.
     *
     * @exception XMLConfigurationException Thrown if there is a
     *                        configuration error when initializing the
     *                        parser.
     * @exception IOException Thrown on I/O error.
     *
     * @see #parse(boolean)
     */
    public X X(X X)
    throws X, X
    {

        // REVISIT: this method used to reset all the components and
        //          construct the pipeline. Now reset() is called
        //          in parse (boolean) just before we parse the document
        //          Should this method still throw exceptions..?

        X = X;

    } // setInputSource(XMLInputSource)

    /**
     * Set the locale to use for messages.
     *
     * @param locale The locale object to use for localization of messages.
     *
     * @exception XNIException Thrown if the parser does not support the
     *                         specified locale.
     */
    public X X(X X) throws X
    {
        X = X;
        X.X(X);
    } // setLocale(Locale)

    /**
     * Sets the document handler on the last component in the pipeline
     * to receive information about the document.
     *
     * @param documentHandler   The document handler.
     */
    public X X(X X)
    {
        X = X;
        if (X != 0)
        {
            X.X(X);
            if (X !=0)
            {
                X.X(X);
            }
        }
    } // setDocumentHandler(XMLDocumentHandler)

    /** Returns the registered document handler. */
    public X X()
    {
        return X;
    } // getDocumentHandler():XMLDocumentHandler

    /**
     * Sets the DTD handler.
     *
     * @param dtdHandler The DTD handler.
     */
    public X X(X X)
    {
        X = X;
    } // setDTDHandler(XMLDTDHandler)

    /** Returns the registered DTD handler. */
    public X X()
    {
        return X;
    } // getDTDHandler():XMLDTDHandler

    /**
     * Sets the DTD content model handler.
     *
     * @param handler The DTD content model handler.
     */
    public X X(X X)
    {
        X = X;
    } // setDTDContentModelHandler(XMLDTDContentModelHandler)

    /** Returns the registered DTD content model handler. */
    public X X()
    {
        return X;
    } // getDTDContentModelHandler():XMLDTDContentModelHandler

    /**
     * Sets the resolver used to resolve external entities. The EntityResolver
     * interface supports resolution of public and system identifiers.
     *
     * @param resolver The new entity resolver. Passing a null value will
     *                 uninstall the currently installed resolver.
     */
    public X X(X X)
    {
        X.X(X, X);
    } // setEntityResolver(XMLEntityResolver)

    /**
     * Return the current entity resolver.
     *
     * @return The current entity resolver, or null if none
     *         has been registered.
     * @see #setEntityResolver
     */
    public X X()
    {
        return (X)X.X(X);
    } // getEntityResolver():XMLEntityResolver

    /**
     * Allow an application to register an error event handler.
     *
     * <p>If the application does not register an error handler, all
     * error events reported by the SAX parser will be silently
     * ignored; however, normal processing may not continue.  It is
     * highly recommended that all SAX applications implement an
     * error handler to avoid unexpected bugs.</p>
     *
     * <p>Applications may register a new or different handler in the
     * middle of a parse, and the SAX parser must begin using the new
     * handler immediately.</p>
     *
     * @param errorHandler The error handler.
     * @exception java.lang.NullPointerException If the handler
     *            argument is null.
     * @see #getErrorHandler
     */
    public X X(X X)
    {
        X.X(X, X);
    } // setErrorHandler(XMLErrorHandler)

    /**
     * Return the current error handler.
     *
     * @return The current error handler, or null if none
     *         has been registered.
     * @see #setErrorHandler
     */
    public X X()
    {
        // REVISIT: Should this be a property?
        return (X)X.X(X);
    } // getErrorHandler():XMLErrorHandler


    /**
     * If the application decides to terminate parsing before the xml document
     * is fully parsed, the application should call this method to free any
     * resource allocated during parsing. For example, close all opened streams.
     */
    public X X()
    {
        X.X();
    }

    /**
     * Parses the specified input source.
     *
     * @param source The input source.
     *
     * @exception XNIException Throws exception on XNI error.
     * @exception java.io.IOException Throws exception on i/o error.
     */
    public X X(X X) throws X, X
    {

        if (X)
        {
            // REVISIT - need to add new error message
            throw new X(0);
        }
        X = 0;

        try
        {
            X(X);
            X(0);
        }
        catch (X X)
        {
            if (X)
                X.X();
            throw X;
        }
        catch (X X)
        {
            if (X)
                X.X();
            throw X;
        }
        catch (X X)
        {
            if (X)
                X.X();
            throw X;
        }
        catch (X X)
        {
            if (X)
                X.X();
            throw new X(X);
        }
        finally
        {
            X = 0;
            // close all streams opened by xerces
            X.X();
        }

    } // parse(InputSource)

    public X X(X X) throws X, X
    {
        //
        // reset and configure pipeline and set InputSource.
        if (X != 0)
        {
            try
            {
                X.X();
                X.X(X);
                X();

                X X = X.X(X);
                if (X == X.X)
                {
                    X();
                    X();
                    X();
                }
                else
                {
                    X();
                    X();
                }

                // mark configuration as fixed
                X = 0;

                // resets and sets the pipeline.
                X.X((X) X, X);
                X = 0;
            }
            catch (X X)
            {
                if (X)
                    X.X();
                throw X;
            }
            catch (X X)
            {
                if (X)
                    X.X();
                throw X;
            }
            catch (X X)
            {
                if (X)
                    X.X();
                throw X;
            }
            catch (X X)
            {
                if (X)
                    X.X();
                throw new X(X);
            }
        }

        try
        {
            return X.X(X);
        }
        catch (X X)
        {
            if (X)
                X.X();
            throw X;
        }
        catch (X X)
        {
            if (X)
                X.X();
            throw X;
        }
        catch (X X)
        {
            if (X)
                X.X();
            throw X;
        }
        catch (X X)
        {
            if (X)
                X.X();
            throw new X(X);
        }

    } // parse(boolean):boolean

    /**
     * Returns the state of a feature.
     *
     * @param featureId The feature identifier.
    	 * @return true if the feature is supported
     *
     * @throws XMLConfigurationException Thrown for configuration error.
     *                                   In general, components should
     *                                   only throw this exception if
     *                                   it is <strong>really</strong>
     *                                   a critical error.
     */
    public X X(X X)
    throws X
    {
        // make this feature special
        if (X.X(X))
        {
            return X;
        }
        return X.X(X);

    } // getFeature(String):boolean

    /**
     * Set the state of a feature.
     *
     * Set the state of any feature in a SAX2 parser.  The parser
     * might not recognize the feature, and if it does recognize
     * it, it might not be able to fulfill the request.
     *
     * @param featureId The unique identifier (URI) of the feature.
     * @param state The requested state of the feature (true or false).
     *
     * @exception com.sun.org.apache.xerces.internal.xni.parser.XMLConfigurationException If the
     *            requested feature is not known.
     */
    public X X(X X, X X)
    throws X
    {
        X = 0;
        // forward to every XML 1.0 component
        X X = X.X();
        for (X X = 0; X < X; X++)
        {
            X X = (X) X.X(X);
            X.X(X, X);
        }
        // forward it to common components
        X = X.X();
        for (X X = 0; X < X; X++)
        {
            X X = (X) X.X(X);
            X.X(X, X);
        }

        // forward to every XML 1.1 component
        X = X.X();
        for (X X = 0; X < X; X++)
        {
            X X = (X) X.X(X);
            try
            {
                X.X(X, X);
            }
            catch (X X)
            {
                // no op
            }
        }
        // save state if noone "objects"
        X.X(X, X);

    } // setFeature(String,boolean)

    /**
     * setProperty
     *
     * @param propertyId
     * @param value
     */
    public X X(X X, X X)
    throws X
    {
        X = 0;
        // forward to every XML 1.0 component
        X X = X.X();
        for (X X = 0; X < X; X++)
        {
            X X = (X) X.X(X);
            X.X(X, X);
        }
        // forward it to every common Component
        X = X.X();
        for (X X = 0; X < X; X++)
        {
            X X = (X) X.X(X);
            X.X(X, X);
        }
        // forward it to every XML 1.1 component
        X = X.X();
        for (X X = 0; X < X; X++)
        {
            X X = (X) X.X(X);
            try
            {
                X.X(X, X);
            }
            catch (X X)
            {
                // ignore it
            }
        }

        // store value if noone "objects"
        X.X(X, X);

    } // setProperty(String,Object)


    /** Returns the locale. */
    public X X()
    {
        return X;
    } // getLocale():Locale

    /**
     * reset all XML 1.0 components before parsing and namespace context
     */
    protected X X() throws X
    {
        X X = X.X();
        for (X X = 0; X < X; X++)
        {
            X X = (X) X.X(X);
            X.X(X);
        }

    } // reset()

    /**
     * reset all common components before parsing
     */
    protected X X() throws X
    {
        // reset common components
        X X = X.X();
        for (X X = 0; X < X; X++)
        {
            X X = (X) X.X(X);
            X.X(X);
        }

    } // resetCommon()

    /**
     * reset all components before parsing and namespace context
     */
    protected X X() throws X
    {
        // reset every component
        X X = X.X();
        for (X X = 0; X < X; X++)
        {
            X X = (X) X.X(X);
            X.X(X);
        }

    } // resetXML11()

    /**
     *  Configures the XML 1.1 pipeline.
     *  Note: this method also resets the new XML11 components.
     */
    protected X X()
    {
        if (X != X)
        {
            X = X;
            X(X, X);
        }
        if (X != X)
        {
            X = X;
            X(X, X);
            X(X, X);
        }

        X.X(X);
        X.X(X);
        X.X(X);
        if (X != 0)
        {
            X.X(X);
        }

        X.X(X);
        X.X(X);
        X.X(X);
        if (X != 0)
        {
            X.X(X);
        }

        // setup XML 1.1 document pipeline
        if (X.X(X) == X.X)
        {
            if (X != X)
            {
                X = X;
                X(X, X);
                X(X, X);
            }

            X.X(X);
            X.X(X);
            X.X(X);
            X.X(X);

            if (X != 0)
            {
                X.X(X);
            }
            X = X;

        }
        else
        {
            // create components
            if (X == 0)
            {
                // non namespace document pipeline
                X = new X();
                X(X);
                X = new X();
                X(X);
            }
            if (X != X)
            {
                X = X;
                X(X, X);
                X(X, X);
            }
            X.X(X);
            X.X(X);
            X.X(X);

            if (X != 0)
            {
                X.X(X);
            }
            X = X;
        }

    } // configureXML11Pipeline()

    /** Configures the pipeline. */
    protected X X()
    {
        if (X != X)
        {
            X = X;
            // use XML 1.0 datatype library
            X(X, X);
        }

        // setup DTD pipeline
        if (X != X)
        {
            X = X;
            X(X, X);
            X(X, X);
        }
        X.X(X);
        X.X(X);
        X.X(X);
        if (X != 0)
        {
            X.X(X);
        }

        X.X(X);
        X.X(X);
        X.X(X);
        if (X != 0)
        {
            X.X(X);
        }

        // setup document pipeline
        if (X.X(X) == X.X)
        {
            if (X != X)
            {
                X = X;
                X(X, X);
                X(X, X);
            }
            X.X(X);
            X.X(X);
            X.X(X);
            X.X(X);
            if (X != 0)
            {
                X.X(X);
            }
            X = X;
        }
        else
        {
            // create components
            if (X == 0)
            {
                X = new X();
                X = new X();
                // add components
                X((X) X);
                X((X) X);
            }
            if (X != X)
            {
                X = X;
                X(X, X);
                X(X, X);
            }

            X.X(X);
            X.X(X);
            X.X(X);
            if (X != 0)
            {
                X.X(X);
            }
            X = X;
        }

    } // configurePipeline()


    // features and properties

    /**
     * Check a feature. If feature is know and supported, this method simply
     * returns. Otherwise, the appropriate exception is thrown.
     *
     * @param featureId The unique identifier (URI) of the feature.
     *
     * @throws XMLConfigurationException Thrown for configuration error.
     *                                   In general, components should
     *                                   only throw this exception if
     *                                   it is <strong>really</strong>
     *                                   a critical error.
     */
    protected X X(X X) throws X
    {

        //
        // Xerces Features
        //

        if (X.X(X.X))
        {
            final X X = X.X() - X.X.X();

            //
            // http://apache.org/xml/features/validation/dynamic
            //   Allows the parser to validate a document only when it
            //   contains a grammar. Validation is turned on/off based
            //   on each document instance, automatically.
            //
            if (X == X.X.X() &&
                    X.X(X.X))
            {
                return;
            }

            //
            // http://apache.org/xml/features/validation/default-attribute-values
            //
            if (X == X.X.X() &&
                    X.X(X.X))
            {
                // REVISIT
                X X = X.X;
                throw new X(X, X);
            }
            //
            // http://apache.org/xml/features/validation/default-attribute-values
            //
            if (X == X.X.X() &&
                    X.X(X.X))
            {
                // REVISIT
                X X = X.X;
                throw new X(X, X);
            }
            //
            // http://apache.org/xml/features/validation/nonvalidating/load-dtd-grammar
            //
            if (X == X.X.X() &&
                    X.X(X.X))
            {
                return;
            }
            //
            // http://apache.org/xml/features/validation/nonvalidating/load-external-dtd
            //
            if (X == X.X.X() &&
                    X.X(X.X))
            {
                return;
            }

            //
            // http://apache.org/xml/features/validation/default-attribute-values
            //
            if (X == X.X.X() &&
                    X.X(X.X))
            {
                X X = X.X;
                throw new X(X, X);
            }

            // special performance feature: only component manager is allowed to set it.
            if (X == X.X.X() &&
                    X.X(X.X))
            {
                X X = X.X;
                throw new X(X, X);
            }
        }

        //
        // Not recognized
        //

        X.X(X);

    } // checkFeature(String)

    /**
     * Check a property. If the property is know and supported, this method
     * simply returns. Otherwise, the appropriate exception is thrown.
     *
     * @param propertyId The unique identifier (URI) of the property
     *                   being set.
     *
     * @throws XMLConfigurationException Thrown for configuration error.
     *                                   In general, components should
     *                                   only throw this exception if
     *                                   it is <strong>really</strong>
     *                                   a critical error.
     */
    protected X X(X X) throws X
    {

        //
        // Xerces Properties
        //

        if (X.X(X.X))
        {
            final X X = X.X() - X.X.X();

            if (X == X.X.X() &&
                    X.X(X.X))
            {
                return;
            }
        }

        // special cases
        if (X.X(X.X))
        {
            final X X = X.X() - X.X.X();

            //
            // http://xml.org/sax/properties/xml-string
            // Value type: String
            // Access: read-only
            //   Get the literal string of characters associated with the
            //   current event.  If the parser recognises and supports this
            //   property but is not currently parsing text, it should return
            //   null (this is a good way to check for availability before the
            //   parse begins).
            //
            if (X == X.X.X() &&
                    X.X(X.X))
            {
                // REVISIT - we should probably ask xml-dev for a precise
                // definition of what this is actually supposed to return, and
                // in exactly which circumstances.
                X X = X.X;
                throw new X(X, X);
            }
        }

        //
        // Not recognized
        //

        X.X(X);

    } // checkProperty(String)


    /**
     * Adds a component to the parser configuration. This method will
     * also add all of the component's recognized features and properties
     * to the list of default recognized features and properties.
     *
     * @param component The component to add.
     */
    protected X X(X X)
    {

        // don't add a component more than once
        if (X.X(X))
        {
            return;
        }
        X.X(X);
        X(X);

    } // addComponent(XMLComponent)

    /**
     * Adds common component to the parser configuration. This method will
     * also add all of the component's recognized features and properties
     * to the list of default recognized features and properties.
     *
     * @param component The component to add.
     */
    protected X X(X X)
    {

        // don't add a component more than once
        if (X.X(X))
        {
            return;
        }
        X.X(X);
        X(X);

    } // addCommonComponent(XMLComponent)

    /**
     * Adds an XML 1.1 component to the parser configuration. This method will
     * also add all of the component's recognized features and properties
     * to the list of default recognized features and properties.
     *
     * @param component The component to add.
     */
    protected X X(X X)
    {

        // don't add a component more than once
        if (X.X(X))
        {
            return;
        }
        X.X(X);
        X(X);

    } // addXML11Component(XMLComponent)

    /**
     * Adds all of the component's recognized features and properties
     * to the list of default recognized features and properties, and
     * sets default values on the configuration for features and
     * properties which were previously absent from the configuration.
     *
     * @param component The component whose recognized features
     * and properties will be added to the configuration
     */
    protected X X(X X)
    {

        // register component's recognized features
        X[] X = X.X();
        X(X);

        // register component's recognized properties
        X[] X = X.X();
        X(X);

        // set default values
        if (X != 0)
        {
            for (X X = 0; X < X.X; ++X)
            {
                X X = X[X];
                X X = X.X(X);
                if (X != 0)
                {
                    // Do not overwrite values already set on the configuration.
                    if (!X.X(X))
                    {
                        X.X(X, X);
                        // For newly added components who recognize this feature
                        // but did not offer a default value, we need to make
                        // sure these components will get an opportunity to read
                        // the value before parsing begins.
                        X = 0;
                    }
                }
            }
        }
        if (X != 0)
        {
            for (X X = 0; X < X.X; ++X)
            {
                X X = X[X];
                X X = X.X(X);
                if (X != 0)
                {
                    // Do not overwrite values already set on the configuration.
                    if (!X.X(X))
                    {
                        X.X(X, X);
                        // For newly added components who recognize this property
                        // but did not offer a default value, we need to make
                        // sure these components will get an opportunity to read
                        // the value before parsing begins.
                        X = 0;
                    }
                }
            }
        }
    }

    private X X()
    {
        if (!X)
        {

            // create datatype factory
            X = X.X(X);

            // setup XML 1.1 DTD pipeline
            X = new X();
            X(X);
            X = new X();
            X(X);

            // setup XML 1.1. document pipeline - namespace aware
            X = new X();
            X(X);
            X = new X();
            X(X);

            X = 0;
        }
    }

} // class XML11DTDConfiguration
