/*
 * %W% %E%
 *
 * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
 * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 */

package X.X.X.X;

import X.X.*;
import X.X.X.*;
import X.X.X.*;
import X.X.X.X.*;
import X.X.X.X;

import X.X.*;
import X.X.X.*;
import X.X.X;
import X.X.X;
import X.X.X.X.X;
import X.X.X;

/**
 * A Synth L&F implementation of TabbedPaneUI.
 *
 * @version %I%, %G%
 * @author Scott Violet
 */
/**
 * Looks up 'selectedTabPadInsets' from the Style, which will be additional
 * insets for the selected tab.
 */
class X extends X implements X, X
{
    /**
     * <p>If non-zero, tabOverlap indicates the amount that the tab bounds
     * should be altered such that they would overlap with a tab on either the
     * leading or trailing end of a run (ie: in TOP, this would be on the left
     * or right).</p>
     *
     * <p>A positive overlap indicates that tabs should overlap right/down,
     * while a negative overlap indicates tha tabs should overlap left/up.</p>
     *
     * <p>When tabOverlap is specified, it both changes the x position and width
     * of the tab if in TOP or BOTTOM placement, and changes the y position and
     * height if in LEFT or RIGHT placement.</p>
     *
     * <p>This is done for the following reason. Consider a run of 10 tabs.
     * There are 9 gaps between these tabs. If you specified a tabOverlap of
     * "-1", then each of the tabs "x" values will be shifted left. This leaves
     * 9 pixels of space to the right of the right-most tab unpainted. So, each
     * tab's width is also extended by 1 pixel to make up the difference.</p>
     *
     * <p>This property respects the RTL component orientation.</p>
     */
    private X X = 0;

    /**
     * When a tabbed pane has multiple rows of tabs, this indicates whether
     * the tabs in the upper row(s) should extend to the base of the tab area,
     * or whether they should remain at their normal tab height. This does not
     * affect the bounds of the tabs, only the bounds of area painted by the
     * tabs. The text position does not change. The result is that the bottom
     * border of the upper row of tabs becomes fully obscured by the lower tabs,
     * resulting in a cleaner look.
     */
    private X X = 0;

    private X X;
    private X X;
    private X X;

    private X X;
    private X X;
    private X X;
    private X X;

    private X X;
    private X X;

    private X X = new X();

    //added for the Nimbus look and feel, where the tab area is painted differently depending on the
    //state for the selected tab
    private X X = 0;
    //added for the Nimbus LAF to ensure that the labels don't move whether the tab is selected or not
    private X X = 0;

    private X X = 0;

    public static X X(X X)
    {
        return new X();
    }

    X()
    {
        X = new X();
        X = new X();
    }

    private X X()
    {
        return (X.X() == X.X);
    }

    protected X X()
    {
        X(X);
    }

    private X X(X X)
    {
        X X = X(X, X);
        X X = X;
        X = X.X(X, X);
        // Add properties other than JComponent colors, Borders and
        // opacity settings here:
        if (X != X)
        {
            X =
                X.X(X, 0, 0);
            X = X.X(X, 0, 0);
            X = X.X(X,
                                                0, 0);
            X = X.X(X, 0, 0);
            X = (X)X.X(X,
                                   0);
            if (X == 0)
            {
                X = new X(0, 0, 0, 0);
            }
            X = X.X(X,
                                            0, 0);
            X = X.X(X,
                                                  0, 0);
            if (X != 0)
            {
                X();
                X();
            }
        }
        X.X();

        if (X != 0)
        {
            X.X();
        }
        X = X(X, X.X, X);
        X.X = X.X(X, X);
        X = X.X(X, 0);


        if (X != 0)
        {
            X.X();
        }
        X = X(X, X.X, X);
        X.X = X.X(X, X);
        X = X.X(X, 0);


        if (X != 0)
        {
            X.X();
        }
        X = X(X, X.X, X);
        X.X = X.X(X,
                               X);
        X =
            X.X(X, 0);
    }

    protected X X()
    {
        X.X();
        X.X(X);
    }

    protected X X()
    {
        X.X();
        X.X(X);
    }

    protected X X()
    {
        X X = X(X, X);
        X.X(X);
        X.X();
        X = 0;

        X.X(X);
        X.X();
        X = 0;
        X = 0;

        X.X(X);
        X.X();
        X = 0;
        X = 0;

        X.X(X);
        X.X();
        X = 0;
        X = 0;
    }

    public X X(X X)
    {
        return X(X, X(X));
    }

    public X X(X X, X X)
    {
        return X.X(X.class, X,
                                       X.X(X),X, X);
    }

    public X X(X X, X X)
    {
        return X(X, X, X(X));
    }

    private X X(X X, X X, X X)
    {
        X X = 0;
        X X = X.class;

        if (X == X.X)
        {
            X = X;
        }
        else if (X == X.X)
        {
            X = X;
        }
        else if (X == X.X)
        {
            X = X;
        }
        return X.X(X, X, X, X, X);
    }

    private X X(X X)
    {
        return X.X(X);
    }

    private X X(X X)
    {
        return X.X(X);
    }

    protected X X(X X)
    {
        // added for Nimbus LAF so that it can use the basic arrow buttons
        // UIManager is queried directly here because this is called before
        // updateStyle is called so the style can not be queried directly
        if (X.X(0))
        {
            X X = X.X(X);
            X.X(X.X());
            return X;
        }
        return new X(X);
    }

    public X X(X X)
    {
        if (X.X(X))
        {
            X(X);
        }
    }

    /**
     * @inheritDoc
     *
     * Overridden to keep track of whether the selected tab is also pressed.
     */
    @X
    protected X X()
    {
        final X X = X.X();
        final X X = (X)X;
        return new X()
        {
            public X X(X X)
            {
                X.X(X);
            }
            public X X(X X)
            {
                X.X(X);
            }
            public X X(X X)
            {
                X.X(X);
            }

            public X X(X X)
            {
                if (!X.X())
                {
                    return;
                }

                X X = X(X, X.X(), X.X());
                if (X >= 0 && X.X(X))
                {
                    if (X == X.X())
                    {
                        // Clicking on selected tab
                        X = 0;
                        //TODO need to just repaint the tab area!
                        X.X();
                    }
                }

                //forward the event (this will set the selected index, or none at all
                X.X(X);
            }

            public X X(X X)
            {
                if (X)
                {
                    X = 0;
                    //TODO need to just repaint the tab area!
                    X.X();
                }
                //forward the event
                X.X(X);

                //hack: The super method *should* be setting the mouse-over property correctly
                //here, but it doesn't. That is, when the mouse is released, whatever tab is below the
                //released mouse should be in rollover state. But, if you select a tab and don't
                //move the mouse, this doesn't happen. Hence, forwarding the event.
                X.X(X);
            }
        };
    }

    @X
    protected X X(X X, X X, X X)
    {
        if (X)
        {
            return X.X(X, X, X);
        }
        else
        {
            return 0;
        }
    }

    @X
    protected X X(X X, X X, X X)
    {
        if (X)
        {
            return X.X(X, X, X);
        }
        else
        {
            return 0;
        }
    }

    public X X(X X, X X)
    {
        X X = X(X);

        X.X(X, X);
        X.X().X(X,
                X, 0, 0, X.X(), X.X());
        X(X, X);
        X.X();
    }

    protected X X(X X)
    {
        if (X.X(X) != 0 ||
                X(X) != 0)
        {
            return X.X(X);
        }
        X X = X.X(X);
        X X = X.X().X(X);
        X X = X(X);
        X X = X(X);
        X.X(0, 0, 0, 0);
        X.X(0, 0, 0, 0);
        X.X(0, 0, X.X, X);
        X.X().X(X).X(
            X, X, X, X, X.X,
            X.X, X.X,
            X.X, X,
            X, X, X);
        return X.X + X.X() + X();
    }

    public X X(X X, X X, X X,
                            X X, X X, X X)
    {
        X.X().X(X, X, X, X, X, X);
    }

    public X X(X X, X X)
    {
        X X = X(X);

        X(X, X);
        X.X();
    }

    protected X X(X X, X X)
    {
        X X = X.X();
        X X = X.X();

        X();

        // Paint tab area
        // If scrollable tabs are enabled, the tab area will be
        // painted by the scrollable tab panel instead.
        //
        if (!X())   // WRAP_TAB_LAYOUT
        {
            X X = X.X();
            X X = X.X;
            X X = X.X;
            X X = X.X() - X.X - X.X;
            X X = X.X() - X.X - X.X;
            X X;
            switch(X)
            {
            case X:
                X = X(X, X,
                                              X);
                break;
            case X:
                X = X(X, X,
                                             X);
                X = X + X - X;
                X = X;
                break;
            case X:
                X = X(X, X,
                                              X);
                X = X + X - X;
                X = X;
                break;
            case X:
            default:
                X = X(X, X,
                                                X);
            }

            X.X(X, X, X, X);

            if (X.X().X(X))
            {
                X(X, X, X,
                             X, X);
            }
        }

        // Paint content border
        X(X, X, X, X);
    }


    protected X X(X X, X X,
                                X X)
    {
        // This can be invoked from ScrollabeTabPanel
        X X = X.X();
        X X = X.X;
        X X = X.X;
        X X = X.X() - X.X - X.X;
        X X = X.X() - X.X - X.X;

        X(X, X, X, X,
                     new X(X, X, X, X));
    }

    protected X X(X X, X X,
                                X X, X X,
                                X X)
    {
        X X = X.X();

        //if the tab area's states should match that of the selected tab, then
        //first update the selected tab's states, then set the state
        //for the tab area to match
        //otherwise, restore the tab area's state to ENABLED (which is the
        //only supported state otherwise).
        if (X && X >= 0)
        {
            X(X, 0, X,
                             (X() == X),
                             (X() == X));
            X.X(X.X());
        }
        else
        {
            X.X(X.X);
        }

        // Paint the tab area.
        X.X(X, X, X);
        X.X().X(X, X,
                X.X, X.X, X.X,
                X.X, X);
        X.X().X(X, X, X.X,
                X.X, X.X, X.X,
                X);

        X X = X.X();

        X.X(0, 0, 0, 0);
        X.X(0, 0, 0, 0);

        // Paint tabRuns of tabs from back to front
        for (X X = X - 0; X >= 0; X--)
        {
            X X = X[X];
            X X = X[(X == X - 0)? 0 : X + 0];
            X X = (X != 0? X - 0: X - 0);
            for (X X = X; X <= X; X++)
            {
                if (X[X].X(X) && X != X)
                {
                    X(X, X, X, X, X, X,
                             X);
                }
            }
        }

        if (X >= 0)
        {
            if (X[X].X(X))
            {
                X(X, X, X, X, X,
                         X, X);
            }
        }
    }

    protected X X(X X)
    {
        X X = X();
        X.X(X);

        X X = 0;

        if (X != X && X)
        {
            //TODO need to just repaint the tab area!
            X.X();
        }
        else
        {
            if ((X >= 0) && (X < X.X()))
            {
                X = X(X, X);
                if (X != 0)
                {
                    X.X(X);
                }
            }

            if (X >= 0)
            {
                X = X(X, X);
                if (X != 0)
                {
                    X.X(X);
                }
            }
        }
    }

    protected X X(X X, X X,
                            X X, X[] X, X X,
                            X X, X X)
    {
        X X = X[X];
        X X = X.X();
        X X = X == X;
        X(X, X, X && X,
                         (X() == X),
                         (X() == X));

        X.X(X, X, X);
        X X = X.X;
        X X = X.X;
        X X = X.X;
        X X = X.X;
        X X = X.X();
        if (X && X > 0)
        {
            //paint this tab such that its edge closest to the base is equal to
            //edge of the selected tab closest to the base. In terms of the TOP
            //tab placement, this will cause the bottom of each tab to be
            //painted even with the bottom of the selected tab. This is because
            //in each tab placement (TOP, LEFT, BOTTOM, RIGHT) the selected tab
            //is closest to the base.
            if (X >= 0)
            {
                X X = X[X];
                switch (X)
                {
                case X:
                    X X = X.X + X.X;
                    X = X - X.X;
                    break;
                case X:
                    X X = X.X + X.X;
                    X = X - X.X;
                    break;
                case X:
                    X X = X.X;
                    X = (X.X + X.X) - X;
                    X = X;
                    break;
                case X:
                    X X = X.X;
                    X = (X.X + X.X) - X;
                    X = X;
                    break;
                }
            }
        }
        X.X().X(X, X,
                X, X, X, X, X, X);
        X.X().X(X, X,
                X, X, X, X, X, X);

        if (X.X(X) == 0)
        {
            X X = X.X(X);
            X X = X.X().X(X);
            X X = X.X(X, X, X);
            X X = X(X);

            X(X, X, X, X, X, X,
                        X, X, X, X);

            X(X, X, X, X, X,
                      X, X, X, X);

            X(X, X, X, X, X, X);
        }
    }

    protected X X(X X, X X,
                               X X, X X,
                               X X, X X,
                               X X, X X,
                               X X, X X )
    {
        X X = X(X);
        if (X != 0)
        {
            X.X(0, X);
        }

        X.X = X.X = X.X = X.X = 0;

        X.X().X(X).X(X, X, X,
                X, X.X, X.X,
                X.X, X.X,
                X, X, X, X);

        X.X(0, 0);

        X X = X(X, X, X);
        X X = X(X, X, X);
        X.X += X;
        X.X += X;
        X.X += X;
        X.X += X;
    }

    protected X X(X X,
                             X X, X X,
                             X X, X X, X X,
                             X X, X X,
                             X X)
    {
        X.X(X);

        X X = X(X);
        if (X != 0)
        {
            // html
            X.X(X, X);
        }
        else
        {
            // plain text
            X X = X.X(X);

            X.X(X.X().X(X, X.X));
            X.X().X(X).X(X, X, X,
                    X, X);
        }
    }


    protected X X(X X, X X,
                                      X X, X X)
    {
        X X = X.X();
        X X = X.X();
        X X = X.X();

        X X = X.X;
        X X = X.X;
        X X = X - X.X - X.X;
        X X = X - X.X - X.X;

        switch(X)
        {
        case X:
            X += X(X, X, X);
            X -= (X - X.X);
            break;
        case X:
            X -= X(X, X, X);
            break;
        case X:
            X -= X(X, X, X);
            break;
        case X:
        default:
            X += X(X, X, X);
            X -= (X - X.X);
        }
        X.X(X, X, new X(X, X, X, X));
        X.X().X(X, X, X, X,
                X, X);
        X.X().X(X, X, X, X, X, X);
    }

    private X X()
    {
        if (!X.X())
        {
            X.X();
        }
        /* If tabPane doesn't have a peer yet, the validate() call will
         * silently fail.  We handle that by forcing a layout if tabPane
         * is still invalid.  See bug 4237677.
         */
        if (!X.X())
        {
            X X = (X)X.X();
            X.X();
        }
    }


    protected X X(X X)
    {
        X X = X(X.X().X(
                X));
        X X = X.X();
        X X = 0;
        X X = X.X();
        for(X X = 0; X < X; X++)
        {
            X = X.X(X(X, X, X), X);
        }
        return X;
    }

    protected X X(X X, X X,
                                    X X)
    {
        X X = X(X);
        X X = X(X, X);
        X X = X.X + X.X + 0;
        X X = X.X(X);
        if (X != 0)
        {
            X += X.X().X;
        }
        else
        {
            if (X != 0)
            {
                X += X.X() + X;
            }
            X X = X(X);
            if (X != 0)
            {
                // html
                X += (X) X.X(X.X);
            }
            else
            {
                // plain text
                X X = X.X(X);
                X += X.X().X(X).
                         X(X, X.X(),
                                            X, X);
            }
        }
        return X;
    }

    protected X X(X X)
    {
        X X = X(X.X().X(
                X));
        X X = X.X();
        X X = 0;
        for(X X = 0; X < X; X++)
        {
            X = X.X(X(X, X, X),
                              X);
        }
        return X;
    }

    protected X X(X X, X X)
    {
        X(X, 0, 0, 0,
                         (X() == X));
        return X;
    }

    protected X X()
    {
        return X(X.X().X(X));
    }

    protected X X(X X)
    {
        return X.X(X);
    }

    private X X(X X, X X,
                                  X X, X X, X X)
    {
        X X = 0;
        if (!X.X() || !X.X(X))
        {
            X |= X.X;
            if (X)
            {
                X |= X.X;
            }
        }
        else if (X)
        {
            X |= (X.X | X.X);
            if (X && X.X(0))
            {
                X |= X.X;
            }
        }
        else if (X)
        {
            X |= (X.X | X.X);
        }
        else
        {
            X = X.X(X);
            X &= ~X.X; // don't use tabbedpane focus state
        }
        if (X && X.X())
        {
            X |= X.X; // individual tab has focus
        }
        if (X)
        {
            X |= X.X;
        }

        X.X(X);
    }

    /**
     * @inheritDoc
     *
     * Overridden to create a TabbedPaneLayout subclass which takes into
     * account tabOverlap.
     */
    @X protected X X()
    {
        if (X.X() == X.X)
        {
            return X.X();
        }
        else     /* WRAP_TAB_LAYOUT */
        {
            return new X()
            {
                @X
                public X X()
                {
                    X.X();
                    //shift all the tabs, if necessary
                    if (X != 0)
                    {
                        X X = X.X();
                        //left-to-right/right-to-left only affects layout
                        //when placement is TOP or BOTTOM
                        X X = X.X().X();
                        for (X X = X - 0; X >= 0; X--)
                        {
                            X X = X[X];
                            X X = X[(X == X - 0)? 0 : X + 0];
                            X X = (X != 0? X - 0: X - 0);
                            for (X X = X+0; X <= X; X++)
                            {
                                // xshift and yshift represent the amount &
                                // direction to shift the tab in their
                                // respective axis.
                                X X = 0;
                                X X = 0;
                                // configure xshift and y shift based on tab
                                // position and ltr/rtl
                                switch (X.X())
                                {
                                case X.X:
                                case X.X:
                                    X = X ? X : -X;
                                    break;
                                case X.X:
                                case X.X:
                                    X = X;
                                    break;
                                default: //do nothing
                                }
                                X[X].X += X;
                                X[X].X += X;
                                X[X].X += X.X(X);
                                X[X].X += X.X(X);
                            }
                        }
                    }
                }
            };
        }
    }

    private class X extends X implements
        X
    {
        public X(X X)
        {
            X(X);
        }
    }
}
