  public void setPositions(boolean check) {
    int max_additional_bytes = 0, additional_bytes = 0;
    int index = 0, count = 0;
    int[] pos = new int[length];

    /* Pass 0: Sanity checks
     */
    if(check) {
      for(InstructionHandle ih=start; ih != null; ih = ih.next) {
        Instruction i = ih.instruction;

        if(i instanceof BranchInstruction) { // target instruction within list?
          Instruction inst = ((BranchInstruction)i).getTarget().instruction;
          if(!contains(inst))
            throw new ClassGenException("Branch target of " +
                                        Constants.OPCODE_NAMES[i.opcode] + ":" +
                                        inst + " not in instruction list");

          if(i instanceof Select) {
            InstructionHandle[] targets = ((Select)i).getTargets();

            for(int j=0; j < targets.length; j++) {
              inst = targets[j].instruction;
              if(!contains(inst))
                throw new ClassGenException("Branch target of " +
                                            Constants.OPCODE_NAMES[i.opcode] + ":" +
                                            inst + " not in instruction list");
            }
          }

          if(!(ih instanceof BranchHandle))
            throw new ClassGenException("Branch instruction " +
                                        Constants.OPCODE_NAMES[i.opcode] + ":" +
                                        inst + " not contained in BranchHandle.");

        }
      }
    }

    /* Pass 1: Set position numbers and sum up the maximum number of bytes an
     * instruction may be shifted.
     */
    for(InstructionHandle ih=start; ih != null; ih = ih.next) {
      Instruction i = ih.instruction;

      ih.setPosition(index);
      pos[count++] = index;

      /* Get an estimate about how many additional bytes may be added, because
       * BranchInstructions may have variable length depending on the target
       * offset (short vs. int) or alignment issues (TABLESWITCH and
       * LOOKUPSWITCH).
       */
      switch(i.getOpcode()) {
      case Constants.JSR: case Constants.GOTO:
        max_additional_bytes += 2;
        break;

      case Constants.TABLESWITCH: case Constants.LOOKUPSWITCH:
        max_additional_bytes += 3;
        break;
      }

      index += i.getLength();
    }

    /* Pass 2: Expand the variable-length (Branch)Instructions depending on
     * the target offset (short or int) and ensure that branch targets are
     * within this list.
     */
    for(InstructionHandle ih=start; ih != null; ih = ih.next)
      additional_bytes += ih.updatePosition(additional_bytes, max_additional_bytes);

    /* Pass 3: Update position numbers (which may have changed due to the
     * preceding expansions), like pass 1.
     */
    index=count=0;
    for(InstructionHandle ih=start; ih != null; ih = ih.next) {
      Instruction i = ih.instruction;

      ih.setPosition(index);
      pos[count++] = index;
      index += i.getLength();
    }

    byte_positions = new int[count]; // Trim to proper size
    System.arraycopy(pos, 0, byte_positions, 0, count);
  }
